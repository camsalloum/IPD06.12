/**
 * AEBF (Actual/Estimate/Budget/Forecast) API Routes
 * Handles data retrieval and upload operations for AEBF feature
 * 
 * Step 3: Basic API Structure
 */

const express = require('express');
const router = express.Router();
const { pool } = require('../database/config');
const { getDivisionPool } = require('../utils/divisionDatabaseManager');
const path = require('path');
const fs = require('fs');
const DivisionMergeRulesService = require('../database/DivisionMergeRulesService');
const { saveLiveSalesRepBudget } = require('../services/salesRepBudgetService');
const { saveDivisionalBudget, getDivisionalBudgetInfo } = require('../services/divisionalBudgetService');

/**
 * Helper function to extract division code from full division name
 * e.g., "FP-UAE" -> "fp", "PP-KSA" -> "pp"
 */
function extractDivisionCode(division) {
  if (!division) return 'fp'; // Default to FP for backward compatibility
  return division.split('-')[0].toLowerCase();
}

/**
 * Helper function to get the correct database pool for a division
 * Uses division-specific database (e.g., fp_database, pp_database)
 */
function getPoolForDivision(division) {
  const divisionCode = extractDivisionCode(division);
  return getDivisionPool(divisionCode.toUpperCase());
}

/**
 * Helper function to get table names for a division
 * ALL tables are division-prefixed: fp_data_excel, pp_data_excel, etc.
 * Only ip_auth_database tables are shared across divisions.
 */
function getTableNames(division) {
  const code = extractDivisionCode(division);
  return {
    dataExcel: `${code}_data_excel`,
    materialPercentages: `${code}_material_percentages`,
    divisionalBudget: `${code}_divisional_budget`,
    salesRepBudget: `${code}_sales_rep_budget`,
    salesRepBudgetDraft: `${code}_sales_rep_budget_draft`,
    pricingRounding: `${code}_product_group_pricing_rounding`,
    customerMergeRules: `${code}_customer_merge_rules`,
    mergeRuleSuggestions: `${code}_merge_rule_suggestions`,
    mergeRuleNotifications: `${code}_merge_rule_notifications`,
    mergeRuleRejections: `${code}_merge_rule_rejections`,
    databaseUploadLog: `${code}_database_upload_log`,
    customerSimilarityCache: `${code}_customer_similarity_cache`
  };
}

// ============================================================================
// HEALTH CHECK ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/health
 * Health check endpoint to verify AEBF API is running
 */
router.get('/health', async (req, res) => {
  try {
    // Get division from query param, default to FP for backward compatibility
    const division = req.query.division || 'FP';
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    // Test database connection
    const result = await divisionPool.query('SELECT NOW() as current_time, version() as pg_version');
    
    // Check if data_excel table exists and get row count
    const tableCheck = await divisionPool.query(`
      SELECT 
        COUNT(*) as total_records,
        COUNT(DISTINCT division) as divisions,
        MIN(year) as min_year,
        MAX(year) as max_year
      FROM public.${tables.dataExcel}
    `);
    
    res.json({
      success: true,
      status: 'healthy',
      timestamp: result.rows[0].current_time,
      database: {
        connected: true,
        version: result.rows[0].pg_version,
        division: division,
        table: tables.dataExcel,
        totalRecords: parseInt(tableCheck.rows[0].total_records),
        divisions: parseInt(tableCheck.rows[0].divisions),
        yearRange: `${tableCheck.rows[0].min_year}-${tableCheck.rows[0].max_year}`
      }
    });
  } catch (error) {
    console.error('‚ùå AEBF Health check failed:', error);
    res.status(500).json({
      success: false,
      status: 'unhealthy',
      error: error.message
    });
  }
});

// ============================================================================
// GET ACTUAL DATA ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/actual
 * Retrieve Actual data from fp_data_excel table
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - page: Page number for pagination (default: 1)
 * - pageSize: Records per page (default: 100, max: 1000)
 * - year: Filter by specific year
 * - month: Filter by specific month
 * - values_type: Filter by values type (AMOUNT, KGS, MORM)
 * - salesrepname: Filter by sales rep name
 * - customername: Filter by customer name (partial match)
 * - countryname: Filter by country name
 * - productgroup: Filter by product group
 * - sortBy: Sort field (year, month, values, customername, etc.)
 * - sortOrder: Sort direction (asc, desc) - default: desc
 * - search: Search across customer, country, product group (partial match)
 * 
 * Returns:
 * {
 *   success: true,
 *   data: [...],
 *   pagination: { total, page, pageSize, totalPages },
 *   filters: { applied filters }
 * }
 */
router.get('/actual', async (req, res) => {
  try {
    const {
      division,
      page = 1,
      pageSize = 100,
      year,
      month,
      values_type,
      salesrepname,
      customername,
      countryname,
      productgroup,
      sortBy = 'year',
      sortOrder = 'desc',
      search,
      types // New parameter: comma-separated types like "Actual,Estimate"
    } = req.query;
    
    // Validate required parameters
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    // Validate division value
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Validate and limit page size
    const limit = Math.min(parseInt(pageSize) || 100, 1000);
    const offset = (parseInt(page) - 1) * limit;
    
    // Build WHERE clause
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      conditions.push(`UPPER(type) IN (${typePlaceholders})`);
      params.push(...typeArray);
      paramIndex += typeArray.length;
    } else {
      // Default to Actual only for backward compatibility
      conditions.push("UPPER(type) = 'ACTUAL'");
    }
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    if (salesrepname) {
      conditions.push(`UPPER(salesrepname) = $${paramIndex}`);
      params.push(salesrepname.toUpperCase());
      paramIndex++;
    }
    
    if (customername) {
      conditions.push(`UPPER(customername) LIKE $${paramIndex}`);
      params.push(`%${customername.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (countryname) {
      conditions.push(`UPPER(countryname) = $${paramIndex}`);
      params.push(countryname.toUpperCase());
      paramIndex++;
    }
    
    if (productgroup) {
      conditions.push(`UPPER(productgroup) LIKE $${paramIndex}`);
      params.push(`%${productgroup.toUpperCase()}%`);
      paramIndex++;
    }
    
    // Global search across multiple fields
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Build ORDER BY clause
    const validSortFields = ['year', 'month', 'values', 'customername', 'countryname', 'productgroup', 'salesrepname', 'values_type'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'year';
    const sortDirection = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';
    const orderByClause = `ORDER BY ${sortField} ${sortDirection}, id DESC`;
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    // Get total count for pagination
    const countQuery = `
      SELECT COUNT(*) as total
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
    `;
    const countResult = await divisionPool.query(countQuery, params);
    const total = parseInt(countResult.rows[0].total);
    
    // Get paginated data
    const dataQuery = `
      SELECT 
        id,
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
      ${orderByClause}
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(limit, offset);
    
    const dataResult = await divisionPool.query(dataQuery, params);
    
    // Build filters object for response
    const appliedFilters = { division };
    if (year) appliedFilters.year = year;
    if (month) appliedFilters.month = month;
    if (values_type) appliedFilters.values_type = values_type;
    if (salesrepname) appliedFilters.salesrepname = salesrepname;
    if (customername) appliedFilters.customername = customername;
    if (countryname) appliedFilters.countryname = countryname;
    if (productgroup) appliedFilters.productgroup = productgroup;
    if (search) appliedFilters.search = search;
    if (sortBy) appliedFilters.sortBy = sortBy;
    if (sortOrder) appliedFilters.sortOrder = sortOrder;
    
    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: limit,
        totalPages: Math.ceil(total / limit)
      },
      filters: appliedFilters
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching actual data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET BUDGET DATA ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/budget
 * Retrieve Budget data from fp_data_excel table
 * Same parameters and structure as /actual endpoint
 */
router.get('/budget', async (req, res) => {
  try {
    const {
      division,
      page = 1,
      pageSize = 100,
      year,
      month,
      values_type,
      search // Add search parameter
    } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const limit = Math.min(parseInt(pageSize) || 100, 1000);
    const offset = (parseInt(page) - 1) * limit;
    
    const conditions = ['UPPER(division) = $1', "type = 'Budget'"];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    // Global search with month name recognition
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const countQuery = `
      SELECT COUNT(*) as total
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
    `;
    const countResult = await divisionPool.query(countQuery, params);
    const total = parseInt(countResult.rows[0].total);
    
    const dataQuery = `
      SELECT 
        id,
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
      ORDER BY year DESC, month DESC, id DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(limit, offset);
    
    const dataResult = await divisionPool.query(dataQuery, params);
    
    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: limit,
        totalPages: Math.ceil(total / limit)
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching budget data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET SUMMARY STATISTICS ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/summary
 * Get summary statistics for a division
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 * 
 * Returns summary by year, month, values_type
 */
router.get('/summary', async (req, res) => {
  try {
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const summaryQuery = `
      SELECT 
        type,
        values_type,
        COUNT(*) as record_count,
        SUM(values) as total_values,
        AVG(values) as avg_values,
        MIN(values) as min_values,
        MAX(values) as max_values
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
      GROUP BY type, values_type
      ORDER BY values_type
    `;
    
    const result = await divisionPool.query(summaryQuery, params);
    
    res.json({
      success: true,
      summary: result.rows
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching summary:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET YEAR-SPECIFIC SUMMARY ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/year-summary
 * Get summary statistics for a specific year or all years
 * Returns totals for AMOUNT, KGS, MORM
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - REQUIRED
 * - year: Filter by year - OPTIONAL (if omitted, returns all years)
 * - search: Optional search filter across multiple fields
 */
router.get('/year-summary', async (req, res) => {
  try {
    const { division, type, types, year, search } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Build WHERE clause with optional year and search
    let whereClause = `WHERE UPPER(division) = $1`;
    const queryParams = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      whereClause += ` AND UPPER(type) IN (${typePlaceholders})`;
      queryParams.push(...typeArray);
      paramIndex += typeArray.length;
    } else if (type) {
      // Single type for backward compatibility
      whereClause += ` AND UPPER(type) = $${paramIndex}`;
      queryParams.push(type.toUpperCase());
      paramIndex++;
    }
    
    // Add year filter if provided
    if (year) {
      whereClause += ` AND year = $${paramIndex}`;
      queryParams.push(parseInt(year));
      paramIndex++;
    }
    
    // Add search filter if provided
    if (search && search.trim()) {
      const searchPattern = `%${search.trim().toUpperCase()}%`;
      whereClause += ` AND (
        UPPER(customername) LIKE $${paramIndex} OR
        UPPER(countryname) LIKE $${paramIndex} OR
        UPPER(productgroup) LIKE $${paramIndex} OR
        UPPER(salesrepname) LIKE $${paramIndex} OR
        UPPER(material) LIKE $${paramIndex}
      )`;
      queryParams.push(searchPattern);
    }
    
    const summaryQuery = `
      SELECT 
        values_type,
        COUNT(*) as record_count,
        SUM(values) as total_values,
        AVG(values) as avg_values,
        MIN(values) as min_values,
        MAX(values) as max_values
      FROM public.${getTableNames(division).dataExcel}
      ${whereClause}
      GROUP BY values_type
      ORDER BY values_type
    `;
    
    const result = await getPoolForDivision(division).query(summaryQuery, queryParams);
    
    res.json({
      success: true,
      summary: result.rows
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching year summary:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET FILTER OPTIONS ENDPOINT (all unique values for column filters)
// ============================================================================

/**
 * GET /api/aebf/filter-options
 * Get all unique values for each filterable column
 * Returns an object with arrays of unique values for each column
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 */
router.get('/filter-options', async (req, res) => {
  try {
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    // Get distinct values for each filterable column
    const filterOptionsQuery = `
      SELECT 
        ARRAY_AGG(DISTINCT year ORDER BY year) FILTER (WHERE year IS NOT NULL) as years,
        ARRAY_AGG(DISTINCT month ORDER BY month) FILTER (WHERE month IS NOT NULL) as months,
        ARRAY_AGG(DISTINCT salesrepname ORDER BY salesrepname) FILTER (WHERE salesrepname IS NOT NULL) as salesreps,
        ARRAY_AGG(DISTINCT customername ORDER BY customername) FILTER (WHERE customername IS NOT NULL) as customers,
        ARRAY_AGG(DISTINCT countryname ORDER BY countryname) FILTER (WHERE countryname IS NOT NULL) as countries,
        ARRAY_AGG(DISTINCT productgroup ORDER BY productgroup) FILTER (WHERE productgroup IS NOT NULL) as productgroups,
        ARRAY_AGG(DISTINCT material ORDER BY material) FILTER (WHERE material IS NOT NULL) as materials,
        ARRAY_AGG(DISTINCT values_type ORDER BY values_type) FILTER (WHERE values_type IS NOT NULL) as valuetypes
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
    `;
    
    const result = await divisionPool.query(filterOptionsQuery, params);
    const row = result.rows[0];
    
    // Format response
    const filterOptions = {
      year: row.years || [],
      month: row.months || [],
      salesrepname: row.salesreps || [],
      customername: row.customers || [],
      countryname: row.countries || [],
      productgroup: row.productgroups || [],
      material: row.materials || [],
      values_type: row.valuetypes || []
    };
    
    res.json({
      success: true,
      filterOptions
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching filter options:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET DISTINCT VALUES ENDPOINT (for dropdowns/filters)
// ============================================================================

/**
 * GET /api/aebf/distinct/:field
 * Get distinct values for a specific field (for filter dropdowns)
 * 
 * URL Parameters:
 * - field: Field name (salesrepname, customername, countryname, productgroup, year, month)
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 * 
 * Returns array of distinct values
 */
router.get('/distinct/:field', async (req, res) => {
  try {
    const { field } = req.params;
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Validate field name to prevent SQL injection
    const validFields = ['salesrepname', 'customername', 'countryname', 'productgroup', 'year', 'month', 'values_type', 'material', 'process'];
    if (!validFields.includes(field)) {
      return res.status(400).json({
        success: false,
        error: `Invalid field. Must be one of: ${validFields.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const distinctQuery = `
      SELECT DISTINCT ${field}
      FROM public.${tables.dataExcel}
      WHERE ${whereClause} AND ${field} IS NOT NULL
      ORDER BY ${field}
    `;
    
    const result = await divisionPool.query(distinctQuery, params);
    
    res.json({
      success: true,
      field,
      values: result.rows.map(row => row[field])
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching distinct values:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET EXPORT DATA ENDPOINT (for CSV/Excel export)
// ============================================================================

/**
 * GET /api/aebf/export
 * Export data in CSV format (same filters as /actual endpoint)
 * 
 * Query Parameters: Same as /actual endpoint
 * Returns: CSV formatted data
 */
router.get('/export', async (req, res) => {
  try {
    const {
      division,
      year,
      month,
      values_type,
      salesrepname,
      customername,
      countryname,
      productgroup,
      sortBy = 'year',
      sortOrder = 'desc',
      search,
      types // Add types parameter
    } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Build WHERE clause (same logic as /actual)
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      conditions.push(`UPPER(type) IN (${typePlaceholders})`);
      params.push(...typeArray);
      paramIndex += typeArray.length;
    } else {
      // Default to Actual only for backward compatibility
      conditions.push("UPPER(type) = 'ACTUAL'");
    }
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    if (salesrepname) {
      conditions.push(`UPPER(salesrepname) = $${paramIndex}`);
      params.push(salesrepname.toUpperCase());
      paramIndex++;
    }
    
    if (customername) {
      conditions.push(`UPPER(customername) LIKE $${paramIndex}`);
      params.push(`%${customername.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (countryname) {
      conditions.push(`UPPER(countryname) = $${paramIndex}`);
      params.push(countryname.toUpperCase());
      paramIndex++;
    }
    
    if (productgroup) {
      conditions.push(`UPPER(productgroup) LIKE $${paramIndex}`);
      params.push(`%${productgroup.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Build ORDER BY clause
    const validSortFields = ['year', 'month', 'values', 'customername', 'countryname', 'productgroup', 'salesrepname', 'values_type'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'year';
    const sortDirection = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';
    const orderByClause = `ORDER BY ${sortField} ${sortDirection}, id DESC`;
    
    // Limit export to 10000 records to prevent memory issues
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const exportQuery = `
      SELECT 
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.${tables.dataExcel}
      WHERE ${whereClause}
      ${orderByClause}
      LIMIT 10000
    `;
    
    const result = await divisionPool.query(exportQuery, params);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No data found for export'
      });
    }
    
    // Convert to CSV
    const headers = Object.keys(result.rows[0]);
    const csvRows = [
      headers.join(','), // Header row
      ...result.rows.map(row => 
        headers.map(header => {
          const value = row[header];
          // Escape values with commas or quotes
          if (value === null || value === undefined) return '';
          const stringValue = String(value);
          if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
            return `"${stringValue.replace(/"/g, '""')}"`;
          }
          return stringValue;
        }).join(',')
      )
    ];
    
    const csv = csvRows.join('\n');
    
    // Generate filename with year, date, and time
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, ''); // YYYYMMDD
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, ''); // HHMMSS
    const dateTime = `${dateStr}-${timeStr}`;
    
    // Determine type label for filename
    let typeLabel = 'Data';
    if (types) {
      const typeArray = types.split(',').map(t => t.trim());
      if (typeArray.length === 1) {
        typeLabel = typeArray[0];
      } else {
        typeLabel = 'Multi';
      }
    }
    
    // Build filename: AEBF-{Type}-{Division}-{Year}-{DateTime}.csv
    let filename = `AEBF-${typeLabel}-${division.toUpperCase()}`;
    if (year) {
      filename += `-${year}`;
    }
    filename += `-${dateTime}.csv`;
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(csv);
    
  } catch (error) {
    console.error('‚ùå Error exporting data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// POST UPLOAD ACTUAL DATA ENDPOINT
// ============================================================================

/**
 * POST /api/aebf/upload-actual
 * Handle Excel file upload and transform to SQL
 * Calls PowerShell script to process the upload
 * 
 * Form Data:
 * - file: Excel file (.xlsx)
 * - division: Division code (FP, SB, TF, HCM)
 * - uploadMode: upsert or replace
 * - uploadedBy: Username
 */
const multer = require('multer');
const { spawn } = require('child_process');

// Configure multer for file upload
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../../uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    cb(null, `aebf-upload-${timestamp}${ext}`);
  }
});

const upload = multer({
  storage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (ext !== '.xlsx' && ext !== '.xls') {
      return cb(new Error('Only Excel files are allowed'));
    }
    cb(null, true);
  },
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB max
  }
});

router.post('/upload-actual', upload.single('file'), async (req, res) => {
  try {
    const { division, uploadMode, uploadedBy } = req.body;
    const filePath = req.file.path;
    
    console.log('üì§ Upload request received:', {
      division,
      uploadMode,
      uploadedBy,
      fileName: req.file.originalname,
      fileSize: req.file.size
    });
    
    // Validate parameters
    if (!division || !['FP', 'SB', 'TF', 'HCM'].includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid division parameter'
      });
    }
    
    if (!uploadMode || !['upsert', 'replace'].includes(uploadMode.toLowerCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid uploadMode parameter'
      });
    }
    
    if (!uploadedBy) {
      return res.status(400).json({
        success: false,
        error: 'uploadedBy parameter is required'
      });
    }
    
    // Path to PowerShell script
    const scriptPath = path.join(__dirname, '../../scripts/transform-actual-to-sql.ps1');
    
    if (!fs.existsSync(scriptPath)) {
      return res.status(500).json({
        success: false,
        error: 'Transform script not found'
      });
    }
    
    // Execute PowerShell script
    console.log('üîÑ Executing PowerShell script...');
    
    const psArgs = [
      '-ExecutionPolicy', 'Bypass',
      '-File', scriptPath,
      '-ExcelPath', filePath,
      '-Division', division.toUpperCase(),
      '-UploadMode', uploadMode.toLowerCase(),
      '-UploadedBy', uploadedBy
    ];
    
    // Add selective year/month filter if provided
    if (req.body.selectiveMode === 'true' && req.body.selectedYearMonths) {
      const selectedYearMonths = JSON.parse(req.body.selectedYearMonths);
      psArgs.push('-SelectiveYearMonths', selectedYearMonths.join(','));
      console.log('üìÖ Selective mode enabled:', selectedYearMonths);
    }
    
    const psProcess = spawn('powershell.exe', psArgs);
    
    let stdout = '';
    let stderr = '';
    
    psProcess.stdout.on('data', (data) => {
      const output = data.toString();
      stdout += output;
      console.log(output);
    });
    
    psProcess.stderr.on('data', (data) => {
      const error = data.toString();
      stderr += error;
      console.error(error);
    });
    
    psProcess.on('close', (code) => {
      console.log(`PowerShell script exited with code ${code}`);
      
      // Clean up uploaded file
      try {
        fs.unlinkSync(filePath);
        console.log('‚úÖ Cleaned up uploaded file');
      } catch (err) {
        console.error('‚ö†Ô∏è  Failed to clean up file:', err);
      }
      
      if (code === 0) {
        // Parse output for results
        const recordsMatch = stdout.match(/Total records processed: (\d+)/);
        const recordsAffected = recordsMatch ? parseInt(recordsMatch[1]) : 0;
        
        res.json({
          success: true,
          message: 'Upload completed successfully',
          division: division.toUpperCase(),
          uploadMode,
          uploadedBy,
          recordsAffected,
          output: stdout,
          logFile: stdout.match(/Log file: (.+)/)?.[1]
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'PowerShell script failed',
          details: stderr || stdout,
          exitCode: code
        });
      }
    });
    
    psProcess.on('error', (error) => {
      console.error('‚ùå Failed to start PowerShell script:', error);
      
      // Clean up uploaded file
      try {
        fs.unlinkSync(filePath);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      res.status(500).json({
        success: false,
        error: 'Failed to execute transform script',
        details: error.message
      });
    });
    
  } catch (error) {
    console.error('‚ùå Upload endpoint error:', error);
    
    // Clean up file if exists
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// BUDGET ENDPOINTS
// ============================================================================

/**
 * GET /api/aebf/budget
 * Retrieve Budget data for a specific division and year
 * 
 * Query params:
 * - division: Division code (required)
 * - year: Year (required)
 * - month: Month filter (optional)
 * - search: Global search term (optional)
 */
router.get('/budget', async (req, res) => {
  try {
    const { division, year, month, search, page, pageSize } = req.query;
    
    console.log('üìä Get budget data request:', { division, year, month, search, page, pageSize });
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division is required'
      });
    }
    
    let query = `
      SELECT 
        id, division, type, year, month, customername, salesrepname, 
        countryname, productgroup, material, process, values_type, values,
        sourcesheet, created_at, updated_at, uploaded_by
      FROM ${getTableNames(division).dataExcel}
      WHERE division = $1 AND type = 'Budget'
    `;
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    if (year) {
      query += ` AND year = $${paramIndex}`;
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      query += ` AND month = $${paramIndex}`;
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (search) {
      query += ` AND (
        LOWER(customername) LIKE $${paramIndex} OR
        LOWER(salesrepname) LIKE $${paramIndex} OR
        LOWER(countryname) LIKE $${paramIndex} OR
        LOWER(productgroup) LIKE $${paramIndex}
      )`;
      params.push(`%${search.toLowerCase()}%`);
      paramIndex++;
    }
    
    query += ' ORDER BY year DESC, month, customername';
    
    // Add pagination
    const currentPage = parseInt(page) || 1;
    const limit = parseInt(pageSize) || 50;
    const offset = (currentPage - 1) * limit;
    
    // Get division-specific pool
    const divisionPool = getPoolForDivision(division);
    
    // Get total count
    const countQuery = query.replace(/SELECT[\s\S]+FROM/, 'SELECT COUNT(*) FROM');
    const countResult = await divisionPool.query(countQuery, params);
    const totalRecords = parseInt(countResult.rows[0].count);
    
    // Add limit and offset
    query += ` LIMIT ${limit} OFFSET ${offset}`;
    
    const result = await divisionPool.query(query, params);
    
    const summary = {
      totalAmount: result.rows.filter(r => r.values_type === 'AMOUNT').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      totalKgs: result.rows.filter(r => r.values_type === 'KGS').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      totalMorm: result.rows.filter(r => r.values_type === 'MORM').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      recordCount: result.rows.length
    };
    
    console.log(`‚úÖ Found ${result.rows.length} budget records (page ${currentPage} of ${Math.ceil(totalRecords / limit)})`);
    
    res.json({
      success: true,
      data: result.rows,
      summary,
      pagination: {
        page: currentPage,
        pageSize: limit,
        total: totalRecords
      }
    });
    
  } catch (error) {
    console.error('‚ùå Get budget error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/upload-budget
 * Handle Budget Excel file upload and transform to SQL
 */
router.post('/upload-budget', upload.single('file'), async (req, res) => {
  try {
    const { division, uploadMode, uploadedBy, selectedYearMonths } = req.body;
    const filePath = req.file.path;
    
    console.log('üì§ Budget upload request received:', {
      division,
      uploadMode: uploadMode || 'replace',
      uploadedBy,
      selectedYearMonths,
      fileName: req.file.originalname,
      fileSize: req.file.size
    });
    
    if (!division || !['FP', 'SB', 'TF', 'HCM'].includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid division parameter'
      });
    }
    
    const mode = uploadMode ? uploadMode.toLowerCase() : 'replace';
    if (!['upsert', 'replace'].includes(mode)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid uploadMode parameter'
      });
    }
    
    if (!uploadedBy) {
      return res.status(400).json({
        success: false,
        error: 'uploadedBy parameter is required'
      });
    }
    
    const scriptPath = path.join(__dirname, '../../scripts/transform-budget-to-sql.ps1');
    
    if (!fs.existsSync(scriptPath)) {
      return res.status(500).json({
        success: false,
        error: 'Budget transform script not found'
      });
    }
    
    console.log('üîÑ Executing Budget PowerShell script...');
    
    const psArgs = [
      '-ExecutionPolicy', 'Bypass',
      '-File', scriptPath,
      '-ExcelPath', filePath,
      '-Division', division.toUpperCase(),
      '-UploadMode', mode,
      '-UploadedBy', uploadedBy
    ];
    
    if (selectedYearMonths) {
      psArgs.push('-SelectiveYearMonths', selectedYearMonths);
    }
    
    const psProcess = spawn('powershell.exe', psArgs);
    
    let stdout = '';
    let stderr = '';
    
    psProcess.stdout.on('data', (data) => {
      const output = data.toString();
      stdout += output;
      console.log(output);
    });
    
    psProcess.stderr.on('data', (data) => {
      const output = data.toString();
      stderr += output;
      console.error(output);
    });
    
    psProcess.on('close', (code) => {
      try {
        fs.unlinkSync(filePath);
        console.log('üóëÔ∏è Cleaned up uploaded file');
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      if (code === 0) {
        console.log('‚úÖ Budget upload completed successfully');
        res.json({
          success: true,
          message: 'Budget data uploaded successfully',
          output: stdout,
          mode: mode
        });
      } else {
        console.error('‚ùå Budget upload failed with exit code:', code);
        res.status(500).json({
          success: false,
          error: 'Budget upload failed',
          details: stderr || stdout,
          exitCode: code
        });
      }
    });
    
    psProcess.on('error', (error) => {
      console.error('‚ùå PowerShell process error:', error);
      
      try {
        fs.unlinkSync(filePath);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      res.status(500).json({
        success: false,
        error: 'Failed to execute budget transform script',
        details: error.message
      });
    });
    
  } catch (error) {
    console.error('‚ùå Budget upload error:', error);
    
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// ANALYZE FILE ENDPOINT (preview year/month combinations)
// ============================================================================

/**
 * POST /api/aebf/analyze-file
 * Analyze Excel file to extract year/month combinations
 * Returns list of year/month with record counts
 */
router.post('/analyze-file', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded'
      });
    }
    
    const filePath = req.file.path;
    console.log('üìä Analyzing file:', filePath);
    
    // Read Excel file
    const XLSX = require('xlsx');
    const workbook = XLSX.readFile(filePath);
    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
    const data = XLSX.utils.sheet_to_json(firstSheet);
    
    // Extract year/month combinations with counts
    const yearMonthMap = new Map();
    
    data.forEach(row => {
      if (row.year && row.month && row.customername) {
        const key = `${row.year}-${row.month}`;
        if (yearMonthMap.has(key)) {
          yearMonthMap.set(key, yearMonthMap.get(key) + 1);
        } else {
          yearMonthMap.set(key, 1);
        }
      }
    });
    
    // Convert to array and sort by year/month
    const yearMonths = Array.from(yearMonthMap.entries())
      .map(([key, count]) => {
        const [year, month] = key.split('-').map(Number);
        return { year, month, count };
      })
      .sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.month - b.month;
      });
    
    // Clean up uploaded file
    try {
      fs.unlinkSync(filePath);
    } catch (err) {
      console.error('Failed to clean up file:', err);
    }
    
    res.json({
      success: true,
      yearMonths,
      totalRecords: data.length,
      totalPeriods: yearMonths.length
    });
    
  } catch (error) {
    console.error('‚ùå Analyze file error:', error);
    
    // Clean up file if exists
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// ESTIMATE ENDPOINTS
// ============================================================================

/**
 * Get Available Actual Months
 * GET /api/aebf/available-months
 * Gets all distinct months with Actual data for a division and year
 * 
 * Query params:
 * - division: Division code (required)
 * - year: Year (required)
 * 
 * Response:
 * - months: Array of month numbers
 */
router.get('/available-months', async (req, res) => {
  const { division, year } = req.query;
  
  console.log('üìÖ Get available months request:', { division, year });
  
  // Validate required parameters
  if (!division || !year) {
    return res.status(400).json({
      success: false,
      error: 'Division and year are required'
    });
  }
  
  try {
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT DISTINCT month
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const result = await divisionPool.query(query, [division.toUpperCase(), parseInt(year)]);
    const months = result.rows.map(row => row.month);
    
    console.log(`‚úÖ Found ${months.length} Actual months:`, months);
    
    res.json({
      success: true,
      months
    });
    
  } catch (error) {
    console.error('‚ùå Get available months error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Calculate Estimate
 * POST /api/aebf/calculate-estimate
 * Calculates estimates based on average of Actual data for base period months
 * 
 * Request body:
 * - division: Division code (required)
 * - year: Year for estimation (required)
 * - selectedMonths: Array of month numbers to estimate (required)
 * - createdBy: Username (required)
 * 
 * Response:
 * - estimates: Array of monthly aggregates (month, amount, kgs, morm, recordCount)
 * - basePeriodMonths: Months used for averaging
 * - estimatedMonths: Months being estimated
 */
router.post('/calculate-estimate', async (req, res) => {
  const { division, year, selectedMonths, createdBy } = req.body;
  
  console.log('üìä Calculate estimate request:', { division, year, selectedMonths, createdBy });
  
  // Validate required parameters
  if (!division || !year || !selectedMonths || !Array.isArray(selectedMonths) || selectedMonths.length === 0) {
    return res.status(400).json({
      success: false,
      error: 'Division, year, and selectedMonths array are required'
    });
  }
  
  try {
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    // Step 1: Get all available Actual months for the year
    const allMonthsQuery = `
      SELECT DISTINCT month
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const allMonthsResult = await divisionPool.query(allMonthsQuery, [division.toUpperCase(), year]);
    const allActualMonths = allMonthsResult.rows.map(row => row.month);
    
    console.log('üìÖ All Actual months:', allActualMonths);
    
    // Step 2: Calculate base period (Actual months NOT in selectedMonths)
    const basePeriodMonths = allActualMonths.filter(m => !selectedMonths.includes(m));
    
    if (basePeriodMonths.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No base period months available for calculation. All Actual months are selected for estimation.'
      });
    }
    
    console.log('üìä Base period months (for averaging):', basePeriodMonths);
    console.log('üéØ Estimate months:', selectedMonths);
    
    // Step 3: Calculate totals per values_type for base period, then divide by number of months
    // Using simple method: SUM(all values) / number of months
    const totalsQuery = `
      SELECT 
        values_type,
        SUM(values) as total_value,
        COUNT(*) as record_count
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ACTUAL' 
        AND year = $2 
        AND month = ANY($3)
      GROUP BY values_type
      ORDER BY values_type
    `;
    
    const totalsResult = await divisionPool.query(totalsQuery, [
      division.toUpperCase(),
      year,
      basePeriodMonths
    ]);
    
    console.log(`‚úÖ Base period totals:`, totalsResult.rows);
    
    // Step 4: Calculate average per month by dividing total by number of base months
    // This is the simple Excel method: Total √∑ Months
    const monthlyAverages = {};
    totalsResult.rows.forEach(row => {
      const avgPerMonth = parseFloat(row.total_value) / basePeriodMonths.length;
      monthlyAverages[row.values_type] = {
        average: Math.round(avgPerMonth), // Round to integer
        totalRecords: parseInt(row.record_count)
      };
    });
    
    console.log('üìä Monthly averages (Simple method - Total√∑Months):', monthlyAverages);
    
    // Step 5: Create estimates for each selected month
    const monthlyAggregates = [];
    
    for (const month of selectedMonths.sort((a, b) => a - b)) {
      monthlyAggregates.push({
        month,
        amount: monthlyAverages['AMOUNT']?.average || 0,
        kgs: monthlyAverages['KGS']?.average || 0,
        morm: monthlyAverages['MORM']?.average || 0,
        recordCount: Math.round((monthlyAverages['AMOUNT']?.totalRecords || 0) / basePeriodMonths.length)
      });
    }
    
    console.log('üìà Monthly aggregates calculated:', monthlyAggregates);
    
    res.json({
      success: true,
      estimates: monthlyAggregates,
      basePeriodMonths,
      estimatedMonths: selectedMonths.sort((a, b) => a - b),
      baseMonthCount: basePeriodMonths.length
    });
    
  } catch (error) {
    console.error('‚ùå Calculate estimate error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Save Estimate
 * POST /api/aebf/save-estimate
 * Saves approved estimates to database
 * 
 * Request body:
 * - division: Division code (required)
 * - year: Year (required)
 * - estimates: Object with month keys and {amount, kgs, morm} values (required)
 * - approvedBy: Username (required)
 * 
 * Response:
 * - recordsInserted: Number of records inserted
 * - months: Array of months saved
 */
router.post('/save-estimate', async (req, res) => {
  const { division, year, estimates, approvedBy } = req.body;
  
  console.log('üíæ Save estimate request:', { division, year, estimateMonths: Object.keys(estimates), approvedBy });
  
  // Validate required parameters
  if (!division || !year || !estimates || typeof estimates !== 'object' || !approvedBy) {
    return res.status(400).json({
      success: false,
      error: 'Division, year, estimates object, and approvedBy are required'
    });
  }
  
  // Get division-specific pool and table names
  const divisionPool = getPoolForDivision(division);
  const tables = getTableNames(division);
  
  const client = await divisionPool.connect();
  
  try {
    await client.query('BEGIN');
    
    const months = Object.keys(estimates).map(Number).sort((a, b) => a - b);
    console.log('üìÖ Saving estimates for months:', months);
    
    // Step 1: Get dimension details from base period
    const basePeriodQuery = `
      SELECT DISTINCT month
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const basePeriodResult = await client.query(basePeriodQuery, [division.toUpperCase(), year]);
    const allActualMonths = basePeriodResult.rows.map(row => row.month);
    const basePeriodMonths = allActualMonths.filter(m => !months.includes(m));
    
    if (basePeriodMonths.length === 0) {
      throw new Error('No base period months available');
    }
    
    console.log('üìä Base period months:', basePeriodMonths);
    
    // Step 2: Get each dimension's PROPORTION of the total
    // We need the proportion, not the absolute values
    const dimensionQuery = `
      SELECT 
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        sourcesheet,
        values_type,
        SUM(values) as total_value
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ACTUAL' 
        AND year = $2 
        AND month = ANY($3)
      GROUP BY salesrepname, customername, countryname, productgroup, material, process, sourcesheet, values_type
    `;
    
    const dimensionResult = await client.query(dimensionQuery, [
      division.toUpperCase(),
      year,
      basePeriodMonths
    ]);
    
    console.log(`‚úÖ Found ${dimensionResult.rows.length} dimension combinations to replicate`);
    
    // Step 3: Delete existing estimates for these months
    const deleteQuery = `
      DELETE FROM public.${tables.dataExcel}
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ESTIMATE' 
        AND year = $2 
        AND month = ANY($3)
    `;
    
    const deleteResult = await client.query(deleteQuery, [
      division.toUpperCase(),
      year,
      months
    ]);
    
    console.log(`üóëÔ∏è Deleted ${deleteResult.rowCount} existing estimate records`);
    
    // Step 4: Calculate each dimension's proportion of the base period total
    // Then distribute the monthly estimate according to these proportions
    const totalsByType = {
      AMOUNT: 0,
      KGS: 0,
      MORM: 0
    };
    
    dimensionResult.rows.forEach(row => {
      const valuesType = row.values_type;
      if (totalsByType[valuesType] !== undefined) {
        totalsByType[valuesType] += parseFloat(row.total_value) || 0;
      }
    });
    
    console.log(`üìä Base period totals by values_type:`, totalsByType);
    
    // Step 5: Insert estimate records with proportional distribution
    let totalInserted = 0;
    const batchSize = 500;
    
    for (const month of months) {
      const monthEstimates = estimates[month];
      const recordsForMonth = [];
      
      // For each dimension, calculate its proportion and apply to monthly estimate
      dimensionResult.rows.forEach(row => {
        const basePeriodTotal = totalsByType[row.values_type];
        const dimensionTotal = parseFloat(row.total_value) || 0;
        const monthlyEstimateTotal = row.values_type === 'AMOUNT' ? monthEstimates.amount :
                                     row.values_type === 'KGS' ? monthEstimates.kgs :
                                     monthEstimates.morm;
        
        // Calculate this dimension's share of the monthly estimate
        // proportion = dimension_total / base_period_total
        // dimension_monthly_value = monthly_estimate * proportion
        const proportion = basePeriodTotal > 0 ? dimensionTotal / basePeriodTotal : 0;
        const dimensionMonthlyValue = monthlyEstimateTotal * proportion;
        
        recordsForMonth.push({
          division: division.toUpperCase(),
          year,
          month,
          type: 'Estimate',
          salesrepname: row.salesrepname,
          customername: row.customername,
          countryname: row.countryname,
          productgroup: row.productgroup,
          material: row.material,
          process: row.process,
          sourcesheet: 'Calculated',
          values_type: row.values_type,
          values: dimensionMonthlyValue,
          uploaded_by: approvedBy
        });
      });
      
      // Insert in batches
      for (let i = 0; i < recordsForMonth.length; i += batchSize) {
        const batch = recordsForMonth.slice(i, i + batchSize);
        
        const insertQuery = `
          INSERT INTO public.${tables.dataExcel} (
            division, year, month, type, salesrepname, customername, countryname,
            productgroup, material, process, sourcesheet, values_type, values, uploaded_by, updated_at
          ) VALUES ${batch.map((_, idx) => {
            const base = idx * 14;
            return `($${base + 1}, $${base + 2}, $${base + 3}, $${base + 4}, $${base + 5}, $${base + 6}, $${base + 7}, $${base + 8}, $${base + 9}, $${base + 10}, $${base + 11}, $${base + 12}, $${base + 13}, $${base + 14}, NOW())`;
          }).join(', ')}
        `;
        
        const insertValues = batch.flatMap(record => [
          record.division,
          record.year,
          record.month,
          record.type,
          record.salesrepname,
          record.customername,
          record.countryname,
          record.productgroup,
          record.material,
          record.process,
          record.sourcesheet,
          record.values_type,
          record.values,
          record.uploaded_by
        ]);
        
        const insertResult = await client.query(insertQuery, insertValues);
        totalInserted += insertResult.rowCount;
      }
      
      console.log(`‚úÖ Inserted ${recordsForMonth.length} records for month ${month}`);
    }
    
    await client.query('COMMIT');
    
    console.log(`‚úÖ Total inserted: ${totalInserted} estimate records`);
    
    res.json({
      success: true,
      recordsInserted: totalInserted,
      months,
      message: `Successfully saved estimates for ${months.length} months`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Save estimate error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  } finally {
    client.release();
  }
});

// ============================================================================
// HTML BUDGET FORM ENDPOINTS
// ============================================================================

// Track if indexes have been created per division (one-time check per division)
const htmlBudgetIndexesCreated = new Set();

// Track if sales rep budget table columns and constraints have been verified per division
const salesRepBudgetColumnsVerified = new Set();

/**
 * Ensure sales rep budget table has all required columns and unique constraint
 * (material, process, uploaded_filename, uploaded_at, and unique index)
 */
async function ensureSalesRepBudgetColumns(division = 'FP') {
  const divisionCode = (division || 'FP').split('-')[0].toUpperCase();
  const divisionLower = divisionCode.toLowerCase();

  // Always check columns to ensure schema is up to date
  if (salesRepBudgetColumnsVerified.has(divisionCode)) {
    return; // Already verified
  }

  try {
    const divisionPool = getPoolForDivision(division);
    const tableName = `${divisionLower}_sales_rep_budget`;

    // Check if all required columns exist
    const columnCheck = await divisionPool.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'public' 
        AND table_name = $1 
        AND column_name IN ('material', 'process', 'uploaded_filename', 'uploaded_at')
    `, [tableName]);

    const existingColumns = columnCheck.rows.map(r => r.column_name);

    // Add material column if missing
    if (!existingColumns.includes('material')) {
      await divisionPool.query(`
        ALTER TABLE public.${tableName} 
        ADD COLUMN IF NOT EXISTS material VARCHAR(255) DEFAULT ''
      `);
      console.log(`‚úÖ Added 'material' column to ${tableName}`);
    }

    // Add process column if missing
    if (!existingColumns.includes('process')) {
      await divisionPool.query(`
        ALTER TABLE public.${tableName} 
        ADD COLUMN IF NOT EXISTS process VARCHAR(255) DEFAULT ''
      `);
      console.log(`‚úÖ Added 'process' column to ${tableName}`);
    }

    // Add uploaded_filename column if missing
    if (!existingColumns.includes('uploaded_filename')) {
      await divisionPool.query(`
        ALTER TABLE public.${tableName} 
        ADD COLUMN IF NOT EXISTS uploaded_filename VARCHAR(500)
      `);
      console.log(`‚úÖ Added 'uploaded_filename' column to ${tableName}`);
    }

    // Add uploaded_at column if missing
    if (!existingColumns.includes('uploaded_at')) {
      await divisionPool.query(`
        ALTER TABLE public.${tableName} 
        ADD COLUMN IF NOT EXISTS uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      `);
      console.log(`‚úÖ Added 'uploaded_at' column to ${tableName}`);
    }

    // Ensure unique constraint exists for ON CONFLICT clause
    const constraintName = `idx_${divisionLower}_sales_rep_budget_unique`;
    const constraintCheck = await divisionPool.query(`
      SELECT indexname 
      FROM pg_indexes 
      WHERE schemaname = 'public' 
        AND tablename = $1 
        AND indexname = $2
    `, [tableName, constraintName]);

    if (constraintCheck.rows.length === 0) {
      // Create unique constraint index for ON CONFLICT clause
      await divisionPool.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS ${constraintName}
        ON public.${tableName} (
          division, 
          budget_year, 
          month, 
          type, 
          salesrepname, 
          customername, 
          countryname, 
          productgroup, 
          values_type
        )
      `);
      console.log(`‚úÖ Created unique constraint ${constraintName} on ${tableName}`);
    }

    salesRepBudgetColumnsVerified.add(divisionCode);
    console.log(`‚úÖ Sales rep budget table columns and constraints verified for ${divisionCode}`);
  } catch (error) {
    console.error(`‚ö†Ô∏è Error verifying sales rep budget columns for ${divisionCode}:`, error.message);
    // Remove from cache so it will retry on next call
    salesRepBudgetColumnsVerified.delete(divisionCode);
    // Don't throw - allow query to proceed (will fail later if columns/constraints are missing)
  }
}

/**
 * Ensure HTML budget indexes exist for a division (automatic, one-time per division)
 */
async function ensureHtmlBudgetIndexes(division = 'FP') {
  const divisionCode = (division || 'FP').split('-')[0].toUpperCase();
  const divisionLower = divisionCode.toLowerCase();
  
  if (htmlBudgetIndexesCreated.has(divisionCode)) return;
  
  try {
    const divisionPool = getPoolForDivision(division);
    const tableName = `${divisionLower}_data_excel`;
    
    // Create indexes if they don't exist
    await divisionPool.query(`
      CREATE INDEX IF NOT EXISTS idx_${divisionLower}_html_budget_customers 
      ON public.${tableName}(division, year, type, salesrepname, customername, countryname, productgroup, month) 
      WHERE type = 'Actual' AND values_type = 'KGS';
    `);
    
    await divisionPool.query(`
      CREATE INDEX IF NOT EXISTS idx_${divisionLower}_budget_insert 
      ON public.${tableName}(division, year, month, type, salesrepname, customername, countryname, productgroup, values_type)
      WHERE type = 'Budget';
    `);
    
    await divisionPool.query(`
      CREATE INDEX IF NOT EXISTS idx_${divisionLower}_actual_sales_rep_customer 
      ON public.${tableName}(division, year, type, salesrepname, customername, countryname, productgroup, month, values_type)
      WHERE type = 'Actual' AND customername IS NOT NULL AND TRIM(customername) != '';
    `);
    
    // Analyze table to update statistics
    await divisionPool.query(`ANALYZE public.${tableName};`);
    
    htmlBudgetIndexesCreated.add(divisionCode);
    console.log(`‚úÖ HTML Budget indexes created/verified for ${divisionCode}`);
  } catch (error) {
    console.error(`‚ö†Ô∏è Error creating HTML budget indexes for ${divisionCode} (will retry):`, error.message);
    // Don't throw - allow query to proceed even if index creation fails
  }
}

/**
 * POST /api/aebf/html-budget-customers-all
 * Get customer Actual sales data for ALL sales reps combined
 * Similar to html-budget-customers but aggregates all sales reps together
 */
router.post('/html-budget-customers-all', async (req, res) => {
  try {
    const { division, actualYear, salesReps } = req.body;
    
    // Ensure indexes exist (automatic, one-time per division)
    await ensureHtmlBudgetIndexes(division);
    
    if (!division || !actualYear || !Array.isArray(salesReps) || salesReps.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and salesReps array are required'
      });
    }
    
    // Fetch merge rules for the division
    const mergeRules = await DivisionMergeRulesService.listRules(division);
    const activeMergeRules = mergeRules.filter(r => r.status === 'ACTIVE' && r.is_active === true);
    
    // Build mapping from original customer names (normalized) to merged customer names
    const norm = (s) => (s || '').toString().trim().toLowerCase();
    // Helper to normalize display name: trim and clean up extra spaces
    const normalizeDisplayName = (s) => (s || '').toString().trim().replace(/\s+/g, ' ');
    // Helper function to convert string to Proper Case (Title Case)
    const toProperCase = (str) => {
      if (!str) return '';
      return str.toLowerCase().replace(/(?:^|\s|[-/])\w/g, (match) => match.toUpperCase());
    };
    const customerMergeMap = new Map();
    
    activeMergeRules.forEach(rule => {
      const mergedName = rule.merged_customer_name;
      const originalCustomers = Array.isArray(rule.original_customers) 
        ? rule.original_customers 
        : (typeof rule.original_customers === 'string' 
            ? JSON.parse(rule.original_customers) 
            : []);
      
      originalCustomers.forEach(original => {
        const normalized = norm(original);
        customerMergeMap.set(normalized, mergedName);
      });
    });
    
    // Query Actual sales data for all sales reps
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT 
        TRIM(salesrepname) as salesrep,
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value,
        SUM(CASE WHEN UPPER(values_type) = 'AMOUNT' THEN values ELSE 0 END) as amount_value,
        SUM(CASE WHEN UPPER(values_type) = 'MORM' THEN values ELSE 0 END) as morm_value
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND TRIM(UPPER(salesrepname)) = ANY($3::text[])
        AND customername IS NOT NULL
        AND TRIM(customername) != ''
        AND countryname IS NOT NULL
        AND TRIM(countryname) != ''
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    // Normalize salesReps to uppercase for matching (database query uses UPPER)
    const normalizedSalesReps = salesReps.map(sr => (sr || '').toString().trim().toUpperCase());
    
    const result = await divisionPool.query(query, [division, actualYear, normalizedSalesReps]);
    
    // Transform to table structure with merge rules applied
    const customerMap = {};
    
    result.rows.forEach(row => {
      const normalizedCustomer = norm(row.customer);
      // Use merged name if available, otherwise normalize the original name
      const displayCustomerName = customerMergeMap.get(normalizedCustomer) || normalizeDisplayName(row.customer);
      const displayCountry = normalizeDisplayName(row.country);
      const displayProductGroup = normalizeDisplayName(row.productgroup);
      // Convert sales rep name to Proper Case for consistent display
      const displaySalesRep = toProperCase(row.salesrep);
      
      const key = `${displaySalesRep}|${displayCustomerName}|${displayCountry}|${displayProductGroup}`;
      if (!customerMap[key]) {
        customerMap[key] = {
          salesRep: displaySalesRep,
          customer: displayCustomerName,
          country: displayCountry,
          productGroup: displayProductGroup,
          monthlyActual: {},
          monthlyActualAmount: {},
          monthlyActualMorm: {},
        };
      }
      const existingMtValue = customerMap[key].monthlyActual[row.month] || 0;
      const existingAmountValue = customerMap[key].monthlyActualAmount[row.month] || 0;
      const existingMormValue = customerMap[key].monthlyActualMorm[row.month] || 0;
      customerMap[key].monthlyActual[row.month] = existingMtValue + (parseFloat(row.mt_value) || 0);
      customerMap[key].monthlyActualAmount[row.month] = existingAmountValue + (parseFloat(row.amount_value) || 0);
      customerMap[key].monthlyActualMorm[row.month] = existingMormValue + (parseFloat(row.morm_value) || 0);
    });
    
    const data = Object.values(customerMap).map(item => {
      const monthlyActual = {};
      const monthlyActualAmount = {};
      const monthlyActualMorm = {};
      for (let month = 1; month <= 12; month++) {
        monthlyActual[month] = item.monthlyActual[month] || 0;
        monthlyActualAmount[month] = item.monthlyActualAmount[month] || 0;
        monthlyActualMorm[month] = item.monthlyActualMorm[month] || 0;
      }
      return {
        ...item,
        monthlyActual,
        monthlyActualAmount,
        monthlyActualMorm,
      };
    });
    
    // Load budget data from division-specific sales_rep_budget table
    const budgetYear = parseInt(actualYear) + 1;
    console.log(`üìä Loading budget data for ALL sales reps / ${budgetYear}`);
    
    const budgetQuery = `
      SELECT 
        TRIM(salesrepname) as salesrep,
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(values) / 1000.0 as mt_value
      FROM ${tables.salesRepBudget}
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(type) = 'BUDGET'
        AND UPPER(values_type) = 'KGS'
      GROUP BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const budgetResult = await divisionPool.query(budgetQuery, [division, budgetYear]);
    console.log(`‚úÖ Found ${budgetResult.rows.length} budget records (all sales reps)`);
    
    // Build budget map
    const budgetMap = {};
    const budgetOnlyCustomers = new Set();
    
    budgetResult.rows.forEach(row => {
      // Normalize names for consistent display
      const budgetSalesRep = toProperCase(row.salesrep);
      const budgetCustomer = normalizeDisplayName(row.customer);
      const budgetCountry = normalizeDisplayName(row.country);
      const budgetProductGroup = normalizeDisplayName(row.productgroup);
      
      const key = `${budgetCustomer}|${budgetCountry}|${budgetProductGroup}|${row.month}`;
      budgetMap[key] = parseFloat(row.mt_value) || 0;
      
      const customerKey = `${budgetSalesRep}|${budgetCustomer}|${budgetCountry}|${budgetProductGroup}`;
      budgetOnlyCustomers.add(customerKey);
    });
    
    // Add budget-only customers (use case-insensitive comparison)
    budgetOnlyCustomers.forEach(customerKey => {
      const normalizedBudgetKey = customerKey.toLowerCase();
      const exists = data.some(item => {
        const itemKey = `${item.salesRep}|${item.customer}|${item.country}|${item.productGroup}`.toLowerCase();
        return itemKey === normalizedBudgetKey;
      });
      
      if (!exists) {
        const [salesRep, customer, country, productGroup] = customerKey.split('|');
        const monthlyActual = {};
        for (let month = 1; month <= 12; month++) {
          monthlyActual[month] = 0;
        }
        data.push({
          salesRep,
          customer,
          country,
          productGroup,
          monthlyActual,
        });
      }
    });
    
    // Sort data
    data.sort((a, b) => {
      const repCompare = (a.salesRep || '').localeCompare(b.salesRep || '');
      if (repCompare !== 0) return repCompare;
      const nameCompare = a.customer.localeCompare(b.customer);
      if (nameCompare !== 0) return nameCompare;
      const countryCompare = a.country.localeCompare(b.country);
      if (countryCompare !== 0) return countryCompare;
      return a.productGroup.localeCompare(b.productGroup);
    });
    
    // Query pricing data for Amount and MoRM calculations
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM ${tables.pricingRounding}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    console.log(`üìä Total rows in response: ${data.length} (all sales reps combined), pricing: ${Object.keys(pricingMap).length} product groups`);
    
    res.json({
      success: true,
      data,
      budgetData: budgetMap,
      pricingData: pricingMap,
      pricingYear: pricingYear,
      isAllSalesReps: true,
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching all sales reps budget customers:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/html-budget-customers
 * Get customer Actual sales data grouped by Customer + Country + Product Group
 * Returns monthly KGS totals converted to MT (divide by 1000)
 */
router.post('/html-budget-customers', async (req, res) => {
  try {
    const { division, actualYear, salesRep } = req.body;
    
    // Ensure indexes exist (automatic, one-time per division)
    await ensureHtmlBudgetIndexes(division);
    
    if (!division || !actualYear || !salesRep) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and salesRep are required'
      });
    }
    
    // Check if salesRep is a group
    const SALES_REP_CONFIG_FILE = path.join(__dirname, '..', 'data', 'sales-reps-config.json');
    let config = {};
    try {
      if (fs.existsSync(SALES_REP_CONFIG_FILE)) {
        config = JSON.parse(fs.readFileSync(SALES_REP_CONFIG_FILE, 'utf8'));
      }
    } catch (err) {
      console.error('Error loading sales rep config:', err);
    }
    
    const divisionConfig = config[division] || { groups: {} };
    const isGroup = divisionConfig.groups && divisionConfig.groups[salesRep];
    const salesRepsToQuery = isGroup 
      ? divisionConfig.groups[salesRep].map(r => r.toString().trim().toUpperCase())
      : [salesRep.toString().trim().toUpperCase()];
    
    if (salesRepsToQuery.length === 0) {
      return res.json({ success: true, data: [] });
    }
    
    // Fetch merge rules for the division
    const mergeRules = await DivisionMergeRulesService.listRules(division);
    const activeMergeRules = mergeRules.filter(r => r.status === 'ACTIVE' && r.is_active === true);
    
    // Build mapping from original customer names (normalized) to merged customer names
    const norm = (s) => (s || '').toString().trim().toLowerCase();
    // Helper to normalize display name: trim and clean up extra spaces
    const normalizeDisplayName = (s) => (s || '').toString().trim().replace(/\s+/g, ' ');
    const customerMergeMap = new Map();
    
    activeMergeRules.forEach(rule => {
      const mergedName = rule.merged_customer_name;
      const originalCustomers = Array.isArray(rule.original_customers) 
        ? rule.original_customers 
        : (typeof rule.original_customers === 'string' 
            ? JSON.parse(rule.original_customers) 
            : []);
      
      originalCustomers.forEach(original => {
        const normalized = norm(original);
        customerMergeMap.set(normalized, mergedName);
      });
    });
    
    // Query Actual sales data grouped by customer, country, product group, month
    // Exclude "Services Charges" product group
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value,
        SUM(CASE WHEN UPPER(values_type) = 'AMOUNT' THEN values ELSE 0 END) as amount_value,
        SUM(CASE WHEN UPPER(values_type) = 'MORM' THEN values ELSE 0 END) as morm_value
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND TRIM(UPPER(salesrepname)) = ANY($3::text[])
        AND customername IS NOT NULL
        AND TRIM(customername) != ''
        AND countryname IS NOT NULL
        AND TRIM(countryname) != ''
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const result = await divisionPool.query(query, [division, actualYear, salesRepsToQuery]);
    
    // Transform to table structure: { customer, country, productGroup, monthlyActual: {1: mt, 2: mt, ...} }
    // Apply merge rules: use merged customer name if exists, otherwise use original
    const customerMap = {};
    
    result.rows.forEach(row => {
      // Check if this customer should be merged
      const normalizedCustomer = norm(row.customer);
      // Use merged name if available, otherwise normalize the original name
      const displayCustomerName = customerMergeMap.get(normalizedCustomer) || normalizeDisplayName(row.customer);
      const displayCountry = normalizeDisplayName(row.country);
      const displayProductGroup = normalizeDisplayName(row.productgroup);
      
      const key = `${displayCustomerName}|${displayCountry}|${displayProductGroup}`;
      if (!customerMap[key]) {
        customerMap[key] = {
          customer: displayCustomerName,
          country: displayCountry,
          productGroup: displayProductGroup,
          monthlyActual: {},
          monthlyActualAmount: {},
          monthlyActualMorm: {},
        };
      }
      // Sum values if multiple original customers map to same merged customer
      const existingMtValue = customerMap[key].monthlyActual[row.month] || 0;
      const existingAmountValue = customerMap[key].monthlyActualAmount[row.month] || 0;
      const existingMormValue = customerMap[key].monthlyActualMorm[row.month] || 0;
      customerMap[key].monthlyActual[row.month] = existingMtValue + (parseFloat(row.mt_value) || 0);
      customerMap[key].monthlyActualAmount[row.month] = existingAmountValue + (parseFloat(row.amount_value) || 0);
      customerMap[key].monthlyActualMorm[row.month] = existingMormValue + (parseFloat(row.morm_value) || 0);
    });
    
    // Convert to array and ensure all months are present (0 if no data)
    const data = Object.values(customerMap).map(item => {
      const monthlyActual = {};
      const monthlyActualAmount = {};
      const monthlyActualMorm = {};
      for (let month = 1; month <= 12; month++) {
        monthlyActual[month] = item.monthlyActual[month] || 0;
        monthlyActualAmount[month] = item.monthlyActualAmount[month] || 0;
        monthlyActualMorm[month] = item.monthlyActualMorm[month] || 0;
      }
      return {
        ...item,
        monthlyActual,
        monthlyActualAmount,
        monthlyActualMorm,
      };
    });
    
    // NOW LOAD BUDGET DATA FROM division-specific sales_rep_budget TABLE
    const budgetYear = parseInt(actualYear) + 1;
    console.log(`üìä Loading budget data for ${division} / ${salesRep} / ${budgetYear}`);
    
    const budgetQuery = `
      SELECT 
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        values / 1000.0 as mt_value
      FROM ${tables.salesRepBudget}
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
        AND UPPER(type) = 'BUDGET'
        AND UPPER(values_type) = 'KGS'
      ORDER BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const budgetResult = await divisionPool.query(budgetQuery, [division, budgetYear, salesRep]);
    console.log(`‚úÖ Found ${budgetResult.rows.length} budget records`);
    
    // Build budget map: { "customer|country|productGroup|month": value }
    const budgetMap = {};
    const budgetOnlyCustomers = new Set(); // Track customers that only exist in budget (not in actual sales)
    
    budgetResult.rows.forEach(row => {
      const key = `${row.customer}|${row.country}|${row.productgroup}|${row.month}`;
      budgetMap[key] = parseFloat(row.mt_value) || 0;
      
      // Track unique customer combinations that exist in budget
      // Store original case for display, but use normalized key for matching
      const customerKey = `${row.customer}|${row.country}|${row.productgroup}`;
      budgetOnlyCustomers.add(customerKey);
    });
    
    // Add budget-only customers to the data array (customers with budget but no actual sales)
    // This ensures custom customers added by users appear in the table after refresh
    budgetOnlyCustomers.forEach(customerKey => {
      // Check if this customer already exists in the data array (from actual sales)
      // Use case-insensitive comparison to avoid duplicates due to casing differences
      const normalizedBudgetKey = customerKey.toLowerCase();
      const exists = data.some(item => {
        const itemKey = `${item.customer}|${item.country}|${item.productGroup}`.toLowerCase();
        return itemKey === normalizedBudgetKey;
      });
      
      if (!exists) {
        // This customer only exists in budget data, add them to the table
        const [customer, country, productGroup] = customerKey.split('|');
        const monthlyActual = {};
        for (let month = 1; month <= 12; month++) {
          monthlyActual[month] = 0; // No actual sales for this customer
        }
        data.push({
          customer,
          country,
          productGroup,
          monthlyActual,
        });
        console.log(`‚ûï Added budget-only customer to table: ${customer} (${country}) - ${productGroup}`);
      }
    });
    
    // Sort data to keep consistent order (customers with budget-only will appear mixed in)
    data.sort((a, b) => {
      const nameCompare = a.customer.localeCompare(b.customer);
      if (nameCompare !== 0) return nameCompare;
      const countryCompare = a.country.localeCompare(b.country);
      if (countryCompare !== 0) return countryCompare;
      return a.productGroup.localeCompare(b.productGroup);
    });
    
    // Query pricing data for Amount and MoRM calculations
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM ${tables.pricingRounding}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    console.log(`üìä Total rows in response: ${data.length} (including budget-only customers)`);
    
    res.json({
      success: true,
      data,
      budgetData: budgetMap, // Add budget data to response
      pricingData: pricingMap, // Add pricing data for Amount/MoRM calculations
      pricingYear: pricingYear,
      salesRep: salesRep,
      isGroup: !!isGroup,
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching HTML budget customers:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/save-html-budget
 * Save budget data from HTML form to database
 * Converts MT back to KGS (multiply by 1000)
 */
router.post('/save-html-budget', async (req, res) => {
  const { division, budgetYear, salesRep, records } = req.body;
  
  // Ensure indexes exist (automatic, one-time per division)
  await ensureHtmlBudgetIndexes(division);
  
  // Ensure sales rep budget table has required columns and unique constraint
  await ensureSalesRepBudgetColumns(division);
  
  if (!division || !budgetYear || !salesRep) {
    return res.status(400).json({
      success: false,
      error: 'division, budgetYear, and salesRep are required'
    });
  }
  
  // Get division-specific pool
  const divisionPool = getPoolForDivision(division);
  const client = await divisionPool.connect();
  
  try {
    
    await client.query('BEGIN');
    const result = await saveLiveSalesRepBudget(client, {
      division,
      budgetYear,
      salesRep,
      records
    });
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `Sales rep budget saved (${result.recordsProcessed} rows, ${result.recordsInserted.total} records inserted)`,
      ...result
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Save HTML budget error:', error);
    const statusCode = error.details ? 400 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
      details: error.details
    });
  } finally {
    client.release();
  }
});

/**
 * POST /api/aebf/export-html-budget-form
 * Generate standalone HTML form with pre-filled Actual data
 * Returns HTML file for download
 */
router.post('/export-html-budget-form', async (req, res) => {
  try {
    const { division, actualYear, salesRep, tableData, customRowsData, budgetData, mergedCustomers, countries, productGroups } = req.body;
    
    if (!division || !actualYear || !salesRep || !Array.isArray(tableData)) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, salesRep, and tableData are required'
      });
    }
    
    // Helper function to convert string to Proper Case (defined early for salesRep normalization)
    const toProperCase = (str) => {
      if (!str) return '';
      return str.toLowerCase().replace(/(?:^|\s|[-/])\w/g, (match) => match.toUpperCase());
    };
    
    // Normalize sales rep name to Proper Case for consistent display
    const normalizedSalesRep = toProperCase(salesRep);
    
    const customRows = Array.isArray(customRowsData) ? customRowsData : [];
    const budgetDataMap = budgetData || {};
    
    const budgetYear = parseInt(actualYear) + 1;
    
    // Query pricing data from database for Amount and MoRM calculations\n    // Get division-specific pool and tables
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM ${tables.pricingRounding}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map (product group -> {selling price, morm})
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    console.log(`üìä Export: Loaded ${pricingResult.rows.length} pricing entries for ${division} year ${pricingYear}`);
    
    // Calculate monthly totals
    const monthlyActualTotals = {};
    const monthlyBudgetTotals = {};
    const monthlyActualAmountTotals = {};
    const monthlyActualMormTotals = {};
    const monthlyBudgetAmountTotals = {};
    const monthlyBudgetMormTotals = {};
    for (let month = 1; month <= 12; month++) {
      monthlyActualTotals[month] = 0;
      monthlyBudgetTotals[month] = 0;
      monthlyActualAmountTotals[month] = 0;
      monthlyActualMormTotals[month] = 0;
      monthlyBudgetAmountTotals[month] = 0;
      monthlyBudgetMormTotals[month] = 0;
    }
    
    // Calculate actual totals from tableData (MT, Amount, and MoRM)
    tableData.forEach(row => {
      for (let month = 1; month <= 12; month++) {
        const mtValue = row.monthlyActual?.[month] || 0;
        const amountValue = row.monthlyActualAmount?.[month] || 0;
        const mormValue = row.monthlyActualMorm?.[month] || 0;
        monthlyActualTotals[month] += mtValue;
        // Use actual Amount and MoRM from database
        monthlyActualAmountTotals[month] += amountValue;
        monthlyActualMormTotals[month] += mormValue;
      }
    });
    
    // Calculate budget totals from budgetData
    // First, create a map of budget values by product group + month for Amount and MoRM calculation
    const budgetByProductGroupMonth = {};
    Object.keys(budgetDataMap).forEach(key => {
      let month, productGroup;
      if (key.startsWith('custom_')) {
        const parts = key.split('_');
        month = parseInt(parts[parts.length - 1], 10);
        // For custom rows, we need to find the product group from customRows
        const customId = parts[1];
        const customRow = customRows.find(r => r.id === parseInt(customId) || r.id === customId);
        productGroup = customRow?.productGroup || '';
      } else {
        const parts = key.split('|');
        month = parseInt(parts[parts.length - 1], 10);
        productGroup = parts[2] || ''; // customer|country|productGroup|month
      }
      if (month >= 1 && month <= 12) {
        const value = budgetDataMap[key];
        const num = parseFloat((value || '').toString().replace(/,/g, '')) || 0;
        if (!isNaN(num)) {
          monthlyBudgetTotals[month] += num;
          
          // Calculate Amount and MoRM for budget
          const pgLower = (productGroup || '').toLowerCase();
          const pricing = pricingMap[pgLower] || { sellingPrice: 0, morm: 0 };
          monthlyBudgetAmountTotals[month] += num * 1000 * pricing.sellingPrice;
          monthlyBudgetMormTotals[month] += num * 1000 * pricing.morm;
        }
      }
    });
    
    // Prepare data for JavaScript - normalize customer names to Proper Case
    const mergedCustomersList = (Array.isArray(mergedCustomers) && mergedCustomers.length > 0 
      ? mergedCustomers 
      : [...new Set(tableData.map(r => r.customer))].sort()
    ).map(c => toProperCase(c));
    const countriesList = Array.isArray(countries) ? countries : [];
    const productGroupsList = Array.isArray(productGroups) ? productGroups : [];
    
    // Normalize customer names in tableData to Proper Case
    tableData.forEach(row => {
      if (row.customer) {
        row.customer = toProperCase(row.customer);
      }
    });
    
    // Sort tableData by customer -> country -> productGroup for consistent ordering
    const sortedTableData = [...tableData].sort((a, b) => {
      const customerCompare = (a.customer || '').localeCompare(b.customer || '');
      if (customerCompare !== 0) return customerCompare;
      const countryCompare = (a.country || '').localeCompare(b.country || '');
      if (countryCompare !== 0) return countryCompare;
      return (a.productGroup || '').localeCompare(b.productGroup || '');
    });
    
    // Generate HTML
    const html = `<!DOCTYPE html>
<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=SALES_REP_BUDGET :: DO_NOT_EDIT_THIS_LINE -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Planning - ${division} - ${normalizedSalesRep} - ${actualYear}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: Arial, sans-serif; padding: 12px; background: #f5f5f5; display: flex; flex-direction: column; }
    .header { background: #fff; padding: 12px 20px; margin-bottom: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; }
    .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .header h1 { margin: 0; color: #333; font-size: 18px; }
    .header-actions { display: flex; gap: 8px; align-items: center; }
    .header-bottom { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; }
    .header-info { display: flex; gap: 20px; flex-wrap: wrap; }
    .header-info div { font-size: 12px; color: #666; }
    .header-info strong { color: #333; }
    .header-legend { display: flex; gap: 16px; align-items: center; }
    .header-legend-item { display: flex; align-items: center; gap: 6px; font-size: 11px; color: #555; }
    .header-legend-color { display: inline-block; width: 14px; height: 14px; border: 1px solid; border-radius: 2px; }
    .header-legend-color.actual { background-color: #cce4ff; border-color: #91caff; }
    .header-legend-color.budget { background-color: #FFEB3B; border-color: #ffc53d; }
    .header-tip { font-size: 10px; color: #8c8c8c; }
    .recap-container { flex-shrink: 0; }
    .table-container {
      background: #fff;
      padding: 0;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
      flex: 1;
      min-height: 500px;
      overflow-x: auto;
      overflow-y: auto;
    }
    table { 
      width: 100%; 
      border-collapse: separate; 
      border-spacing: 0; 
      font-size: 12px; 
      table-layout: fixed; 
    }
    .legend-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    .legend { display: flex; gap: 24px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; }
    .legend-color { display: inline-block; width: 16px; height: 16px; border: 1px solid; }
    .legend-actual { background-color: #e6f4ff; border-color: #99c8ff; }
    .legend-budget { background-color: #FFFFB8; border-color: #d4b106; }
    .add-row-btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .add-row-btn:hover { background: #4096ff; }
    thead tr.header-row {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      z-index: 1001;
      background: #fff;
    }
    thead th.column-header {
      background-color: #1677ff;
      color: #fff;
      padding: 8px;
      border: 1px solid #fff;
      text-align: center;
      min-width: 0;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    thead th.column-header.sticky-col {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 1003;
      background-color: #1677ff;
    }
    tbody td { 
      padding: 8px; 
      border: 1px solid #ddd; 
    }
    tbody td:last-child {
      text-align: center;
    }
    tbody td:nth-child(1) {
      background-color: #fff;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 5;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.actual-row td:nth-child(1) {
      background-color: #fff;
    }
    tbody tr.budget-row td:nth-child(1) {
      background-color: #fff;
    }
    tbody tr.custom-row td:nth-child(1) {
      background-color: #fff;
      padding: 8px;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.custom-row td:nth-child(1) .customer-cell {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    tbody tr.custom-row td:nth-child(1) .customer-cell span {
      flex: 1;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.custom-row td:nth-child(1) .new-customer-input {
      font-weight: 600;
    }
    tbody tr.actual-row td:nth-child(2),
    tbody tr.actual-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody tr.budget-row td:nth-child(2),
    tbody tr.budget-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody tr.custom-row td:nth-child(2),
    tbody tr.custom-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody td:nth-child(2), tbody td:nth-child(3) { 
      background-color: #fff; 
      white-space: normal; 
      word-break: break-word; 
      line-height: 1.3; 
    }
    tbody tr.actual-row { background-color: #e6f4ff; }
    tbody tr.actual-row td:nth-child(n+4) { 
      background-color: #e6f4ff; 
      text-align: right; 
      font-weight: 500; 
      padding: 6px 8px; 
    }
    tbody tr.budget-row { background-color: #FFFFB8; }
    tbody tr.budget-row td { 
      background-color: #FFFFB8 !important; 
      padding: 2px;
      text-align: right;
      font-weight: 500;
      font-size: 12px;
    }
    tbody tr.custom-row { background-color: #FFFFB8; }
    tbody tr.custom-row td:nth-child(2), tbody tr.custom-row td:nth-child(3) { 
      padding: 4px; 
    }
    tbody tr.custom-row td:nth-child(n+4) { 
      background-color: #FFFFB8 !important; 
      padding: 2px; 
    }
    tbody input { 
      width: 100%; 
      border: none; 
      padding: 4px 6px; 
      text-align: right; 
      font-size: 12px; 
      font-weight: 500; 
      background-color: transparent !important; 
      box-shadow: none; 
    }
    tbody tr.budget-row input,
    tbody tr.custom-row input.custom-input {
      background-color: transparent !important;
    }
    tbody input:focus { outline: none; }
    tbody input:disabled { background-color: #f5f5f5 !important; cursor: not-allowed; }
    tbody select { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
    tbody select option { padding: 4px; }
    tbody select option:hover { background-color: #e6f4ff; }
    tbody .delete-btn { 
      background: #ff4d4f; 
      color: #fff; 
      border: none; 
      padding: 2px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 12px; 
      margin-left: 4px; 
    }
    tbody .delete-btn:hover { background: #ff7875; }
    tfoot tr.actual-total {
      background-color: #cce4ff;
    }
    tfoot tr.actual-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #cce4ff;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #cce4ff;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-total td:last-child {
      background-color: #90CAF9;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total {
      background-color: #d4edda;
    }
    tfoot tr.actual-amount-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #d4edda;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #d4edda;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total td:last-child {
      background-color: #c3e6cb;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total {
      background-color: #ffe0b2;
    }
    tfoot tr.actual-morm-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #ffe0b2;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #ffe0b2;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total td:last-child {
      background-color: #ffb74d;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-year-total {
      background-color: #90CAF9;
    }
    tfoot tr.actual-year-total td {
      padding: 8px;
      border: 1px solid #ddd;
      background-color: #90CAF9;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-year-total td:first-child {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #90CAF9;
    }
    tfoot tr.budget-total {
      background-color: #FFFFB8;
    }
    tfoot tr.budget-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #FFFFB8;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFFFB8;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-total td:last-child {
      background-color: #FFEB3B;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total {
      background-color: #c8e6c9;
    }
    tfoot tr.budget-amount-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #c8e6c9;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #c8e6c9;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total td:last-child {
      background-color: #81c784;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total {
      background-color: #ffe0b2;
    }
    tfoot tr.budget-morm-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #ffe0b2;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #ffe0b2;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total td:last-child {
      background-color: #ffb74d;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-year-total {
      background-color: #FFEB3B;
    }
    tfoot tr.budget-year-total td {
      padding: 8px;
      border: 1px solid #ddd;
      background-color: #FFEB3B;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-year-total td:first-child {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFEB3B;
    }
    tfoot tr.budget-year-total td:last-child {
      text-align: center;
      font-size: 12px;
      background-color: #FFEB3B;
    }
    .btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .btn:hover { background: #4096ff; }
    .btn:disabled { background: #ccc; cursor: not-allowed; }
    .customer-cell {
      display: flex;
      align-items: center;
      gap: 4px;
      width: 100%;
    }
    .customer-cell select {
      flex: 1;
    }
    .new-customer-input {
      flex: 1;
      padding: 4px 6px;
      border: 1px solid #d9d9d9;
      border-radius: 4px;
      font-size: 12px;
    }
    .recap-container {
      background: linear-gradient(135deg, #f0f9ff 0%, #e6f4ff 100%);
      border: 1px solid #91caff;
      border-radius: 8px;
      padding: 10px 16px;
      margin-bottom: 10px;
      box-shadow: 0 2px 6px rgba(24,144,255,0.1);
    }
    .recap-title {
      font-size: 13px;
      font-weight: 600;
      color: #0958d9;
      margin-bottom: 8px;
    }
    .recap-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    .recap-stat {
      background: #fff;
      padding: 12px 16px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .recap-stat-header {
      font-size: 13px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }
    .recap-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .recap-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .recap-item-label {
      font-size: 12px;
      color: #666;
    }
    .recap-item-value {
      font-size: 18px;
      font-weight: 700;
    }
    .recap-item-value.actual {
      color: #1890ff;
    }
    .recap-item-value.budget {
      color: #d48806;
    }
    .recap-variance-value {
      font-size: 14px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
    }
    .recap-variance-value.positive {
      color: #52c41a;
      background: #f6ffed;
    }
    .recap-variance-value.negative {
      color: #ff4d4f;
      background: #fff2f0;
    }
    .recap-variance-value.neutral {
      color: #666;
      background: #fafafa;
    }
    .product-group-chart-container {
      background: linear-gradient(135deg, #fff9e6 0%, #fffbf0 100%);
      border: 1px solid #ffc53d;
      border-radius: 8px;
      padding: 16px 20px;
      margin: 12px;
      box-shadow: 0 2px 6px rgba(212, 136, 6, 0.1);
      flex-shrink: 0;
    }
    .product-group-chart-title {
      font-size: 14px;
      font-weight: 600;
      color: #d48806;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .product-group-chart-wrapper {
      background: #fff;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    .product-group-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-top: 16px;
    }
    .product-group-table th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      color: #fff;
      font-size: 14px;
      letter-spacing: 0.3px;
    }
    .product-group-table th:nth-child(2),
    .product-group-table th:nth-child(3),
    .product-group-table th:nth-child(4) {
      text-align: right;
    }
    .product-group-table td {
      padding: 14px 16px;
      border-bottom: 1px solid #e8e8e8;
      font-size: 14px;
    }
    .product-group-table td:first-child {
      font-weight: 600;
      color: #333;
    }
    .product-group-table td:nth-child(2),
    .product-group-table td:nth-child(3),
    .product-group-table td:nth-child(4) {
      text-align: right;
      font-weight: 500;
      font-family: 'Segoe UI', monospace;
    }
    .product-group-table tbody tr:hover {
      background-color: #f0f7ff;
    }
    .product-group-table tbody tr:nth-child(even) {
      background-color: #fafbfc;
    }
    .product-group-table tbody tr:nth-child(even):hover {
      background-color: #f0f7ff;
    }
    .product-group-table tfoot {
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
      border-top: 2px solid #667eea;
    }
    .product-group-table tfoot td {
      padding: 14px 16px;
      font-size: 15px;
      color: #333;
    }
    .pg-variance-positive {
      color: #52c41a;
      font-weight: 700;
    }
    .pg-variance-negative {
      color: #ff4d4f;
      font-weight: 700;
    }
    .pg-variance-neutral {
      color: #666;
      font-weight: 600;
    }
    .pg-variance-new {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-top">
      <h1>Budget Planning Form</h1>
      <div class="header-actions">
        <button class="add-row-btn" id="addRowBtn">+ Add New Row</button>
        <button class="btn" id="saveDraftBtn" style="background: #1677ff; padding: 4px 12px; font-size: 11px;">üíæ Save Draft</button>
        <button class="btn" id="saveFinalBtn" style="background: #52c41a; padding: 4px 12px; font-size: 11px;">‚úì Save Final</button>
      </div>
    </div>
    <div class="header-bottom">
      <div class="header-info">
        <div><strong>Division:</strong> ${division}</div>
        <div><strong>Sales Rep:</strong> ${normalizedSalesRep}</div>
        <div><strong>Actual Year:</strong> ${actualYear}</div>
        <div><strong>Budget Year:</strong> ${budgetYear}</div>
      </div>
      <div class="header-legend">
        <div class="header-legend-item">
          <span class="header-legend-color actual"></span>
          <span>Actual ${actualYear} (MT)</span>
        </div>
        <div class="header-legend-item">
          <span class="header-legend-color budget"></span>
          <span>Budget ${budgetYear} (MT)</span>
        </div>
        <span class="header-tip">üí° Save Draft to continue later, Save Final to submit</span>
      </div>
    </div>
  </div>
  
  <div id="recapContainer" class="recap-container" style="display: none;">
    <div class="recap-title">üìä Budget vs Actual Summary</div>
    <div class="recap-stats">
      <div class="recap-stat">
        <div class="recap-stat-header">üì¶ Volume (MT)</div>
        <div class="recap-row">
          <div class="recap-item">
            <span class="recap-item-label">Act:</span>
            <span class="recap-item-value actual" id="recapActualMT">0</span>
          </div>
          <div class="recap-item">
            <span class="recap-item-label">Bud:</span>
            <span class="recap-item-value budget" id="recapBudgetMT">0</span>
          </div>
          <span class="recap-variance-value neutral" id="recapMTVariance">0%</span>
        </div>
      </div>
      <div class="recap-stat">
        <div class="recap-stat-header"><svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.3em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg> Amount</div>
        <div class="recap-row">
          <div class="recap-item">
            <span class="recap-item-label">Act:</span>
            <span class="recap-item-value actual" id="recapActualAmount">0</span>
          </div>
          <div class="recap-item">
            <span class="recap-item-label">Bud:</span>
            <span class="recap-item-value budget" id="recapBudgetAmount">0</span>
          </div>
          <span class="recap-variance-value neutral" id="recapAmountVariance">0%</span>
        </div>
      </div>
      <div class="recap-stat">
        <div class="recap-stat-header">üë• Customers</div>
        <div class="recap-row">
          <div class="recap-item">
            <span class="recap-item-label">Act:</span>
            <span class="recap-item-value actual" id="recapActualCustomers">0</span>
          </div>
          <div class="recap-item">
            <span class="recap-item-label">Bud:</span>
            <span class="recap-item-value budget" id="recapBudgetCustomers">0</span>
          </div>
          <span class="recap-variance-value neutral" id="recapCustomerVariance">0%</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="table-container">
    <table>
      <colgroup>
        <col style="width: 14%;" />
        <col style="width: 9%;" />
        <col style="width: 13%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 8%;" />
      </colgroup>
      <thead>
        <tr class="header-row">
          <th rowspan="2" class="column-header sticky-col">Customer Name</th>
          <th rowspan="2" class="column-header" style="width: 10%;">Country Name</th>
          <th rowspan="2" class="column-header" style="width: 15%;">Product Group</th>
          ${Array.from({ length: 12 }, (_, i) => '<th class="column-header" style="width: 5%;">' + (i + 1) + '</th>').join('')}
          <th rowspan="2" class="column-header" style="background-color: #0958d9; width: 8%; font-weight: 700;">Total</th>
        </tr>
      </thead>
      <tbody id="tableBody">
        ${sortedTableData.map((row, idx) => {
          // Calculate actual total for this row
          let actualRowTotal = 0;
          const actualCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const value = row.monthlyActual?.[month] || 0;
            actualRowTotal += value;
            const formatted = value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('');
          
          // Calculate budget total for this row
          let budgetRowTotal = 0;
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const key = row.customer + '|' + row.country + '|' + row.productGroup + '|' + month;
            const preFilledValue = budgetDataMap[key] || '';
            if (preFilledValue) {
              budgetRowTotal += parseFloat(preFilledValue.toString().replace(/,/g, '')) || 0;
            }
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-customer="' + row.customer.replace(/"/g, '&quot;') + '" ' +
              'data-country="' + row.country.replace(/"/g, '&quot;') + '" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              '/>' +
            '</td>';
          }).join('');
          
          return '<tr class="actual-row">' +
            '<td rowspan="2">' + row.customer + '</td>' +
            '<td rowspan="2">' + row.country + '</td>' +
            '<td rowspan="2">' + row.productGroup + '</td>' +
            actualCells +
            '<td style="background-color: #cce4ff; text-align: center; font-weight: 700;">' + actualRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>' +
          '<tr class="budget-row">' +
            budgetCells +
            '<td class="budget-row-total" style="background-color: #FFEB3B; text-align: center; font-weight: 700;">' + budgetRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>';
        }).join('')}
        ${customRows.map((row, idx) => {
          let customRowTotal = 0;
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            let preFilledValue = '';
            if (row.id) {
              const key = 'custom_' + row.id + '_' + month;
              preFilledValue = budgetDataMap[key] || '';
            }
            if (!preFilledValue) {
              const fallbackKey = row.customer + '|' + row.country + '|' + row.productGroup + '|' + month;
              preFilledValue = budgetDataMap[fallbackKey] || '';
            }
            if (preFilledValue) {
              customRowTotal += parseFloat(preFilledValue.toString().replace(/,/g, '')) || 0;
            }
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-customer="' + row.customer.replace(/"/g, '&quot;') + '" ' +
              'data-country="' + row.country.replace(/"/g, '&quot;') + '" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              'class="custom-input" ' +
              '/>' +
            '</td>';
          }).join('');
          
          const showInput = row.isNewCustomer && !row.customer;
          const hasCustomer = row.customer && row.customer.trim();
          
          const customerCellContent = hasCustomer ? (
            '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + row.customer.replace(/"/g, '&quot;') + '</span>' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">√ó</button>'
          ) : (
            '<select class="customer-select" style="flex: 1; ' + (showInput ? 'display:none;' : '') + '">' +
              '<option value="" disabled>Select customer</option>' +
              '<option value="__NEW__" style="font-style: italic; color: #1890ff;">+ Add New Customer</option>' +
              mergedCustomersList.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '"' + (c === row.customer ? ' selected' : '') + '>' + c + '</option>').join('') +
            '</select>' +
            '<input type="text" class="new-customer-input" placeholder="Enter new customer name" value="' + (showInput && row.customer ? row.customer.replace(/"/g, '&quot;') : '') + '" style="flex: 1; font-weight: 600; ' + (showInput ? 'display:block;' : 'display:none;') + '" />' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">√ó</button>'
          );
          
          const countryOptions = countriesList.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '"' + (c === row.country ? ' selected' : '') + '>' + c + '</option>').join('');
          const productGroupOptions = productGroupsList.map(pg => '<option value="' + pg.replace(/"/g, '&quot;') + '"' + (pg === row.productGroup ? ' selected' : '') + '>' + pg + '</option>').join('');
          
          return '<tr class="custom-row" data-row-id="' + (row.id || idx) + '">' +
            '<td style="padding: 8px; border: 1px solid #ddd; background-color: #fff; position: sticky; left: 0; z-index: 5; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' +
              '<div class="customer-cell" style="display: flex; align-items: center; gap: 4px;">' +
                customerCellContent +
              '</div>' +
            '</td>' +
            '<td>' +
              '<select class="country-select" style="width: 100%;"' + (!row.isNewCustomer ? ' disabled' : '') + '>' +
                '<option value="" disabled>Select country</option>' +
                countryOptions +
              '</select>' +
            '</td>' +
            '<td>' +
              '<select class="product-group-select" style="width: 100%;">' +
                '<option value="" disabled>Select product group</option>' +
                productGroupOptions +
              '</select>' +
            '</td>' +
            budgetCells +
            '<td class="custom-row-total" style="background-color: #FFEB3B; text-align: center; font-weight: 700;">' + customRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>';
        }).join('')}
      </tbody>
      <tfoot>
        <tr class="actual-total">
          <td colSpan="3">Total Actual Volume (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #90CAF9; text-align: center; font-weight: 700;">${Object.values(monthlyActualTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="actual-amount-total">
          <td colSpan="3">Total Actual Amount <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="text-align: center;">
            ${(() => {
              const total = Object.values(monthlyActualAmountTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>
        <tr class="actual-morm-total" style="display: none;">
          <td colSpan="3">Total Actual MoRM <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualMormTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="text-align: center;">
            ${(() => {
              const total = Object.values(monthlyActualMormTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>
        <tr class="budget-total">
          <td colSpan="3">Total Budget Volume (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #FFEB3B; text-align: center; font-weight: 700;" id="budgetYearTotal">${Object.values(monthlyBudgetTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="budget-amount-total">
          <td colSpan="3">Total Budget Amount <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td id="budgetAmountYearTotal" style="text-align: center;">
            ${(() => {
              const total = Object.values(monthlyBudgetAmountTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>
        <tr class="budget-morm-total" style="display: none;">
          <td colSpan="3">Total Budget MoRM <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetMormTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td id="budgetMormYearTotal" style="text-align: center;">
            ${(() => {
              const total = Object.values(monthlyBudgetMormTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>

      </tfoot>
    </table>
  </div>

  <div id="productGroupChartContainer" class="product-group-chart-container" style="display: none;">
    <div class="product-group-chart-title">üìä Product Group Breakdown: Actual vs Budget (MT)</div>
    <div class="product-group-chart-wrapper">
      <canvas id="productGroupChart" style="max-height: 400px;"></canvas>
    </div>
    <table class="product-group-table" id="productGroupTable">
      <thead>
        <tr>
          <th>Product Group</th>
          <th>Actual (MT)</th>
          <th>Budget (MT)</th>
          <th>Variance</th>
        </tr>
      </thead>
      <tbody id="productGroupTableBody">
        <!-- Populated by JavaScript -->
      </tbody>
      <tfoot id="productGroupTableFoot">
        <tr>
          <td><strong>TOTAL</strong></td>
          <td id="pgTotalActual"><strong>0.00</strong></td>
          <td id="pgTotalBudget"><strong>0.00</strong></td>
          <td id="pgTotalVariance"><strong>0.0%</strong></td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    const formData = {
      division: '${division}',
      salesRep: '${normalizedSalesRep.replace(/'/g, "\\'")}',
      actualYear: ${actualYear},
      budgetYear: ${budgetYear},
    };
    
    const mergedCustomers = ${JSON.stringify(mergedCustomersList)};
    const countries = ${JSON.stringify(countriesList)};
    const productGroups = ${JSON.stringify(productGroupsList)};
    const pricingMap = ${JSON.stringify(pricingMap)};
    let customRowCounter = ${customRows.length > 0 && customRows.some(r => r.id) ? Math.max(...customRows.filter(r => r.id).map(r => r.id)) + 1 : Date.now()};
    
    // Helper to format Amount values with K/M suffix
    function formatAmount(value) {
      if (!value || value === 0) return '0';
      if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
      if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
      return value.toFixed(0);
    }
    
    // Make dropdowns searchable - filter options as user types
    function makeSelectSearchable(selectElement) {
      if (!selectElement || selectElement.dataset.searchable === 'true') return;
      selectElement.dataset.searchable = 'true';
      
      selectElement.addEventListener('keydown', function(e) {
        // Only handle alphanumeric keys
        if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
          const searchTerm = e.key.toLowerCase();
          const options = Array.from(this.options);
          
          // Find first option that starts with the typed character
          for (let i = 0; i < options.length; i++) {
            if (options[i].text.toLowerCase().startsWith(searchTerm)) {
              this.selectedIndex = i;
              this.dispatchEvent(new Event('change'));
              e.preventDefault();
              break;
            }
          }
        }
      });
      
      // Add input event for continuous search (requires contenteditable hack)
      let searchBuffer = '';
      let searchTimeout;
      
      selectElement.addEventListener('keypress', function(e) {
        if (e.key.length === 1) {
          searchBuffer += e.key.toLowerCase();
          clearTimeout(searchTimeout);
          
          const options = Array.from(this.options);
          for (let i = 0; i < options.length; i++) {
            if (options[i].text.toLowerCase().includes(searchBuffer)) {
              this.selectedIndex = i;
              break;
            }
          }
          
          searchTimeout = setTimeout(() => {
            searchBuffer = '';
          }, 1000);
        }
      });
    }
    
    function formatMT(value) {
      if (!value && value !== 0) return '';
      const num = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value;
      if (isNaN(num)) return '';
      return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    function recalculateTotals() {
      const actualTotals = Array.from({ length: 12 }, () => 0);
      const budgetTotals = Array.from({ length: 12 }, () => 0);
      const budgetAmountTotals = Array.from({ length: 12 }, () => 0);
      const budgetMormTotals = Array.from({ length: 12 }, () => 0);
      
      // Calculate actual totals - cells start from 4th child (columns 1-3 are customer/country/group)
      // Skip the last cell in each row (the Total column)
      document.querySelectorAll('tr.actual-row').forEach(row => {
        const cells = row.querySelectorAll('td:nth-child(n+4):not(:last-child)');
        cells.forEach((cell, idx) => {
          const val = parseFloat(cell.textContent.replace(/,/g, '')) || 0;
          if (idx < 12) actualTotals[idx] += val;
        });
      });
      
      // Calculate budget totals - use month from dataset directly as array index (1-12 maps to 0-11)
      // Also calculate budget Amount and MoRM using pricing data
      document.querySelectorAll('input:not([disabled])').forEach(input => {
        const month = parseInt(input.dataset.month);
        const val = parseFloat(input.value.replace(/,/g, '')) || 0;
        const productGroup = (input.dataset.group || '').toLowerCase();
        const pricing = pricingMap[productGroup] || { sellingPrice: 0, morm: 0 };
        const sellingPrice = typeof pricing === 'object' ? (pricing.sellingPrice || 0) : pricing;
        const mormPrice = typeof pricing === 'object' ? (pricing.morm || 0) : 0;
        
        if (month >= 1 && month <= 12 && !isNaN(val)) {
          budgetTotals[month - 1] += val;
          // Amount = MT * 1000 * sellingPrice
          budgetAmountTotals[month - 1] += val * 1000 * sellingPrice;
          // MoRM = MT * 1000 * mormPrice
          budgetMormTotals[month - 1] += val * 1000 * mormPrice;
        }
      });
      
      // Also update individual budget row totals
      document.querySelectorAll('tr.budget-row, tr.custom-row').forEach(row => {
        const inputs = row.querySelectorAll('input');
        let rowTotal = 0;
        inputs.forEach(input => {
          const val = parseFloat(input.value.replace(/,/g, '')) || 0;
          rowTotal += val;
        });
        const totalCell = row.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(rowTotal);
        }
      });
      
      // Update total cells in footer
      // Footer rows have: <td colspan="3">Label</td> + 12 month cells + 1 Total cell
      // Select the 12 month cells (not first and not last)
      const actualTotalRow = document.querySelector('tfoot tr.actual-total');
      const budgetTotalRow = document.querySelector('tfoot tr.budget-total');
      const budgetAmountRow = document.querySelector('tfoot tr.budget-amount-total');
      
      if (actualTotalRow) {
        const cells = actualTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatMT(actualTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = actualTotalRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(actualTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      if (budgetTotalRow) {
        const cells = budgetTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatMT(budgetTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = budgetTotalRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(budgetTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      if (budgetAmountRow) {
        const cells = budgetAmountRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatAmount(budgetAmountTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = budgetAmountRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatAmount(budgetAmountTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      // Update Budget MoRM row
      const budgetMormRow = document.querySelector('tfoot tr.budget-morm-total');
      if (budgetMormRow) {
        const cells = budgetMormRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatAmount(budgetMormTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = budgetMormRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatAmount(budgetMormTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      // Also update id-based elements for compatibility
      const yearTotalCell = document.getElementById('budgetYearTotal');
      if (yearTotalCell) {
        yearTotalCell.textContent = formatMT(budgetTotals.reduce((sum, val) => sum + val, 0));
      }
      
      const amountYearTotalCell = document.getElementById('budgetAmountYearTotal');
      if (amountYearTotalCell) {
        amountYearTotalCell.textContent = formatAmount(budgetAmountTotals.reduce((sum, val) => sum + val, 0));
      }
      
      const mormYearTotalCell = document.getElementById('budgetMormYearTotal');
      if (mormYearTotalCell) {
        mormYearTotalCell.textContent = formatAmount(budgetMormTotals.reduce((sum, val) => sum + val, 0));
      }
      
      // Update product group chart
      updateProductGroupChart();
    }
    
    let productGroupChartInstance = null;
    
    function updateProductGroupChart() {
      // Calculate product group totals
      const productGroupData = {};
      
      // Get actual data by product group
      document.querySelectorAll('tr.actual-row').forEach(row => {
        const productGroupCell = row.querySelector('td:nth-child(3)');
        if (!productGroupCell) return;
        
        const productGroup = productGroupCell.textContent.trim();
        if (!productGroupData[productGroup]) {
          productGroupData[productGroup] = { actual: 0, budget: 0 };
        }
        
        // Sum all month cells (columns 4-15, excluding last Total column)
        const cells = row.querySelectorAll('td:nth-child(n+4):not(:last-child)');
        cells.forEach(cell => {
          const val = parseFloat(cell.textContent.replace(/,/g, '')) || 0;
          productGroupData[productGroup].actual += val;
        });
      });
      
      // Get budget data by product group
      document.querySelectorAll('tr.budget-row, tr.custom-row').forEach(row => {
        // For budget-row: get product group from data-group attribute of inputs
        // (budget-row doesn't have columns 1-3, they're part of actual-row via rowspan)
        // For custom-row: get from the 3rd column (select or span)
        let productGroup;
        
        if (row.classList.contains('budget-row')) {
          // Budget row: get product group from first input's data-group attribute
          const firstInput = row.querySelector('input[data-group]');
          productGroup = firstInput ? firstInput.dataset.group : '';
        } else {
          // Custom row: get from the 3rd column (select or span)
          const productGroupCell = row.querySelector('td:nth-child(3)');
          if (productGroupCell) {
            const selectElem = productGroupCell.querySelector('select, span');
            if (selectElem) {
              productGroup = selectElem.tagName === 'SELECT' ? selectElem.value : selectElem.textContent.trim();
            } else {
              productGroup = productGroupCell.textContent.trim();
            }
          }
        }
        
        if (!productGroup) return;
        
        if (!productGroupData[productGroup]) {
          productGroupData[productGroup] = { actual: 0, budget: 0 };
        }
        
        // Sum all budget inputs
        const inputs = row.querySelectorAll('input[data-month]');
        inputs.forEach(input => {
          const val = parseFloat(input.value.replace(/,/g, '')) || 0;
          productGroupData[productGroup].budget += val;
        });
      });
      
      // Filter out product groups with no data
      const filteredData = Object.entries(productGroupData)
        .filter(([_, data]) => data.actual > 0 || data.budget > 0)
        .sort((a, b) => (b[1].actual + b[1].budget) - (a[1].actual + a[1].budget));
      
      if (filteredData.length === 0) {
        document.getElementById('productGroupChartContainer').style.display = 'none';
        return;
      }
      
      document.getElementById('productGroupChartContainer').style.display = 'block';
      
      // Prepare chart data
      const labels = filteredData.map(([pg]) => pg);
      const actualData = filteredData.map(([_, data]) => data.actual.toFixed(2));
      const budgetData = filteredData.map(([_, data]) => data.budget.toFixed(2));
      
      // Update table
      const tableBody = document.getElementById('productGroupTableBody');
      tableBody.innerHTML = filteredData.map(([pg, data]) => {
        let varianceClass, varianceText;
        if (data.actual === 0 && data.budget > 0) {
          // New product group - no actual, only budget
          varianceClass = 'pg-variance-new';
          varianceText = 'NEW';
        } else if (data.actual > 0) {
          const variance = ((data.budget - data.actual) / data.actual) * 100;
          varianceClass = variance > 5 ? 'pg-variance-positive' : variance < -5 ? 'pg-variance-negative' : 'pg-variance-neutral';
          varianceText = (variance > 0 ? '+' : '') + variance.toFixed(1) + '%';
        } else {
          varianceClass = 'pg-variance-neutral';
          varianceText = '0.0%';
        }
        
        return '<tr>' +
          '<td>' + pg + '</td>' +
          '<td>' + data.actual.toFixed(2) + '</td>' +
          '<td>' + data.budget.toFixed(2) + '</td>' +
          '<td><span class="' + varianceClass + '">' + varianceText + '</span></td>' +
          '</tr>';
      }).join('');
      
      // Calculate and update totals in footer
      const totalActual = filteredData.reduce((sum, [_, data]) => sum + data.actual, 0);
      const totalBudget = filteredData.reduce((sum, [_, data]) => sum + data.budget, 0);
      let totalVarianceClass, totalVarianceText;
      if (totalActual === 0 && totalBudget > 0) {
        totalVarianceClass = 'pg-variance-new';
        totalVarianceText = 'NEW';
      } else if (totalActual > 0) {
        const totalVariance = ((totalBudget - totalActual) / totalActual) * 100;
        totalVarianceClass = totalVariance > 5 ? 'pg-variance-positive' : totalVariance < -5 ? 'pg-variance-negative' : 'pg-variance-neutral';
        totalVarianceText = (totalVariance > 0 ? '+' : '') + totalVariance.toFixed(1) + '%';
      } else {
        totalVarianceClass = 'pg-variance-neutral';
        totalVarianceText = '0.0%';
      }
      
      document.getElementById('pgTotalActual').innerHTML = '<strong>' + totalActual.toFixed(2) + '</strong>';
      document.getElementById('pgTotalBudget').innerHTML = '<strong>' + totalBudget.toFixed(2) + '</strong>';
      const totalVarCell = document.getElementById('pgTotalVariance');
      totalVarCell.innerHTML = '<strong><span class="' + totalVarianceClass + '">' + totalVarianceText + '</span></strong>';
      totalVarCell.className = '';
      
      // Update or create chart
      const ctx = document.getElementById('productGroupChart').getContext('2d');
      
      if (productGroupChartInstance) {
        productGroupChartInstance.data.labels = labels;
        productGroupChartInstance.data.datasets[0].data = actualData;
        productGroupChartInstance.data.datasets[1].data = budgetData;
        productGroupChartInstance.update();
      } else {
        productGroupChartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Actual ' + formData.actualYear + ' (MT)',
                data: actualData,
                backgroundColor: 'rgba(24, 144, 255, 0.7)',
                borderColor: 'rgba(24, 144, 255, 1)',
                borderWidth: 1
              },
              {
                label: 'Budget ' + formData.budgetYear + ' (MT)',
                data: budgetData,
                backgroundColor: 'rgba(255, 235, 59, 0.7)',
                borderColor: 'rgba(212, 136, 6, 1)',
                borderWidth: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + parseFloat(context.parsed.y).toFixed(2) + ' MT';
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: function(value) {
                    return value.toFixed(0) + ' MT';
                  }
                }
              }
            }
          }
        });
      }
    }
    
    function addCustomRow() {
      const rowId = customRowCounter++;
      const tbody = document.getElementById('tableBody');
      
      const budgetCells = Array.from({ length: 12 }, (_, i) => {
        const month = i + 1;
        return '<td><input type="text" data-customer="" data-country="" data-group="" data-month="' + month + '" placeholder="0" class="custom-input" disabled /></td>';
      }).join('');
      
      const customerOptions = mergedCustomers.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '">' + c + '</option>').join('');
      const countryOptions = countries.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '">' + c + '</option>').join('');
      const productGroupOptions = productGroups.map(pg => '<option value="' + pg.replace(/"/g, '&quot;') + '">' + pg + '</option>').join('');
      
      const newRow = document.createElement('tr');
      newRow.className = 'custom-row';
      newRow.setAttribute('data-row-id', rowId);
      newRow.innerHTML = '<td style="padding: 8px; border: 1px solid #ddd; background-color: #fff; position: sticky; left: 0; z-index: 5; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' +
        '<div class="customer-cell" style="display: flex; align-items: center; gap: 4px;">' +
        '<select class="customer-select" style="flex: 1;">' +
        '<option value="" disabled selected>Select customer</option>' +
        '<option value="__NEW__" style="font-style: italic; color: #1890ff;">+ Add New Customer</option>' +
        customerOptions +
        '</select>' +
        '<input type="text" class="new-customer-input" placeholder="Enter new customer name" style="flex: 1; font-weight: 600; display:none;" />' +
        '<button class="delete-btn" onclick="removeCustomRow(this)">√ó</button>' +
        '</div>' +
        '</td>' +
        '<td>' +
        '<select class="country-select" style="width: 100%;">' +
        '<option value="" disabled selected>Select country</option>' +
        countryOptions +
        '</select>' +
        '</td>' +
        '<td>' +
        '<select class="product-group-select" style="width: 100%;">' +
        '<option value="" disabled selected>Select product group</option>' +
        productGroupOptions +
        '</select>' +
        '</td>' +
        budgetCells +
        '<td class="custom-row-total" style="background-color: #FFEB3B; text-align: center; font-weight: 700;">0.00</td>';

      tbody.appendChild(newRow);
      attachRowListeners(newRow);
    }
    
    function removeCustomRow(btn) {
      const row = btn.closest('tr.custom-row');
      if (row && confirm('Remove this row?')) {
        row.remove();
        recalculateTotals();
      }
    }
    
    function attachRowListeners(row) {
      if (!row) return;
      
      const customerSelect = row.querySelector('.customer-select');
      const customerInput = row.querySelector('.new-customer-input');
      const countrySelect = row.querySelector('.country-select');
      const productGroupSelect = row.querySelector('.product-group-select');
      const inputs = row.querySelectorAll('input.custom-input');
      
      // Make dropdowns searchable
      if (customerSelect) makeSelectSearchable(customerSelect);
      if (countrySelect) makeSelectSearchable(countrySelect);
      if (productGroupSelect) makeSelectSearchable(productGroupSelect);
      
      const showCustomerInput = () => {
        if (customerInput) {
          customerInput.style.display = 'inline-block';
          customerInput.value = '';
          customerInput.focus();
        }
        customerSelect.style.display = 'none';
      };
      
      const showCustomerSelect = () => {
        customerSelect.style.display = 'inline-block';
        if (customerInput) {
          customerInput.style.display = 'none';
        }
      };
      
      const applyCustomerSelection = (customer) => {
        inputs.forEach(input => {
          input.dataset.customer = customer || '';
        });
        
        if (customer && countrySelect) {
          console.log('üîç Searching for customer:', customer);
          
          // Normalize customer name for comparison (trim and case-insensitive)
          const normalizedCustomer = customer.trim().toLowerCase();
          
          const actualRow = Array.from(document.querySelectorAll('tr.actual-row')).find(actual => {
            const cell = actual.querySelector('td:first-child');
            if (!cell) return false;
            const cellText = cell.textContent.trim().toLowerCase();
            console.log('   Comparing with actual-row customer:', cell.textContent.trim(), '| Match:', cellText === normalizedCustomer);
            return cellText === normalizedCustomer;
          });
          
          if (actualRow) {
            console.log('‚úì Found matching actual-row');
            const countryCell = actualRow.querySelector('td:nth-child(2)');
            if (countryCell) {
              const countryName = countryCell.textContent.trim();
              console.log('‚úì Found country:', countryName);
              countrySelect.value = countryName;
              countrySelect.disabled = true;
              inputs.forEach(input => {
                input.dataset.country = countryName;
              });
            } else {
              console.warn('‚ö†Ô∏è Country cell not found in actual-row');
            }
          } else {
            console.warn('‚ö†Ô∏è No matching actual-row found for customer:', customer);
            console.log('   Available customers in actual-rows:');
            document.querySelectorAll('tr.actual-row').forEach(row => {
              const cell = row.querySelector('td:first-child');
              if (cell) console.log('      -', cell.textContent.trim());
            });
            countrySelect.disabled = false;
          }
        } else if (countrySelect) {
          countrySelect.disabled = false;
          countrySelect.value = '';
          inputs.forEach(input => {
            input.dataset.country = '';
          });
        }
        
        updateInputStates(row);
        recalculateTotals();
        setTimeout(showRecapSummary, 100);
      };
      
      const saveNewCustomer = () => {
        if (!customerInput) return;
        const newCustomerName = customerInput.value.trim();
        
        if (!newCustomerName) {
          showCustomerSelect();
          customerSelect.value = '';
          applyCustomerSelection('');
          return;
        }
        
        // Replace select/input with plain text span matching other customer names
        const customerCell = row.querySelector('.customer-cell');
        customerCell.innerHTML = '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + newCustomerName.replace(/"/g, '&quot;') + '</span>' +
          '<button class="delete-btn" onclick="removeCustomRow(this)">√ó</button>';
        
        countrySelect.disabled = false;
        countrySelect.value = '';
        inputs.forEach(input => {
          input.dataset.customer = newCustomerName;
          input.dataset.country = '';
        });
        updateInputStates(row);
        recalculateTotals();
        setTimeout(showRecapSummary, 100);
      };
      
      const showCustomerAsText = (customerName) => {
        const customerCell = row.querySelector('.customer-cell');
        if (customerCell && customerName) {
          customerCell.innerHTML = '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + customerName.replace(/"/g, '&quot;') + '</span>' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">√ó</button>';
        }
      };
      
      if (customerSelect) {
        customerSelect.addEventListener('change', function() {
          const customer = this.value;
          if (customer === '__NEW__') {
            this.value = '';
            showCustomerInput();
            inputs.forEach(input => {
              input.dataset.customer = '';
              input.dataset.country = '';
            });
            if (countrySelect) {
              countrySelect.disabled = false;
              countrySelect.value = '';
            }
            updateInputStates(row);
            return;
          }
          
          if (customer) {
            // Replace select with plain text span matching other customer names
            showCustomerAsText(customer);
          } else {
            showCustomerSelect();
          }
          applyCustomerSelection(customer);
          recalculateTotals();
        });
      }
      
      if (customerInput) {
        customerInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveNewCustomer();
          }
        });
        
        customerInput.addEventListener('blur', function() {
          saveNewCustomer();
        });
        
        // Update input states as user types new customer name
        customerInput.addEventListener('input', function() {
          updateInputStates(row);
        });
        
        if (customerInput.style.display !== 'none') {
          customerInput.focus();
        }
      }
      
      if (countrySelect) {
        countrySelect.addEventListener('change', function() {
          const country = this.value;
          inputs.forEach(input => {
            input.dataset.country = country || '';
          });
          updateInputStates(row);
          recalculateTotals();
          setTimeout(showRecapSummary, 100);
        });
      }
      
      if (productGroupSelect) {
        productGroupSelect.addEventListener('change', function() {
          const productGroup = this.value;
          inputs.forEach(input => {
            input.dataset.group = productGroup || '';
          });
          updateInputStates(row);
          recalculateTotals();
          setTimeout(showRecapSummary, 100);
        });
      }
      
      inputs.forEach(input => {
        input.addEventListener('focus', function() {
          // Show notification if trying to enter value without complete info
          if (this.disabled) {
            const customer = this.dataset.customer || '';
            const country = this.dataset.country || '';
            const productGroup = this.dataset.group || '';
            
            const missing = [];
            if (!customer) missing.push('Customer Name');
            if (!country) missing.push('Country');
            if (!productGroup) missing.push('Product Group');
            
            if (missing.length > 0) {
              alert('‚ö†Ô∏è Please fill in the following before entering budget values:\\n\\n' + missing.join('\\n'));
              this.blur();
            }
          }
        });
        
        input.addEventListener('blur', function() {
          const val = this.value;
          if (val) {
            this.value = formatMT(val);
          }
          recalculateTotals();
        });
        
        input.addEventListener('input', function() {
          this.value = this.value.replace(/[^0-9.,]/g, '');
          recalculateTotals();
        });
      });
      
      // Set initial state
      updateInputStates(row);
    }
    
    function updateInputStates(row) {
      // Query fresh from DOM each time to handle dynamic changes
      const customerSelect = row.querySelector('.customer-select');
      const customerInput = row.querySelector('.new-customer-input');
      const customerSpan = row.querySelector('.customer-cell span:not(.delete-btn)');
      const countrySelect = row.querySelector('.country-select');
      const productGroupSelect = row.querySelector('.product-group-select');
      const inputs = row.querySelectorAll('input.custom-input');
      
      // Get customer value from select, input field, or span text
      let customer = '';
      if (customerSelect && customerSelect.value && customerSelect.value !== '__NEW__') {
        customer = customerSelect.value;
      } else if (customerInput && customerInput.style.display !== 'none' && customerInput.value.trim()) {
        // User is typing new customer name in input field
        customer = customerInput.value.trim();
      } else if (customerSpan) {
        // Customer name already confirmed and shown as span
        customer = customerSpan.textContent.trim();
      }
      
      const country = countrySelect ? countrySelect.value : '';
      const productGroup = productGroupSelect ? productGroupSelect.value : '';
      
      const isComplete = customer && country && productGroup;
      
      console.log('updateInputStates:', { customer, country, productGroup, isComplete, customerInput: customerInput?.value });
      
      // Disable country and product group until customer is selected
      if (countrySelect && countrySelect.disabled === false) {
        // Only disable if not already disabled by other logic (e.g., existing customer auto-fill)
        const hasCustomer = !!customer;
        if (!hasCustomer && !countrySelect.dataset.keepEnabled) {
          countrySelect.disabled = true;
        } else if (hasCustomer) {
          countrySelect.disabled = false;
        }
      }
      
      if (productGroupSelect) {
        const hasCustomer = !!customer;
        productGroupSelect.disabled = !hasCustomer;
      }
      
      inputs.forEach(input => {
        input.disabled = !isComplete;
        // Update dataset with customer, country, and product group values
        if (customer) {
          input.dataset.customer = customer;
        }
        if (country) {
          input.dataset.country = country;
        }
        if (productGroup) {
          input.dataset.group = productGroup;
        }
      });
    }
    
    document.querySelectorAll('tr.custom-row').forEach(row => {
      attachRowListeners(row);
    });
    
    document.querySelectorAll('input:not(.custom-input)').forEach(input => {
      input.addEventListener('blur', function() {
        const val = this.value;
        if (val) {
          this.value = formatMT(val);
        }
        recalculateTotals();
      });
      
      input.addEventListener('input', function() {
        this.value = this.value.replace(/[^0-9.,]/g, '');
        recalculateTotals();
      });
    });
    
    const addRowBtn = document.getElementById('addRowBtn');
    if (addRowBtn) {
      addRowBtn.addEventListener('click', addCustomRow);
    }
    
    // Function to calculate and display recap summary (Budget vs Actual comparison)
    function showRecapSummary() {
      // Budget data from inputs
      const budgetInputs = document.querySelectorAll('input[data-month]');
      const budgetCustomerSet = new Set();
      let budgetTotalMT = 0;
      let budgetTotalAmount = 0;
      
      budgetInputs.forEach(input => {
        const value = parseFloat(input.value?.replace(/,/g, '')) || 0;
        if (value > 0) {
          const customer = input.dataset.customer;
          const productGroup = (input.dataset.group || '').toLowerCase();
          
          if (customer) budgetCustomerSet.add(customer);
          budgetTotalMT += value;
          
          // Calculate budget amount using pricing
          const pricing = pricingMap[productGroup] || { sellingPrice: 0 };
          const sellingPrice = typeof pricing === 'object' ? (pricing.sellingPrice || 0) : pricing;
          budgetTotalAmount += value * 1000 * sellingPrice;
        }
      });
      
      // Actual data from actual rows (table cells, not inputs)
      const actualCustomerSet = new Set();
      let actualTotalMT = 0;
      let actualTotalAmount = 0;
      
      document.querySelectorAll('tr.actual-row').forEach(row => {
        const customerCell = row.querySelector('td:first-child');
        if (customerCell) {
          const customerName = customerCell.textContent.trim();
          if (customerName) actualCustomerSet.add(customerName);
        }
        
        // Get actual MT values (columns 4-15, excluding last Total column)
        const cells = row.querySelectorAll('td:nth-child(n+4):not(:last-child)');
        cells.forEach(cell => {
          const val = parseFloat(cell.textContent?.replace(/,/g, '')) || 0;
          if (val > 0) actualTotalMT += val;
        });
      });
      
      // Get actual amount from footer row
      const actualAmountRow = document.querySelector('tfoot tr.actual-amount-total');
      if (actualAmountRow) {
        const totalCell = actualAmountRow.querySelector('td:last-child');
        if (totalCell) {
          const text = totalCell.textContent || '';
          if (text.includes('M')) {
            actualTotalAmount = parseFloat(text.replace('M', '')) * 1000000;
          } else if (text.includes('K')) {
            actualTotalAmount = parseFloat(text.replace('K', '')) * 1000;
          } else {
            actualTotalAmount = parseFloat(text.replace(/,/g, '')) || 0;
          }
        }
      }
      
      // Format values - Volume in full format (xxx,xxx.xx), Amount with K/M suffix
      const formatMTFull = (val) => {
        return val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      };
      const formatAmountCompact = (val) => {
        if (val >= 1000000) return (val / 1000000).toFixed(1) + 'M';
        if (val >= 1000) return (val / 1000).toFixed(1) + 'K';
        return val.toFixed(0);
      };
      
      // Calculate variances (Budget - Actual)
      const mtVariancePct = actualTotalMT > 0 ? (((budgetTotalMT - actualTotalMT) / actualTotalMT) * 100) : 0;
      const amountVariancePct = actualTotalAmount > 0 ? (((budgetTotalAmount - actualTotalAmount) / actualTotalAmount) * 100) : 0;
      const customerVariance = budgetCustomerSet.size - actualCustomerSet.size;
      const customerVariancePct = actualCustomerSet.size > 0 ? ((customerVariance / actualCustomerSet.size) * 100) : 0;
      
      // Update DOM with values
      document.getElementById('recapActualMT').textContent = formatMTFull(actualTotalMT);
      document.getElementById('recapBudgetMT').textContent = formatMTFull(budgetTotalMT);
      
      document.getElementById('recapActualAmount').textContent = formatAmountCompact(actualTotalAmount);
      document.getElementById('recapBudgetAmount').textContent = formatAmountCompact(budgetTotalAmount);
      
      document.getElementById('recapActualCustomers').textContent = actualCustomerSet.size;
      document.getElementById('recapBudgetCustomers').textContent = budgetCustomerSet.size;
      
      // Update variances with just percentage
      const mtVarEl = document.getElementById('recapMTVariance');
      mtVarEl.textContent = (mtVariancePct >= 0 ? '+' : '') + mtVariancePct.toFixed(0) + '%';
      mtVarEl.className = 'recap-variance-value ' + (mtVariancePct > 0 ? 'positive' : (mtVariancePct < 0 ? 'negative' : 'neutral'));
      
      const amountVarEl = document.getElementById('recapAmountVariance');
      amountVarEl.textContent = (amountVariancePct >= 0 ? '+' : '') + amountVariancePct.toFixed(0) + '%';
      amountVarEl.className = 'recap-variance-value ' + (amountVariancePct > 0 ? 'positive' : (amountVariancePct < 0 ? 'negative' : 'neutral'));
      
      const custVarEl = document.getElementById('recapCustomerVariance');
      custVarEl.textContent = (customerVariance >= 0 ? '+' : '') + customerVariance;
      custVarEl.className = 'recap-variance-value ' + (customerVariance > 0 ? 'positive' : (customerVariance < 0 ? 'negative' : 'neutral'));
      
      // Always show the recap container
      document.getElementById('recapContainer').style.display = 'block';
    }
    
    // Initialize: Ensure ALL budget inputs are enabled and editable
    // This is critical for draft files to be editable when reopened
    function initializeInputs() {
      document.querySelectorAll('input[data-month]').forEach(input => {
        // Explicitly enable all inputs (remove disabled attribute if present)
        input.removeAttribute('disabled');
        input.disabled = false;
        input.readOnly = false;
        
        // Ensure inputs have proper styling (not grayed out)
        input.style.backgroundColor = 'transparent';
        input.style.cursor = 'text';
      });
    }
    
    // Run initialization immediately
    initializeInputs();
    
    // Also run after a short delay to catch any dynamically added inputs
    setTimeout(initializeInputs, 100);
    
    // Show recap on page load and after any input change
    recalculateTotals();
    showRecapSummary();
    
    // Attach event listeners to ALL budget inputs (both regular and custom rows)
    // This ensures inputs are editable and functional
    document.querySelectorAll('input[data-month]').forEach(input => {
      // Ensure input is enabled (remove any disabled attribute)
      input.removeAttribute('disabled');
      input.disabled = false;
      
      // Format on blur
      input.addEventListener('blur', function() {
        const val = this.value;
        if (val) {
          this.value = formatMT(val);
        }
        recalculateTotals();
        setTimeout(showRecapSummary, 100);
      });
      
      // Format on input (remove non-numeric characters)
      input.addEventListener('input', function() {
        this.value = this.value.replace(/[^0-9.,]/g, '');
        recalculateTotals();
        setTimeout(showRecapSummary, 100);
      });
    });
    
    // Save Draft Button - keeps form editable
    document.getElementById('saveDraftBtn').addEventListener('click', function() {
      // Recalculate totals first
      recalculateTotals();
      
      // CRITICAL: Update value attributes in the DOM so they persist in the saved file
      // cloneNode copies attributes, not current property values
      document.querySelectorAll('input').forEach(input => {
        input.setAttribute('value', input.value);
      });
      
      document.querySelectorAll('select').forEach(select => {
        const options = select.querySelectorAll('option');
        options.forEach(opt => {
          if (opt.selected) {
            opt.setAttribute('selected', 'selected');
          } else {
            opt.removeAttribute('selected');
          }
        });
      });
      
      // Clone the entire document AS-IS (keep everything editable)
      const clonedDoc = document.cloneNode(true);
      
      // Ensure inputs are enabled in draft (in case they were disabled)
      clonedDoc.querySelectorAll('input').forEach(input => {
        input.removeAttribute('disabled');
      });
      
      // Add draft metadata (for identification)
      const draftMetadata = {
        isDraft: true,
        division: formData.division,
        salesRep: formData.salesRep,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'budget_draft'
      };
      
      // Remove existing draft metadata script if it exists
      const existingDraftScript = clonedDoc.getElementById('draftMetadata');
      if (existingDraftScript) {
        existingDraftScript.remove();
      }
      
      // Embed draft metadata
      const draftScript = clonedDoc.createElement('script');
      draftScript.id = 'draftMetadata';
      draftScript.textContent = '/* DRAFT METADATA */\\n' +
        'var draftMetadata = ' + JSON.stringify(draftMetadata, null, 2) + ';';
      clonedDoc.body.appendChild(draftScript);
      
      // Get HTML content with IPD signature
      const htmlContent = '<!DOCTYPE html>\\n<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=SALES_REP_BUDGET :: DO_NOT_EDIT_THIS_LINE -->\\n' + clonedDoc.documentElement.outerHTML;
      
      // Generate dynamic filename with DRAFT prefix
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      // Format: DRAFT_Division_SalesRep_BudgetYear_YYYYMMDD_HHMMSS.html
      const filename = 'DRAFT_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.salesRep.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      // Trigger download
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('‚úÖ Draft saved!\\n\\nYou can open this file later to continue editing.\\n\\nFilename: ' + filename + '\\n\\nüí° This is a DRAFT file - it cannot be uploaded to the system.\\nUse "Save Final" when ready to submit.');
    });
    
    // Save Final Button - creates static HTML for upload
    document.getElementById('saveFinalBtn').addEventListener('click', function() {
      // Validate: Check if any budget data is entered
      const budgetInputs = document.querySelectorAll('input:not([disabled])[data-month]');
      const hasData = Array.from(budgetInputs).some(input => {
        const val = input.value.replace(/,/g, '');
        return val && parseFloat(val) > 0;
      });
      
      if (!hasData) {
        alert('‚ö†Ô∏è No budget data entered!\\n\\nPlease enter at least one budget value before saving final version.');
        return;
      }
      
      // Confirm finalization
      if (!confirm('üìã Finalize Budget?\\n\\nThis will create a final version that:\\n‚Ä¢ Cannot be edited\\n‚Ä¢ Can be uploaded to the system\\n‚Ä¢ Will calculate Amount and MoRM values\\n\\nDo you want to proceed?')) {
        return;
      }
      
      // Recalculate totals first
      recalculateTotals();
      
      // CRITICAL: Update value attributes in the DOM so they persist in the saved file
      // cloneNode copies attributes, not current property values
      document.querySelectorAll('input').forEach(input => {
        input.setAttribute('value', input.value);
      });
      
      document.querySelectorAll('select').forEach(select => {
        const options = select.querySelectorAll('option');
        options.forEach(opt => {
          if (opt.selected) {
            opt.setAttribute('selected', 'selected');
          } else {
            opt.removeAttribute('selected');
          }
        });
      });
      
      // Clone the document
      const clonedDoc = document.cloneNode(true);
      
      // Replace all budget inputs with hardcoded text
      clonedDoc.querySelectorAll('input[data-month]').forEach(input => {
        const value = input.value || '0';
        const td = input.parentElement;
        td.innerHTML = value;
        td.style.textAlign = 'right';
        td.style.fontWeight = '500';
        td.style.padding = '6px 8px';
      });
      
      // Remove all interactive elements (buttons, selects)
      clonedDoc.querySelectorAll('.delete-btn').forEach(btn => btn.remove());
      clonedDoc.querySelectorAll('select').forEach(select => {
        const value = select.options[select.selectedIndex]?.text || '';
        select.outerHTML = '<span>' + value + '</span>';
      });
      
      // Replace new customer inputs with text before removing
      clonedDoc.querySelectorAll('.new-customer-input').forEach(input => {
        if (input.style.display !== 'none' && input.value) {
           const span = clonedDoc.createElement('span');
           span.textContent = input.value;
           span.style.fontWeight = '600';
           if (input.parentNode) {
             input.parentNode.insertBefore(span, input);
           }
        }
        input.remove();
      });
      // clonedDoc.querySelectorAll('.new-customer-input').forEach(input => input.remove()); // Removed redundant call
      
      // Remove Add Row button
      const addBtn = clonedDoc.getElementById('addRowBtn');
      if (addBtn) addBtn.remove();
      
      // Remove Save Draft and Save Final buttons
      const saveDraftBtn = clonedDoc.getElementById('saveDraftBtn');
      if (saveDraftBtn) saveDraftBtn.remove();
      const saveFinalBtn = clonedDoc.getElementById('saveFinalBtn');
      if (saveFinalBtn) saveFinalBtn.remove();
      
      // Remove the tip message div (specific selector to avoid removing parent containers)
      const allDivs = clonedDoc.querySelectorAll('div');
      allDivs.forEach(div => {
        // Only remove if this div directly contains the tip text and has the specific styling
        const hasMarginTop = div.style.marginTop === '8px' || div.getAttribute('style')?.includes('margin-top: 8px');
        const hasTipText = div.innerHTML && div.innerHTML.includes('üí° <strong>Tip:</strong>');
        if (hasMarginTop && hasTipText) {
          div.remove();
        }
      });
      
      // Convert chart canvas to static image BEFORE removing scripts
      const originalCanvas = document.getElementById('productGroupChart');
      if (originalCanvas && productGroupChartInstance) {
        try {
          // Get the chart image as base64 PNG
          const chartImageUrl = originalCanvas.toDataURL('image/png', 1.0);
          
          // Find the canvas in cloned document and replace with image
          const clonedCanvas = clonedDoc.getElementById('productGroupChart');
          if (clonedCanvas) {
            const img = clonedDoc.createElement('img');
            img.src = chartImageUrl;
            img.alt = 'Product Group Chart';
            img.style.cssText = 'max-width: 100%; height: auto; display: block;';
            clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
          }
        } catch (e) {
          console.error('Failed to convert chart to image:', e);
        }
      }
      
      // Remove all scripts to make it static
      clonedDoc.querySelectorAll('script').forEach(script => {
        if (!script.id || script.id !== 'savedBudgetData') {
          script.remove();
        }
      });
      
      // Collect budget data for backend
      const budgetData = [];
      document.querySelectorAll('input:not([disabled])[data-month]').forEach(input => {
        const val = input.value.replace(/,/g, '');
        if (val && parseFloat(val) > 0) {
          budgetData.push({
            customer: input.dataset.customer,
            country: input.dataset.country,
            productGroup: input.dataset.group,
            month: parseInt(input.dataset.month),
            value: parseFloat(val) * 1000
          });
        }
      });
      
      // Add metadata and saved data as script for easy database import
      const metadata = {
        division: formData.division,
        salesRep: formData.salesRep,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'budget_import'
      };
      
      const savedDataScript = clonedDoc.createElement('script');
      savedDataScript.id = 'savedBudgetData';
      savedDataScript.textContent = 
        '/* BUDGET DATA FOR DATABASE IMPORT */\\n' +
        'const budgetMetadata = ' + JSON.stringify(metadata, null, 2) + ';\\n' +
        'const savedBudget = ' + JSON.stringify(budgetData, null, 2) + ';';
      clonedDoc.body.appendChild(savedDataScript);
      
      // Get HTML content with IPD signature
      const htmlContent = '<!DOCTYPE html>\\n<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=SALES_REP_BUDGET :: DO_NOT_EDIT_THIS_LINE -->\\n' + clonedDoc.documentElement.outerHTML;
      
      // Generate dynamic filename with budget year, date, and time
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      // Format: FINAL_Division_SalesRep_BudgetYear_YYYYMMDD_HHMMSS.html
      const filename = 'FINAL_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.salesRep.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      // Trigger download
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('‚úÖ Final budget saved!\\n\\nFilename: ' + filename + '\\n\\nThis file is ready for upload to the system.\\n\\nüì§ Next step: Upload this file in the Budget Tab.');
    });
  </script>
</body>
</html>`;
    
    // Generate timestamp for filename
    const now = new Date();
    const dateStr = now.getFullYear().toString() + 
      String(now.getMonth() + 1).padStart(2, '0') + 
      String(now.getDate()).padStart(2, '0');
    const timeStr = String(now.getHours()).padStart(2, '0') + 
      String(now.getMinutes()).padStart(2, '0') + 
      String(now.getSeconds()).padStart(2, '0');
    const timestamp = dateStr + '_' + timeStr;
    
    // Initial export is a DRAFT - user must Save Final to create uploadable version
    const filename = `DRAFT_${division}_${salesRep.replace(/[^a-zA-Z0-9]/g, '_')}_${budgetYear}_${timestamp}.html`;
    
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(html);
    
  } catch (error) {
    console.error('‚ùå Error exporting HTML budget form:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// IMPORT FILLED BUDGET HTML
// ============================================================================

/**
 * POST /api/aebf/import-budget-html
 * Import filled budget data from saved HTML file
 * Expects HTML file upload with embedded budget data
 */
router.post('/import-budget-html', async (req, res) => {
  console.log('üì• Import budget HTML request received');
  try {
    const { htmlContent, currentSalesRep, currentDivision } = req.body;
    
    if (!htmlContent) {
      console.error('‚ùå No HTML content provided');
      return res.status(400).json({
        success: false,
        error: 'No HTML content provided'
      });
    }
    
    console.log('‚úÖ HTML content received, length:', htmlContent.length);
    console.log('üìã Current context:', { currentSalesRep, currentDivision });
    
    // ============================================================================
    // VALIDATION STEP 0: File Signature Check
    // ============================================================================
    
    // Check for IPD Budget System signature (validates this is a genuine export)
    const signaturePattern = /<!--\s*IPD_BUDGET_SYSTEM_v[\d.]+\s*::\s*TYPE=(SALES_REP_BUDGET|DIVISIONAL_BUDGET)\s*::/;
    const signatureMatch = htmlContent.match(signaturePattern);
    
    if (!signatureMatch) {
      // Allow legacy files without signature but log warning
      console.warn('‚ö†Ô∏è File missing IPD Budget System signature - may be legacy or modified file');
    } else if (signatureMatch[1] !== 'SALES_REP_BUDGET') {
      console.error('‚ùå Wrong file type: expected SALES_REP_BUDGET, got', signatureMatch[1]);
      return res.status(400).json({
        success: false,
        error: 'Wrong file type. This appears to be a Divisional Budget file. Please use the Divisional Budget import instead.'
      });
    } else {
      console.log('‚úÖ Valid IPD Budget System signature detected');
    }
    
    // ============================================================================
    // VALIDATION STEP 1: Extract and Parse Data
    // ============================================================================
    
    // Extract metadata and budget data from HTML
    // Prefer structured <script id="savedBudgetData"> where the exporter embeds JSON
    let metadata = null;
    let budgetData = null;

    try {
      const scriptTagMatch = htmlContent.match(/<script[^>]*id=["']savedBudgetData["'][^>]*>([\s\S]*?)<\/script>/i);
      if (scriptTagMatch && scriptTagMatch[1]) {
        const scriptContent = scriptTagMatch[1];

        // Improved JSON extraction - handle multi-line JSON properly
        const metaMatch = scriptContent.match(/const\s+budgetMetadata\s*=\s*(\{[\s\S]*?\});/);
        const dataMatch = scriptContent.match(/const\s+savedBudget\s*=\s*(\[[\s\S]*?\]);/);

        if (metaMatch && dataMatch) {
          try {
            metadata = JSON.parse(metaMatch[1]);
          } catch (e) {
            console.error('‚ùå Failed to JSON.parse metadata from script tag:', e.message);
            return res.status(400).json({ success: false, error: 'Failed to parse budget metadata from file.' });
          }

          try {
            budgetData = JSON.parse(dataMatch[1]);
          } catch (e) {
            console.error('‚ùå Failed to JSON.parse budget data from script tag:', e.message);
            return res.status(400).json({ success: false, error: 'Failed to parse budget data from file.' });
          }
        }
      }

      // Fallback: older files might not have script id, try previous regex approach limited to the whole HTML
      if (!metadata || !budgetData) {
        const metadataMatch = htmlContent.match(/const budgetMetadata = (\{[\s\S]*?\});/);
        const budgetDataMatch = htmlContent.match(/const savedBudget = (\[[\s\S]*?\]);/);
        if (metadataMatch && budgetDataMatch) {
          metadata = JSON.parse(metadataMatch[1]);
          budgetData = JSON.parse(budgetDataMatch[1]);
        }
      }

      if (!metadata || !budgetData) {
        console.error('‚ùå Invalid HTML format - missing savedBudgetData script or metadata/savedBudget variables');
        return res.status(400).json({ success: false, error: 'Invalid HTML file format. Missing budget metadata or saved budget data. Please re-export using the in-app "Save Final" button.' });
      }

      console.log('‚úÖ Parsed metadata and budget data from HTML export');
      console.log('‚úÖ Metadata:', { division: metadata.division, salesRep: metadata.salesRep, budgetYear: metadata.budgetYear });
      console.log('‚úÖ Budget records count:', Array.isArray(budgetData) ? budgetData.length : 0);
    } catch (e) {
      console.error('‚ùå Error extracting data from HTML:', e);
      return res.status(400).json({ success: false, error: 'Failed to extract budget data from file. Ensure the file was exported from the application using "Save Final".' });
    }
    
    // ============================================================================
    // VALIDATION STEP 1.5: Division Mismatch Check
    // ============================================================================
    
    // NOTE: Sales rep mismatch check removed - allow importing any sales rep's file
    // The file's embedded metadata.salesRep determines where the data is saved
    // This allows batch-importing multiple sales rep files without switching dropdown
    
    if (currentSalesRep && metadata.salesRep) {
      const currentSalesRepNormalized = currentSalesRep.trim().toUpperCase();
      const fileSalesRepNormalized = metadata.salesRep.trim().toUpperCase();
      
      if (currentSalesRepNormalized !== fileSalesRepNormalized) {
        console.log('‚ÑπÔ∏è Sales rep differs from current selection - will import to file\'s sales rep');
        console.log(`   Current UI: ${currentSalesRep}`);
        console.log(`   File for: ${metadata.salesRep}`);
        // No longer blocking - data will be saved to file's sales rep
      }
    }
    
    if (currentDivision && metadata.division) {
      const currentDivisionNormalized = currentDivision.trim().toUpperCase();
      const fileDivisionNormalized = metadata.division.trim().toUpperCase();
      
      if (currentDivisionNormalized !== fileDivisionNormalized) {
        console.warn('‚ö†Ô∏è Division mismatch detected');
        console.warn(`   Current: ${currentDivision}`);
        console.warn(`   File: ${metadata.division}`);
        
        return res.status(400).json({
          success: false,
          error: `‚ö†Ô∏è Division Mismatch!\n\nYou are in division: ${currentDivision}\nBut this file is for: ${metadata.division}\n\nPlease switch to the correct division and try again.`,
          mismatch: true,
          currentDivision: currentDivision,
          fileDivision: metadata.division
        });
      }
    }
    
    console.log('‚úÖ Sales rep and division validation passed');
    
    // ============================================================================
    // Generate file hash for duplicate detection
    // ============================================================================
    const crypto = require('crypto');
    const fileHash = crypto.createHash('sha256').update(htmlContent).digest('hex').substring(0, 16);
    
    // ============================================================================
    // VALIDATION STEP 2: Check for Draft File
    // ============================================================================
    
    const draftCheck = htmlContent.match(/const draftMetadata = ({[^;]+});/);
    if (draftCheck) {
      try {
        const draftMeta = JSON.parse(draftCheck[1]);
        if (draftMeta.isDraft === true) {
          console.warn('‚ö†Ô∏è Draft file rejected');
          return res.status(400).json({
            success: false,
            error: '‚ö†Ô∏è Cannot upload draft file!\n\nThis is a work-in-progress draft. Please open the file, complete your budget, and click "Save Final" before uploading.',
            isDraft: true
          });
        }
      } catch (e) {
        console.log('Draft check parse error (ignored):', e.message);
      }
    }
    
    // ============================================================================
    // VALIDATION STEP 3: Validate Metadata Structure
    // ============================================================================
    
    const validationErrors = [];
    
    if (!metadata.division || typeof metadata.division !== 'string') {
      validationErrors.push('Invalid or missing division');
    }
    
    if (!metadata.salesRep || typeof metadata.salesRep !== 'string') {
      validationErrors.push('Invalid or missing sales rep name');
    }
    
    if (!metadata.budgetYear || typeof metadata.budgetYear !== 'number' || metadata.budgetYear < 2020 || metadata.budgetYear > 2100) {
      validationErrors.push('Invalid or missing budget year (must be between 2020-2100)');
    }
    
    if (!metadata.version || metadata.version !== '1.0') {
      validationErrors.push('Unsupported file version. Please re-export from the system.');
    }
    
    if (!metadata.dataFormat || metadata.dataFormat !== 'budget_import') {
      validationErrors.push('Invalid data format. This file may not be a budget export.');
    }
    
    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'File validation failed:\n' + validationErrors.join('\n')
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 4: Validate Budget Data Structure
    // ============================================================================
    
    if (!Array.isArray(budgetData)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid budget data format. Expected an array of records.'
      });
    }
    
    if (budgetData.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No budget data found in file. The file appears to be empty.'
      });
    }
    
    if (budgetData.length > 10000) {
      return res.status(400).json({
        success: false,
        error: `Too many records (${budgetData.length}). Maximum allowed is 10,000.`
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 5: Validate Individual Records
    // ============================================================================
    
    const recordErrors = [];
    const validRecords = [];
    
    budgetData.forEach((record, index) => {
      const errors = [];
      
      // Check required fields
      if (!record.customer || typeof record.customer !== 'string' || record.customer.trim() === '') {
        errors.push('Missing or invalid customer name');
      }
      
      if (!record.country || typeof record.country !== 'string' || record.country.trim() === '') {
        errors.push('Missing or invalid country');
      }
      
      if (!record.productGroup || typeof record.productGroup !== 'string' || record.productGroup.trim() === '') {
        errors.push('Missing or invalid product group');
      }
      
      if (!record.month || typeof record.month !== 'number' || record.month < 1 || record.month > 12) {
        errors.push('Invalid month (must be 1-12)');
      }
      
      if (record.value === undefined || record.value === null) {
        errors.push('Missing value');
      } else if (typeof record.value !== 'number' || isNaN(record.value)) {
        errors.push('Invalid value (must be a number)');
      } else if (record.value < 0) {
        errors.push('Negative values not allowed');
      } else if (record.value === 0) {
        errors.push('Zero values not allowed');
      } else if (record.value > 1000000000) {
        errors.push('Value too large (max 1 billion KGS)');
      }
      
      if (errors.length > 0) {
        recordErrors.push({
          index: index + 1,
          customer: record.customer || 'Unknown',
          month: record.month || 'Unknown',
          errors: errors
        });
      } else {
        validRecords.push(record);
      }
    });
    
    // If more than 10% of records have errors, reject the file
    const errorRate = recordErrors.length / budgetData.length;
    if (errorRate > 0.1) {
      return res.status(400).json({
        success: false,
        error: `Too many invalid records (${recordErrors.length} out of ${budgetData.length}). Please check your file and try again.`,
        recordErrors: recordErrors.slice(0, 10), // Show first 10 errors
        totalErrors: recordErrors.length
      });
    }
    
    // If some records have errors, log them but continue with valid records
    if (recordErrors.length > 0) {
      console.warn(`‚ö†Ô∏è Skipping ${recordErrors.length} invalid records out of ${budgetData.length}`);
    }
    
    // Use only valid records
    budgetData = validRecords;
    
    console.log(`‚úÖ Validation passed: ${budgetData.length} valid records`);

    console.log('üì• Importing budget data:', {
      division: metadata.division,
      salesRep: metadata.salesRep,
      budgetYear: metadata.budgetYear,
      recordCount: budgetData.length,
      savedAt: metadata.savedAt
    });
    
    // Ensure sales rep budget table has required columns and unique constraint
    await ensureSalesRepBudgetColumns(metadata.division);
    
    // Start transaction using division-specific pool
    const divisionPool = getPoolForDivision(metadata.division);
    const tables = getTableNames(metadata.division);
    const client = await divisionPool.connect();
    try {
      await client.query('BEGIN');
      
      // Check if budget already exists for this sales rep/division/year
      const existingCheckQuery = `
        SELECT 
          COUNT(*) as record_count,
          MAX(uploaded_at) as last_upload,
          MAX(uploaded_filename) as last_filename
        FROM ${tables.salesRepBudget}
        WHERE UPPER(division) = UPPER($1)
        AND UPPER(salesrepname) = UPPER($2)
        AND budget_year = $3
        AND UPPER(type) = 'BUDGET'
      `;
      
      const existingCheck = await client.query(existingCheckQuery, [
        metadata.division,
        metadata.salesRep,
        metadata.budgetYear
      ]);
      
      const existingRecords = parseInt(existingCheck.rows[0].record_count);
      const lastUpload = existingCheck.rows[0].last_upload;
      const lastFilename = existingCheck.rows[0].last_filename;
      
      console.log(`üìã Existing budget check:`, {
        existingRecords,
        lastUpload,
        lastFilename
      });
      
      // 1. Fetch material and process for all product groups
      const materialProcessQuery = `
        SELECT product_group, material, process 
        FROM ${tables.materialPercentages}
      `;
      const materialProcessResult = await client.query(materialProcessQuery);
      
      // Create lookup map: productGroup -> { material, process }
      const materialProcessMap = {};
      materialProcessResult.rows.forEach(row => {
        materialProcessMap[row.product_group.toLowerCase()] = {
          material: row.material || '',
          process: row.process || ''
        };
      });
      
      console.log('üìã Material/Process lookup map:', materialProcessMap);
      
      // 2. Fetch pricing data for previous year (budgetYear - 1)
      const pricingYear = metadata.budgetYear - 1;
      const divisionCode = extractDivisionCode(metadata.division);
      console.log(`üìä Fetching pricing data for division: ${divisionCode}, year: ${pricingYear}`);
      
      let pricingResult;
      try {
        const pricingQuery = `
          SELECT product_group, asp_round, morm_round
          FROM ${tables.pricingRounding}
          WHERE UPPER(division) = UPPER($1)
          AND year = $2
        `;
        pricingResult = await client.query(pricingQuery, [divisionCode, pricingYear]);
        console.log(`‚úÖ Found ${pricingResult.rows.length} pricing records`);
      } catch (pricingError) {
        console.error('‚ùå Error querying pricing table:', pricingError);
        throw new Error(`Pricing table query failed: ${pricingError.message}. Please ensure the ${tables.pricingRounding} table exists.`);
      }
      
      // Create lookup map: productGroup -> { sellingPrice, morm }
      const pricingMap = {};
      pricingResult.rows.forEach(row => {
        const aspRound = row.asp_round ? Math.round(parseFloat(row.asp_round)) : null;
        const mormRound = row.morm_round ? Math.round(parseFloat(row.morm_round)) : null;
        pricingMap[row.product_group.toLowerCase()] = {
          sellingPrice: aspRound,
          morm: mormRound
        };
      });
      
      console.log(`üìä Pricing lookup map (Year ${pricingYear}):`, pricingMap);
      
      // ============================================================================
      // VALIDATION STEP 6: Check Pricing Data Availability
      // ============================================================================
      
      const warnings = [];
      const missingPricingProducts = new Set();
      
      budgetData.forEach(record => {
        const productGroupKey = record.productGroup.toLowerCase();
        const pricing = pricingMap[productGroupKey];
        
        if (!pricing || (pricing.sellingPrice === null && pricing.morm === null)) {
          missingPricingProducts.add(record.productGroup);
        }
      });
      
      if (missingPricingProducts.size > 0) {
        const missingList = Array.from(missingPricingProducts).join(', ');
        warnings.push(`Missing pricing data for ${missingPricingProducts.size} product group(s): ${missingList}`);
        console.warn(`‚ö†Ô∏è Missing pricing data for products: ${missingList}`);
      }
      
      if (Object.keys(pricingMap).length === 0) {
        warnings.push(`No pricing data found for year ${pricingYear}. Only KGS records will be created.`);
        console.warn(`‚ö†Ô∏è No pricing data available for year ${pricingYear}`);
      }
      
      // ============================================================================
      // BACKUP STEP: Archive existing data before deletion (if any)
      // ============================================================================
      
      const archiveTableName = `${extractDivisionCode(metadata.division)}_sales_rep_budget_archive`;
      
      if (existingRecords > 0) {
        console.log(`üì¶ Creating backup of ${existingRecords} existing records before replacement...`);
        
        // Archive to division-specific archive table (create if not exists)
        const archiveQuery = `
          INSERT INTO ${archiveTableName} (
            division, budget_year, month, type, salesrepname, customername, countryname,
            productgroup, values_type, values, material, process, uploaded_filename,
            uploaded_at, archived_at, archived_reason
          )
          SELECT 
            division, budget_year, month, type, salesrepname, customername, countryname,
            productgroup, values_type, values, material, process, uploaded_filename,
            uploaded_at, CURRENT_TIMESTAMP, 'Replaced by new upload'
          FROM ${tables.salesRepBudget}
          WHERE UPPER(division) = UPPER($1)
            AND UPPER(salesrepname) = UPPER($2)
            AND budget_year = $3 
            AND UPPER(type) = 'BUDGET'
        `;
        
        try {
          await client.query(archiveQuery, [
            metadata.division,
            metadata.salesRep,
            metadata.budgetYear
          ]);
          console.log(`‚úÖ Backup created successfully`);
        } catch (archiveError) {
          // Archive table might not exist - create it and retry
          if (archiveError.code === '42P01') { // undefined_table
            console.log('üìã Creating archive table...');
            // Rollback current transaction and start fresh
            await client.query('ROLLBACK');
            await client.query('BEGIN');
            
            // Create archive table
            await client.query(`
              CREATE TABLE IF NOT EXISTS ${archiveTableName} (
                id SERIAL PRIMARY KEY,
                division VARCHAR(50),
                budget_year INTEGER,
                month INTEGER,
                type VARCHAR(50),
                salesrepname VARCHAR(255),
                customername VARCHAR(255),
                countryname VARCHAR(100),
                productgroup VARCHAR(100),
                values_type VARCHAR(20),
                values NUMERIC(18,4),
                material VARCHAR(100),
                process VARCHAR(100),
                uploaded_filename VARCHAR(500),
                uploaded_at TIMESTAMP,
                archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                archived_reason VARCHAR(255)
              )
            `);
            
            // Retry archive insert
            await client.query(archiveQuery, [
              metadata.division,
              metadata.salesRep,
              metadata.budgetYear
            ]);
            console.log(`‚úÖ Archive table created and backup stored`);
          } else {
            console.warn('‚ö†Ô∏è Backup failed (non-critical):', archiveError.message);
            console.warn('‚ö†Ô∏è Rolling back and continuing without backup...');
            // Rollback and restart transaction to continue with import
            await client.query('ROLLBACK');
            await client.query('BEGIN');
          }
        }
      }
      
      // 3. Delete existing sales rep budget data for this combination
      const deleteQuery = `
        DELETE FROM ${tables.salesRepBudget} 
        WHERE UPPER(division) = UPPER($1)
        AND UPPER(salesrepname) = UPPER($2)
        AND budget_year = $3 
        AND UPPER(type) = 'BUDGET'
      `;
      
      const deleteResult = await client.query(deleteQuery, [
        metadata.division,
        metadata.salesRep,
        metadata.budgetYear
      ]);
      
      console.log(`üóëÔ∏è  Deleted ${deleteResult.rowCount} existing sales rep budget records`);
      
      // 4. Insert new budget data with 3 records per entry (KGS, Amount, MoRM)
      let insertedKGS = 0;
      let insertedAmount = 0;
      let insertedMoRM = 0;
      
      // Track total values for recap
      let totalKGS = 0;
      let totalAmount = 0;
      let totalMoRM = 0;
      
      // Extract filename from metadata if available
      const uploadedFilename = metadata.savedAt ? 
        `BUDGET_${metadata.division.replace(/[^a-zA-Z0-9]/g, '_')}_${metadata.salesRep.replace(/[^a-zA-Z0-9]/g, '_')}_${metadata.budgetYear}_${new Date(metadata.savedAt).toISOString().replace(/[:.]/g, '-').slice(0, -5)}.html` : 
        null;
      
      for (const record of budgetData) {
        // Lookup material and process for this product group
        const productGroupKey = record.productGroup.toLowerCase();
        const materialProcess = materialProcessMap[productGroupKey] || { material: '', process: '' };
        const pricing = pricingMap[productGroupKey] || { sellingPrice: null, morm: null };
        
        const kgsValue = record.value; // Already in KGS (MT * 1000)
        
        // Common insert query for all 3 value types
        const insertQuery = `
          INSERT INTO ${tables.salesRepBudget} (
            division,
            budget_year,
            month,
            type,
            salesrepname,
            customername,
            countryname,
            productgroup,
            values_type,
            values,
            material,
            process,
            uploaded_filename
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
          ON CONFLICT (division, budget_year, month, type, salesrepname, customername, countryname, productgroup, values_type)
          DO UPDATE SET 
            values = EXCLUDED.values,
            material = EXCLUDED.material,
            process = EXCLUDED.process,
            uploaded_at = CURRENT_TIMESTAMP,
            uploaded_filename = EXCLUDED.uploaded_filename
        `;
        
        // Insert Record 1: KGS (always insert)
        await client.query(insertQuery, [
          metadata.division,
          metadata.budgetYear,
          record.month,
          'Budget',
          metadata.salesRep,
          record.customer,
          record.country,
          record.productGroup,
          'KGS',
          kgsValue,
          materialProcess.material,
          materialProcess.process,
          uploadedFilename
        ]);
        insertedKGS++;
        totalKGS += kgsValue;
        
        // Insert Record 2: Amount (only if selling price available)
        if (pricing.sellingPrice !== null) {
          const amountValue = kgsValue * pricing.sellingPrice;
          await client.query(insertQuery, [
            metadata.division,
            metadata.budgetYear,
            record.month,
            'Budget',
            metadata.salesRep,
            record.customer,
            record.country,
            record.productGroup,
            'Amount',
            amountValue,
            materialProcess.material,
            materialProcess.process,
            uploadedFilename
          ]);
          insertedAmount++;
          totalAmount += amountValue;
        }
        
        // Insert Record 3: MoRM (only if morm price available)
        if (pricing.morm !== null) {
          const mormValue = kgsValue * pricing.morm;
          await client.query(insertQuery, [
            metadata.division,
            metadata.budgetYear,
            record.month,
            'Budget',
            metadata.salesRep,
            record.customer,
            record.country,
            record.productGroup,
            'MoRM',
            mormValue,
            materialProcess.material,
            materialProcess.process,
            uploadedFilename
          ]);
          insertedMoRM++;
          totalMoRM += mormValue;
        }
      }
      
      await client.query('COMMIT');
      
      // Calculate MT from KGS (divide by 1000)
      const totalMT = totalKGS / 1000;
      
      console.log(`‚úÖ Successfully imported sales rep budget:`);
      console.log(`   - KGS records: ${insertedKGS} (Total: ${totalKGS.toLocaleString()} KGS = ${totalMT.toLocaleString()} MT)`);
      console.log(`   - Amount records: ${insertedAmount} (Total: ${totalAmount.toLocaleString()})`);
      console.log(`   - MoRM records: ${insertedMoRM} (Total: ${totalMoRM.toLocaleString()})`);
      console.log(`   - Total records: ${insertedKGS + insertedAmount + insertedMoRM}`);
      
      res.json({
        success: true,
        message: 'Sales rep budget data imported successfully',
        metadata: metadata,
        existingBudget: existingRecords > 0 ? {
          recordCount: existingRecords,
          lastUpload: lastUpload,
          lastFilename: lastFilename,
          wasReplaced: true
        } : null,
        recordsDeleted: deleteResult.rowCount,
        recordsInserted: {
          kgs: insertedKGS,
          amount: insertedAmount,
          morm: insertedMoRM,
          total: insertedKGS + insertedAmount + insertedMoRM
        },
        totals: {
          mt: totalMT,
          kgs: totalKGS,
          amount: totalAmount,
          morm: totalMoRM
        },
        pricingYear: pricingYear,
        pricingDataAvailable: Object.keys(pricingMap).length,
        warnings: warnings.length > 0 ? warnings : undefined,
        skippedRecords: recordErrors.length > 0 ? recordErrors.length : undefined,
        errors: recordErrors.length > 0 ? recordErrors : undefined
      });
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('‚ùå Error importing budget HTML:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// DIVISIONAL HTML BUDGET ENDPOINTS
// ============================================================================

/**
 * GET /api/aebf/html-budget-actual-years
 * Get all unique years that have actual sales data for a division (for HTML budget)
 */
router.get('/html-budget-actual-years', async (req, res) => {
  try {
    const { division } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'division is required'
      });
    }
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT DISTINCT year
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = UPPER($1)
        AND UPPER(type) = 'ACTUAL'
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      ORDER BY year DESC
    `;
    
    const result = await divisionPool.query(query, [division]);
    const years = result.rows.map(row => row.year);
    
    res.json({
      success: true,
      years
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching HTML budget actual years:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/divisional-html-budget-data
 * Fetch aggregated actual sales data by product group for divisional budget
 */
router.post('/divisional-html-budget-data', async (req, res) => {
  try {
    const { division, actualYear } = req.body;
    
    if (!division || !actualYear) {
      return res.status(400).json({
        success: false,
        error: 'division and actualYear are required'
      });
    }
    
    const budgetYear = parseInt(actualYear) + 1;
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    // Query actual sales data aggregated by product group (all sales reps, all customers, all countries)
    const actualQuery = `
      SELECT 
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value,
        SUM(CASE WHEN UPPER(values_type) = 'AMOUNT' THEN values ELSE 0 END) as amount_value,
        SUM(CASE WHEN UPPER(values_type) = 'MORM' THEN values ELSE 0 END) as morm_value
      FROM public.${tables.dataExcel}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(productgroup), month
      ORDER BY TRIM(productgroup), month
    `;
    
    const actualResult = await divisionPool.query(actualQuery, [division, actualYear]);
    
    // Query existing budget data from divisional_budget table
    const budgetQuery = `
      SELECT 
        TRIM(product_group) as productgroup,
        month,
        SUM(CASE WHEN UPPER(metric) = 'KGS' THEN value ELSE 0 END) / 1000.0 as mt_value
      FROM public.${tables.divisionalBudget}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND product_group IS NOT NULL
        AND TRIM(product_group) != ''
      GROUP BY TRIM(product_group), month
      ORDER BY TRIM(product_group), month
    `;
    
    const budgetResult = await divisionPool.query(budgetQuery, [division, budgetYear]);
    
    // Query pricing data for Amount and MoRM calculations (from prior year)
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM ${tables.pricingRounding}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    console.log(`üìä Loaded ${pricingResult.rows.length} pricing records for ${division} year ${pricingYear}`);
    
    // Build pricing map
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    // Transform actual data to table structure
    const productGroupMap = {};
    
    actualResult.rows.forEach(row => {
      const productGroup = row.productgroup;
      if (!productGroupMap[productGroup]) {
        productGroupMap[productGroup] = {
          productGroup: productGroup,
          monthlyActual: {},
          monthlyActualAmount: {},
          monthlyActualMorm: {},
        };
      }
      productGroupMap[productGroup].monthlyActual[row.month] = parseFloat(row.mt_value) || 0;
      productGroupMap[productGroup].monthlyActualAmount[row.month] = parseFloat(row.amount_value) || 0;
      productGroupMap[productGroup].monthlyActualMorm[row.month] = parseFloat(row.morm_value) || 0;
    });
    
    // Transform budget data to key-value map
    const budgetDataMap = {};
    budgetResult.rows.forEach(row => {
      const key = `${row.productgroup}|${row.month}`;
      budgetDataMap[key] = (parseFloat(row.mt_value) || 0).toFixed(2);
    });
    
    const data = Object.values(productGroupMap).sort((a, b) => 
      a.productGroup.localeCompare(b.productGroup)
    );
    
    res.json({
      success: true,
      data: data,
      budgetData: budgetDataMap,
      pricingData: pricingMap,
      pricingYear: pricingYear
    });
    
  } catch (error) {
    console.error('Error fetching divisional HTML budget data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/export-divisional-html-budget-form
 * Export divisional budget HTML form (similar to sales rep, but product group only)
 */
router.post('/export-divisional-html-budget-form', async (req, res) => {
  try {
    const { division, actualYear, tableData, budgetData, pricingData, isFinal } = req.body;
    
    if (!division || !actualYear || !Array.isArray(tableData)) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and tableData are required'
      });
    }
    
    const budgetDataMap = budgetData || {};
    
    // Get division-specific pool and table name
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);

    // Query pricing data directly from DB to ensure accuracy
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM ${tables.pricingRounding}
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    const dbPricingMap = {};
    pricingResult.rows.forEach(row => {
      dbPricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    // Use DB pricing map, falling back to frontend data if empty (unlikely)
    const pricingMap = Object.keys(dbPricingMap).length > 0 ? dbPricingMap : (pricingData || {});

    const budgetYear = parseInt(actualYear) + 1;
    
    // Calculate monthly totals
    const monthlyActualTotals = {};
    const monthlyActualAmountTotals = {};
    const monthlyActualMormTotals = {};
    const monthlyBudgetTotals = {};
    const monthlyBudgetAmountTotals = {};
    const monthlyMormTotals = {};
    for (let month = 1; month <= 12; month++) {
      monthlyActualTotals[month] = 0;
      monthlyActualAmountTotals[month] = 0;
      monthlyActualMormTotals[month] = 0;
      monthlyBudgetTotals[month] = 0;
      monthlyBudgetAmountTotals[month] = 0;
      monthlyMormTotals[month] = 0;
    }
    
    // Calculate actual totals (MT, Amount, and MoRM)
    tableData.forEach(row => {
      for (let month = 1; month <= 12; month++) {
        monthlyActualTotals[month] += row.monthlyActual?.[month] || 0;
        monthlyActualAmountTotals[month] += row.monthlyActualAmount?.[month] || 0;
        monthlyActualMormTotals[month] += row.monthlyActualMorm?.[month] || 0;
      }
    });
    
    // Helper to find pricing (case-insensitive)
    const findPricing = (productGroup) => {
      if (!productGroup || !pricingMap) return { sellingPrice: 0, morm: 0 };
      const normalizedKey = productGroup.toLowerCase().trim();
      if (pricingMap[normalizedKey]) {
        return pricingMap[normalizedKey];
      }
      // Try partial match
      for (const key of Object.keys(pricingMap)) {
        if (key.toLowerCase().includes(normalizedKey) || normalizedKey.includes(key.toLowerCase())) {
          return pricingMap[key];
        }
      }
      return { sellingPrice: 0, morm: 0 };
    };
    
    // Calculate budget totals (MT, Amount, MoRM)
    Object.keys(budgetDataMap).forEach(key => {
      let month, productGroup;
      if (key.startsWith('custom_')) {
        const parts = key.split('_');
        month = parseInt(parts[parts.length - 1], 10);
        productGroup = ''; // Custom rows don't have product group for pricing
      } else {
        const parts = key.split('|');
        month = parseInt(parts[parts.length - 1], 10);
        productGroup = parts[0] || '';
      }
      if (month >= 1 && month <= 12) {
        const value = budgetDataMap[key];
        const mtValue = parseFloat((value || '').toString().replace(/,/g, '')) || 0;
        if (!isNaN(mtValue)) {
          monthlyBudgetTotals[month] += mtValue;
          
          // Calculate Amount and MoRM
          const pricing = findPricing(productGroup);
          monthlyBudgetAmountTotals[month] += mtValue * 1000 * (pricing.sellingPrice || 0);
          monthlyMormTotals[month] += mtValue * 1000 * (pricing.morm || 0);
        }
      }
    });
    
    // Calculate year totals for summary
    const actualVolumeYearTotal = Object.values(monthlyActualTotals).reduce((sum, val) => sum + val, 0);
    const actualAmountYearTotal = Object.values(monthlyActualAmountTotals).reduce((sum, val) => sum + val, 0);
    const actualMormYearTotal = Object.values(monthlyActualMormTotals).reduce((sum, val) => sum + val, 0);
    const budgetVolumeYearTotal = Object.values(monthlyBudgetTotals).reduce((sum, val) => sum + val, 0);
    const budgetAmountYearTotal = Object.values(monthlyBudgetAmountTotals).reduce((sum, val) => sum + val, 0);
    const budgetMormYearTotal = Object.values(monthlyMormTotals).reduce((sum, val) => sum + val, 0);
    
    // Format functions for summary
    const formatMT = (val) => (val || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const formatAed = (val) => {
      if (!val || val === 0) return '0';
      if (Math.abs(val) >= 1000000) return (val / 1000000).toFixed(2) + 'M';
      if (Math.abs(val) >= 1000) return (val / 1000).toFixed(1) + 'K';
      return val.toFixed(0);
    };
    const calcVariance = (budget, actual) => {
      if (!actual || actual === 0) return budget > 0 ? 100 : (budget < 0 ? -100 : 0);
      return ((budget - actual) / Math.abs(actual) * 100).toFixed(0);
    };
    
    
    // Generate HTML (similar structure to sales rep, but simplified for product groups only)
    const html = `<!DOCTYPE html>
<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=DIVISIONAL_BUDGET :: DO_NOT_EDIT_THIS_LINE -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Divisional Budget Planning - ${division} - ${actualYear}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; display: flex; flex-direction: column; }
    .header { background: #fff; padding: 20px; margin-bottom: 20px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; }
    .header h1 { margin-bottom: 10px; color: #333; }
    .header-info { display: flex; gap: 30px; flex-wrap: wrap; }
    .header-info div { font-size: 14px; color: #666; }
    .header-info strong { color: #333; }
    .table-container {
      background: #fff;
      padding: 0;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
      flex: 1;
      min-height: 0;
      height: calc(100vh - 200px);
      overflow-x: auto;
      overflow-y: auto;
    }
    table { 
      width: 100%; 
      border-collapse: separate; 
      border-spacing: 0; 
      font-size: 12px; 
      table-layout: fixed; 
    }
    thead th.legend-header {
      position: -webkit-sticky !important;
      position: sticky !important;
      top: 0 !important;
      z-index: 1002 !important;
      background: #fff !important;
      padding: 12px 24px !important;
      border-bottom: 1px solid #e8e8e8 !important;
      text-align: left !important;
    }
    thead tr.header-row {
      position: -webkit-sticky;
      position: sticky;
      top: 49px;
      z-index: 1001;
      background: #fff;
    }
    thead th.column-header {
      background-color: #1677ff;
      color: #fff;
      padding: 8px;
      border: 1px solid #fff;
      text-align: center;
      min-width: 0;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    thead th.column-header.sticky-col {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 1003;
      background-color: #1677ff;
    }
    tbody td { 
      padding: 8px; 
      border: 1px solid #ddd; 
    }
    tbody td:last-child {
      text-align: center;
    }
    tbody td:nth-child(1) {
      background-color: #fff;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 5;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.actual-row { background-color: #e6f4ff; }
    tbody tr.actual-row td:nth-child(n+2) { 
      background-color: #e6f4ff; 
      text-align: right; 
      font-weight: 500; 
      padding: 6px 8px; 
    }
    tbody tr.budget-row { background-color: #FFFFB8; }
    tbody tr.budget-row td { 
      background-color: #FFFFB8 !important; 
      padding: 2px;
      text-align: right;
      font-weight: 500;
      font-size: 12px;
    }
    tbody input { 
      width: 100%; 
      border: none; 
      padding: 4px 6px; 
      text-align: right; 
      font-size: 12px; 
      font-weight: 500; 
      background-color: transparent !important; 
      box-shadow: none; 
    }
    tbody input:focus { outline: none; }
    tbody input:disabled { background-color: #f5f5f5 !important; cursor: not-allowed; }
    tbody select { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
    tbody .delete-btn { 
      background: #ff4d4f; 
      color: #fff; 
      border: none; 
      padding: 2px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 12px; 
      margin-left: 4px; 
    }
    tfoot tr.actual-total {
      background-color: #cce4ff;
    }
    tfoot tr.actual-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #cce4ff;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #cce4ff;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-total td:last-child {
      background-color: #b3d9ff;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total {
      background-color: #d4edda;
    }
    tfoot tr.actual-amount-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #d4edda;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #d4edda;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-amount-total td:last-child {
      background-color: #c3e6cb;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total {
      background-color: #ffe0b2;
    }
    tfoot tr.actual-morm-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #ffe0b2;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #ffe0b2;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.actual-morm-total td:last-child {
      background-color: #ffb74d;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-total {
      background-color: #FFFFB8;
    }
    tfoot tr.budget-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #FFFFB8;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFFFB8;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-total td:last-child {
      background-color: #FFEB3B;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total {
      background-color: #c8e6c9;
    }
    tfoot tr.budget-amount-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #c8e6c9;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #c8e6c9;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-amount-total td:last-child {
      background-color: #81c784;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total {
      background-color: #ffe0b2;
    }
    tfoot tr.budget-morm-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #ffe0b2;
      text-align: right;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #ffe0b2;
      font-weight: 700;
      font-size: 12px;
    }
    tfoot tr.budget-morm-total td:last-child {
      background-color: #ffb74d;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
    }
    .btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .btn:hover { background: #4096ff; }
    .summary-container { background: #f8f9fa; padding: 12px 16px; margin-bottom: 12px; border-radius: 4px; }
    .summary-title { font-size: 13px; font-weight: 600; color: #1890ff; margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
    .summary-cards { display: flex; gap: 16px; flex-wrap: wrap; }
    .summary-card { flex: 1; min-width: 280px; background: #fff; border-radius: 6px; padding: 12px 16px; border: 1px solid #e8e8e8; }
    .summary-card-title { font-size: 12px; font-weight: 600; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
    .summary-card-values { display: flex; align-items: baseline; gap: 24px; }
    .summary-label { font-size: 11px; color: #999; }
    .summary-value { font-size: 16px; font-weight: 600; }
    .summary-value.actual { color: #1890ff; }
    .summary-value.budget { color: #d4b106; }
    .summary-variance { margin-left: auto; font-size: 14px; font-weight: 700; }
    .summary-variance.positive { color: #52c41a; }
    .summary-variance.negative { color: #ff4d4f; }
  </style>
</head>
<body>
  <!-- Budget vs Actual Summary -->
  <div class="summary-container">
    <div class="summary-title">üìä Budget vs Actual Summary</div>
    <div class="summary-cards">
      <!-- Volume Card -->
      <div class="summary-card">
        <div class="summary-card-title">üì¶ Volume (MT)</div>
        <div class="summary-card-values">
          <div><span class="summary-label">Act: </span><span class="summary-value actual">${formatMT(actualVolumeYearTotal)}</span></div>
          <div><span class="summary-label">Bud: </span><span id="summaryBudgetVolume" class="summary-value budget">${formatMT(budgetVolumeYearTotal)}</span></div>
          <span id="summaryVolumeVariance" class="summary-variance ${(budgetVolumeYearTotal - actualVolumeYearTotal) >= 0 ? 'positive' : 'negative'}">${calcVariance(budgetVolumeYearTotal, actualVolumeYearTotal)}%</span>
        </div>
      </div>
      <!-- Amount Card -->
      <div class="summary-card">
        <div class="summary-card-title"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="14" height="14"><path d="M788.6 609.9c0 53.5-16.7 102.4-50.2 146.8L620.9 609.9h166.1c0.9 0 1.6-0.7 1.6-1.6V406.8c0-0.9-0.7-1.6-1.6-1.6h-287l179.3 213.5c29-12.5 51.7-30.7 68.1-54.7 21.5-31.3 32.3-68.9 32.3-112.8h-78.5c0 29-7.3 53.7-21.8 73.9-14.5 20.3-35.9 35.5-64.1 45.7V358.7c67.1-17.6 114.1-45.7 140.8-84.3 26.8-38.6 40.1-83.3 40.1-134.1 0-52.6-17.9-96.9-53.7-132.9-35.8-36-81.9-55.9-138.3-59.6V0h-57.5v48.3c-103.1 7.3-179.3 50.4-228.4 129.5l66.5 40.1c39.4-61.4 95.5-93.9 168.5-97.5v199.9c-75.9 18.3-129.5 48.2-160.9 89.7-31.4 41.5-47.1 90.7-47.1 147.5 0 57.7 18.7 105.7 56.2 144 37.4 38.3 86.4 59 147 62.1v107h57.5v-105c25.9-1.8 50-7 72.3-15.5l207.2 247.9H893L720.7 794.2c63.6-44.6 113.9-128.7 121.2-178.9l-53.3-5.4zM484.7 177.9c38.6-49 92.3-75.7 161-80v193.6c-41.1-10.9-73.5-29.3-97.3-55.2-23.8-25.8-43.7-43.4-63.7-58.4z m161 475.8V472.2c31.7 6.8 56.6 19.6 74.7 38.3 18.1 18.7 27.2 42.5 27.2 71.2 0 27.9-8.7 51.4-26.2 70.5-17.4 19.2-43.3 27.3-75.7 1.5z m-57.5-2.9c-37.4-7.3-66.5-22.5-87.3-45.7-20.8-23.2-31.2-51.2-31.2-84.2 0-36.6 10.5-66.5 31.6-89.7 21.1-23.1 50.1-38.8 86.9-47.1v266.7z" fill="#666"/></svg> Amount</div>
        <div class="summary-card-values">
          <div><span class="summary-label">Act: </span><span class="summary-value actual">${formatAed(actualAmountYearTotal)}</span></div>
          <div><span class="summary-label">Bud: </span><span id="summaryBudgetAmount" class="summary-value budget">${formatAed(budgetAmountYearTotal)}</span></div>
          <span id="summaryAmountVariance" class="summary-variance ${(budgetAmountYearTotal - actualAmountYearTotal) >= 0 ? 'positive' : 'negative'}">${calcVariance(budgetAmountYearTotal, actualAmountYearTotal)}%</span>
        </div>
      </div>
      <!-- MoRM Card -->
      <div class="summary-card">
        <div class="summary-card-title">üìà MoRM</div>
        <div class="summary-card-values">
          <div><span class="summary-label">Act: </span><span class="summary-value actual">${formatAed(actualMormYearTotal)}</span></div>
          <div><span class="summary-label">Bud: </span><span id="summaryBudgetMorm" class="summary-value budget">${formatAed(budgetMormYearTotal)}</span></div>
          <span id="summaryMormVariance" class="summary-variance ${(budgetMormYearTotal - actualMormYearTotal) >= 0 ? 'positive' : 'negative'}">${calcVariance(budgetMormYearTotal, actualMormYearTotal)}%</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="table-container">
    <table>
      <colgroup>
        <col style="width: 20%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 5.7%;" />
        <col style="width: 8%;" />
      </colgroup>
      <thead>
        <tr>
          <th colspan="14" class="legend-header">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; gap: 24px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="display: inline-block; width: 16px; height: 16px; background-color: #e6f4ff; border: 1px solid #99c8ff;"></span>
                  <span>Actual ${actualYear} Volume (MT)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="display: inline-block; width: 16px; height: 16px; background-color: #FFFFB8; border: 1px solid #d4b106;"></span>
                  <span>Budget ${budgetYear} Volume (MT)</span>
                </div>
              </div>
              ${!isFinal ? `
              <div style="display: flex; gap: 8px;">
                <button class="btn" id="saveDraftBtn" style="background: #1677ff;">üíæ Save Draft</button>
                <button class="btn" id="saveFinalBtn" style="background: #52c41a;">‚úì Save Final</button>
              </div>
              ` : ''}
            </div>
          </th>
        </tr>
        <tr class="header-row">
          <th rowspan="2" class="column-header sticky-col">Product Group</th>
          ${Array.from({ length: 12 }, (_, i) => `<th class="column-header">${i + 1}</th>`).join('')}
          <th class="column-header">Year Total</th>
        </tr>
      </thead>
      <tbody id="tableBody">
        ${tableData.map((row, idx) => {
          const actualCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const value = row.monthlyActual?.[month] || 0;
            const formatted = value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('');
          
          // Calculate year total for actual
          const actualYearTotal = Array.from({ length: 12 }, (_, i) => row.monthlyActual?.[i + 1] || 0).reduce((sum, val) => sum + val, 0);
          
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const key = row.productGroup + '|' + month;
            const preFilledValue = budgetDataMap[key] || '';
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              (isFinal ? 'disabled ' : '') +
              '/>' +
            '</td>';
          }).join('');
          
          // Calculate year total for budget
          const budgetYearTotalVal = Array.from({ length: 12 }, (_, i) => {
            const key = row.productGroup + '|' + (i + 1);
            return parseFloat((budgetDataMap[key] || '').toString().replace(/,/g, '')) || 0;
          }).reduce((sum, val) => sum + val, 0);
          
          return `<tr class="actual-row">
            <td rowspan="2">${row.productGroup}</td>
            ${actualCells}
            <td style="background-color: #b3d9ff; text-align: center; font-weight: 700;">${actualYearTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          </tr>
          <tr class="budget-row">
            ${budgetCells}
            <td class="product-budget-total" data-group="${row.productGroup.replace(/"/g, '&quot;')}" style="background-color: #FFEB3B; text-align: center; font-weight: 700;">${budgetYearTotalVal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          </tr>`;
        }).join('')}
      </tbody>
      <!-- Dirham SVG symbol -->
      <svg id="aedSymbol" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" style="display:none"><text x="0" y="15" font-size="16">ÿØ.ÿ•</text></svg>
      <tfoot>
        <tr class="actual-total">
          <td>Total Actual Volume (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('')}
          <td>${Object.values(monthlyActualTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="actual-amount-total">
          <td>Total Actual Amount <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td>${(() => {
            const total = Object.values(monthlyActualAmountTotals).reduce((sum, val) => sum + val, 0);
            return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                   total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                   total.toFixed(0);
          })()}</td>
        </tr>
        <tr class="actual-morm-total">
          <td>Total Actual MoRM <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualMormTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td>${(() => {
            const total = Object.values(monthlyActualMormTotals).reduce((sum, val) => sum + val, 0);
            return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                   total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                   total.toFixed(0);
          })()}</td>
        </tr>
        <tr class="budget-total">
          <td>Total Budget Volume (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('')}
          <td id="budgetYearTotal">${Object.values(monthlyBudgetTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="budget-amount-total">
          <td>Total Budget Amount <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td id="budgetAmountYearTotal">${(() => {
            const total = Object.values(monthlyBudgetAmountTotals).reduce((sum, val) => sum + val, 0);
            return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                   total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                   total.toFixed(0);
          })()}</td>
        </tr>
        <tr class="budget-morm-total">
          <td>Total Budget MoRM <svg class="uae-dirham-symbol" viewBox="0 0 344.84 299.91" xmlns="http://www.w3.org/2000/svg" fill="currentColor" style="display: inline-block; vertical-align: -0.1em; width: 1em; height: 1em; margin-right: 0.2em;"><path d="M342.14,140.96l2.7,2.54v-7.72c0-17-11.92-30.84-26.56-30.84h-23.41C278.49,36.7,222.69,0,139.68,0c-52.86,0-59.65,0-109.71,0,0,0,15.03,12.63,15.03,52.4v52.58h-27.68c-5.38,0-10.43-2.08-14.61-6.01l-2.7-2.54v7.72c0,17.01,11.92,30.84,26.56,30.84h18.44s0,29.99,0,29.99h-27.68c-5.38,0-10.43-2.07-14.61-6.01l-2.7-2.54v7.71c0,17,11.92,30.82,26.56,30.82h18.44s0,54.89,0,54.89c0,38.65-15.03,50.06-15.03,50.06h109.71c85.62,0,139.64-36.96,155.38-104.98h32.46c5.38,0,10.43,2.07,14.61,6l2.7,2.54v-7.71c0-17-11.92-30.83-26.56-30.83h-18.9c.32-4.88.49-9.87.49-15s-.18-10.11-.51-14.99h28.17c5.37,0,10.43,2.07,14.61,6.01ZM89.96,15.01h45.86c61.7,0,97.44,27.33,108.1,89.94l-153.96.02V15.01ZM136.21,284.93h-46.26v-89.98l153.87-.02c-9.97,56.66-42.07,88.38-107.61,90ZM247.34,149.96c0,5.13-.11,10.13-.34,14.99l-157.04.02v-29.99l157.05-.02c.22,4.84.33,9.83.33,15Z"/></svg></td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyMormTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td id="budgetMormYearTotal">${(() => {
            const total = Object.values(monthlyMormTotals).reduce((sum, val) => sum + val, 0);
            return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                   total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                   total.toFixed(0);
          })()}</td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script>
    // Insert Dirham SVG into all .aed-svg spans
    document.addEventListener('DOMContentLoaded', function() {
      const svg = document.getElementById('aedSymbol');
      if (svg) {
        const svgHtml = svg.outerHTML;
        document.querySelectorAll('.aed-svg').forEach(span => {
          span.innerHTML = svgHtml;
        });
      }
    });
    const formData = {
      division: '${division}',
      actualYear: ${actualYear},
      budgetYear: ${budgetYear},
    };
    
    // Pricing data for Amount and MoRM calculations
    const pricingMap = ${JSON.stringify(pricingMap)};
    
    // Helper to find pricing (case-insensitive)
    function findPricing(productGroup) {
      if (!productGroup || !pricingMap) return { sellingPrice: 0, morm: 0 };
      const normalizedKey = productGroup.toLowerCase().trim();
      if (pricingMap[normalizedKey]) {
        return pricingMap[normalizedKey];
      }
      // Try partial match
      for (const key of Object.keys(pricingMap)) {
        if (key.toLowerCase().includes(normalizedKey) || normalizedKey.includes(key.toLowerCase())) {
          return pricingMap[key];
        }
      }
      return { sellingPrice: 0, morm: 0 };
    }
    
    function cloneWorkingDocument() {
      const htmlClone = document.documentElement.cloneNode(true);
      const liveInputs = document.querySelectorAll('input');
      const clonedInputs = htmlClone.querySelectorAll('input');
      clonedInputs.forEach((input, idx) => {
        if (liveInputs[idx]) {
          input.setAttribute('value', liveInputs[idx].value || '');
        }
      });
      
      const tempDoc = document.implementation.createHTMLDocument(document.title || 'Divisional Budget');
      const importedHtml = tempDoc.importNode(htmlClone, true);
      tempDoc.replaceChild(importedHtml, tempDoc.documentElement);
      return tempDoc;
    }
    
    function formatMT(value) {
      if (!value && value !== 0) return '';
      const num = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value;
      if (isNaN(num)) return '';
      return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    function formatAed(value) {
      if (!value || value === 0) return '0';
      if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
      if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
      return value.toFixed(0);
    }
    
    function recalculateTotals() {
      // Monthly totals arrays
      const budgetTotals = Array.from({ length: 12 }, () => 0);
      const budgetAmountTotals = Array.from({ length: 12 }, () => 0);
      const mormTotals = Array.from({ length: 12 }, () => 0);
      // Track totals per product group for row year totals
      const productGroupTotals = {};
      // Track all input values for each product group
      const groupMonthVals = {};
      document.querySelectorAll('input:not([disabled])').forEach(input => {
        const month = parseInt(input.dataset.month);
        const productGroup = input.dataset.group;
        const val = parseFloat(input.value.replace(/,/g, '')) || 0;
        if (!groupMonthVals[productGroup]) groupMonthVals[productGroup] = Array(12).fill(0);
        if (month >= 1 && month <= 12 && !isNaN(val)) {
          budgetTotals[month - 1] += val;
          // Calculate Amount and MoRM (MT * 1000 * price)
          const pricing = findPricing(productGroup);
          budgetAmountTotals[month - 1] += val * 1000 * (pricing.sellingPrice || 0);
          mormTotals[month - 1] += val * 1000 * (pricing.morm || 0);
          // Track product group totals
          productGroupTotals[productGroup] = (productGroupTotals[productGroup] || 0) + val;
          groupMonthVals[productGroup][month - 1] = val;
        }
      });
      // Update Budget MT monthly cells (excluding year total - last cell)
      const budgetTotalRow = document.querySelector('tfoot tr.budget-total');
      if (budgetTotalRow) {
        const cells = budgetTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          cell.textContent = formatMT(budgetTotals[idx]);
        });
      }
      // Update Budget MT year total
      const budgetYearTotal = budgetTotals.reduce((sum, val) => sum + val, 0);
      const budgetYearTotalCell = document.getElementById('budgetYearTotal');
      if (budgetYearTotalCell) {
        budgetYearTotalCell.textContent = formatMT(budgetYearTotal);
      }
      // Update Budget Amount monthly cells
      const budgetAmountTotalRow = document.querySelector('tfoot tr.budget-amount-total');
      if (budgetAmountTotalRow) {
        const cells = budgetAmountTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          cell.textContent = formatAed(budgetAmountTotals[idx]);
        });
      }
      // Update Budget Amount year total
      const budgetAmountYearTotal = budgetAmountTotals.reduce((sum, val) => sum + val, 0);
      const budgetAmountYearTotalCell = document.getElementById('budgetAmountYearTotal');
      if (budgetAmountYearTotalCell) {
        budgetAmountYearTotalCell.textContent = formatAed(budgetAmountYearTotal);
      }
      // Update MoRM monthly cells
      const mormTotalRow = document.querySelector('tfoot tr.budget-morm-total');
      if (mormTotalRow) {
        const cells = mormTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          cell.textContent = formatAed(mormTotals[idx]);
        });
      }
      // Update MoRM year total
      const mormYearTotal = mormTotals.reduce((sum, val) => sum + val, 0);
      const mormYearTotalCell = document.getElementById('budgetMormYearTotal');
      if (mormYearTotalCell) {
        mormYearTotalCell.textContent = formatAed(mormYearTotal);
      }
      // Update product group row year totals (including custom rows)
      document.querySelectorAll('.product-budget-total').forEach(cell => {
        const productGroup = cell.dataset.group;
        // Sum all 12 months for this group
        const vals = groupMonthVals[productGroup] || [];
        const total = vals.reduce((sum, v) => sum + (parseFloat(v) || 0), 0);
        cell.textContent = formatMT(total);
      });
      
      // Update Summary Cards
      const actualVolumeTotal = ${actualVolumeYearTotal};
      const actualAmountTotal = ${actualAmountYearTotal};
      const actualMormTotal = ${actualMormYearTotal};
      
      // Update Budget Volume in summary
      const summaryBudgetVolume = document.getElementById('summaryBudgetVolume');
      if (summaryBudgetVolume) {
        summaryBudgetVolume.textContent = formatMT(budgetYearTotal);
      }
      
      // Update Volume Variance
      const summaryVolumeVariance = document.getElementById('summaryVolumeVariance');
      if (summaryVolumeVariance) {
        const variance = actualVolumeTotal ? ((budgetYearTotal - actualVolumeTotal) / Math.abs(actualVolumeTotal) * 100).toFixed(0) : (budgetYearTotal > 0 ? 100 : 0);
        summaryVolumeVariance.textContent = variance + '%';
        summaryVolumeVariance.className = 'summary-variance ' + ((budgetYearTotal - actualVolumeTotal) >= 0 ? 'positive' : 'negative');
      }
      
      // Update Budget Amount in summary
      const summaryBudgetAmount = document.getElementById('summaryBudgetAmount');
      if (summaryBudgetAmount) {
        summaryBudgetAmount.textContent = formatAed(budgetAmountYearTotal);
      }
      
      // Update Amount Variance
      const summaryAmountVariance = document.getElementById('summaryAmountVariance');
      if (summaryAmountVariance) {
        const variance = actualAmountTotal ? ((budgetAmountYearTotal - actualAmountTotal) / Math.abs(actualAmountTotal) * 100).toFixed(0) : (budgetAmountYearTotal > 0 ? 100 : 0);
        summaryAmountVariance.textContent = variance + '%';
        summaryAmountVariance.className = 'summary-variance ' + ((budgetAmountYearTotal - actualAmountTotal) >= 0 ? 'positive' : 'negative');
      }
      
      // Update Budget MoRM in summary
      const summaryBudgetMorm = document.getElementById('summaryBudgetMorm');
      if (summaryBudgetMorm) {
        summaryBudgetMorm.textContent = formatAed(mormYearTotal);
      }
      
      // Update MoRM Variance
      const summaryMormVariance = document.getElementById('summaryMormVariance');
      if (summaryMormVariance) {
        const variance = actualMormTotal ? ((mormYearTotal - actualMormTotal) / Math.abs(actualMormTotal) * 100).toFixed(0) : (mormYearTotal > 0 ? 100 : 0);
        summaryMormVariance.textContent = variance + '%';
        summaryMormVariance.className = 'summary-variance ' + ((mormYearTotal - actualMormTotal) >= 0 ? 'positive' : 'negative');
      }
    }
    
    ${!isFinal ? `
    document.querySelectorAll('input').forEach(input => {
      input.addEventListener('blur', function() {
        const val = this.value;
        if (val) {
          this.value = formatMT(val);
        }
        recalculateTotals();
      });
      
      input.addEventListener('input', function() {
        this.value = this.value.replace(/[^0-9.,]/g, '');
        recalculateTotals();
      });
    });
    
    // Save Draft Button - keeps form editable
    document.getElementById('saveDraftBtn').addEventListener('click', function() {
      recalculateTotals();
      
      const clonedDoc = cloneWorkingDocument();
      
      // Ensure inputs are enabled in draft
      clonedDoc.querySelectorAll('input').forEach(input => {
        input.removeAttribute('disabled');
      });
      
      const draftMetadata = {
        isDraft: true,
        division: formData.division,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'divisional_budget_draft'
      };
      
      // Remove existing draft metadata script if it exists
      const existingDraftScript = clonedDoc.getElementById('draftMetadata');
      if (existingDraftScript) {
        existingDraftScript.remove();
      }
      
      const draftScript = clonedDoc.createElement('script');
      draftScript.id = 'draftMetadata';
      draftScript.textContent = '/* DRAFT METADATA */\\n' +
        'var draftMetadata = ' + JSON.stringify(draftMetadata, null, 2) + ';';
      clonedDoc.body.appendChild(draftScript);
      
      // Add IPD signature
      const htmlContent = '<!DOCTYPE html>\\n<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=DIVISIONAL_BUDGET :: DO_NOT_EDIT_THIS_LINE -->\\n' + clonedDoc.documentElement.outerHTML;
      
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      const filename = 'DRAFT_Divisional_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('‚úÖ Draft saved!\\n\\nYou can open this file later to continue editing.\\n\\nFilename: ' + filename + '\\n\\nüí° This is a DRAFT file - it cannot be uploaded to the system.\\nUse "Save Final" when ready to submit.');
    });
    
    // Save Final Button
    document.getElementById('saveFinalBtn').addEventListener('click', function() {
      const budgetInputs = document.querySelectorAll('input:not([disabled])[data-month]');
      const hasData = Array.from(budgetInputs).some(input => {
        const val = input.value.replace(/,/g, '');
        return val && parseFloat(val) > 0;
      });
      
      if (!hasData) {
        alert('‚ö†Ô∏è No budget data entered!\\n\\nPlease enter at least one budget value before saving final version.');
        return;
      }
      
      if (!confirm('üìã Finalize Divisional Budget?\\n\\nThis will create a final version that:\\n‚Ä¢ Cannot be edited\\n‚Ä¢ Can be uploaded to the system\\n‚Ä¢ Will calculate Amount and MoRM values\\n\\nDo you want to proceed?')) {
        return;
      }
      
      recalculateTotals();
      
      const clonedDoc = cloneWorkingDocument();
      
      clonedDoc.querySelectorAll('input[data-month]').forEach(input => {
        const value = input.value || '0';
        const td = input.parentElement;
        td.innerHTML = value;
        td.style.textAlign = 'right';
        td.style.fontWeight = '500';
        td.style.padding = '6px 8px';
      });
      
      clonedDoc.querySelectorAll('.delete-btn').forEach(btn => btn.remove());
      clonedDoc.querySelectorAll('select').forEach(select => {
        const value = select.options[select.selectedIndex]?.text || '';
        select.outerHTML = '<span>' + value + '</span>';
      });
      
      const addBtn = clonedDoc.getElementById('addRowBtn');
      if (addBtn) addBtn.remove();
      const saveDraftBtn = clonedDoc.getElementById('saveDraftBtn');
      if (saveDraftBtn) saveDraftBtn.remove();
      const saveFinalBtn = clonedDoc.getElementById('saveFinalBtn');
      if (saveFinalBtn) saveFinalBtn.remove();
      
      clonedDoc.querySelectorAll('script').forEach(script => {
        if (!script.id || script.id !== 'savedBudgetData') {
          script.remove();
        }
      });
      
      const budgetData = [];
      document.querySelectorAll('input:not([disabled])[data-month]').forEach(input => {
        const val = input.value.replace(/,/g, '');
        if (val && parseFloat(val) > 0) {
          budgetData.push({
            productGroup: input.dataset.group,
            month: parseInt(input.dataset.month),
            value: parseFloat(val) * 1000
          });
        }
      });
      
      const metadata = {
        division: formData.division,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'divisional_budget_import'
      };
      
      const savedDataScript = clonedDoc.createElement('script');
      savedDataScript.id = 'savedBudgetData';
      savedDataScript.textContent = 
        '/* DIVISIONAL BUDGET DATA FOR DATABASE IMPORT */\\n' +
        'const budgetMetadata = ' + JSON.stringify(metadata, null, 2) + ';\\n' +
        'const savedBudget = ' + JSON.stringify(budgetData, null, 2) + ';';
      clonedDoc.body.appendChild(savedDataScript);
      
      // Add IPD signature
      const htmlContent = '<!DOCTYPE html>\\n<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=DIVISIONAL_BUDGET :: DO_NOT_EDIT_THIS_LINE -->\\n' + clonedDoc.documentElement.outerHTML;
      
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      const filename = 'FINAL_Divisional_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('‚úÖ Final divisional budget saved!\\n\\nFilename: ' + filename + '\\n\\nThis file is ready for upload to the system.');
    });
    ` : ''}
    
    recalculateTotals();
  </script>
</body>
</html>`;
    
    // Generate timestamp for filename
    const now = new Date();
    const dateStr = now.getFullYear().toString() + 
      String(now.getMonth() + 1).padStart(2, '0') + 
      String(now.getDate()).padStart(2, '0');
    const timeStr = String(now.getHours()).padStart(2, '0') + 
      String(now.getMinutes()).padStart(2, '0') + 
      String(now.getSeconds()).padStart(2, '0');
    const timestamp = dateStr + '_' + timeStr;
    
    // Initial export is a DRAFT - user must Save Final to create uploadable version  
    const filename = `DRAFT_Divisional_${division}_${budgetYear}_${timestamp}.html`;
    
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(html);
    
  } catch (error) {
    console.error('‚ùå Error exporting divisional HTML budget form:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/import-divisional-budget-html
 * Import filled divisional budget HTML file to fp_divisional_budget table
 */
router.post('/import-divisional-budget-html', async (req, res) => {
  console.log('üì• Import divisional budget HTML request received');
  try {
    const htmlContent = req.body.htmlContent;
    const confirmReplace = req.body.confirmReplace === true;
    
    if (!htmlContent) {
      return res.status(400).json({
        success: false,
        error: 'No HTML content provided'
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 0: File Signature Check
    // ============================================================================
    
    const signaturePattern = /<!--\s*IPD_BUDGET_SYSTEM_v[\d.]+\s*::\s*TYPE=(SALES_REP_BUDGET|DIVISIONAL_BUDGET)\s*::/;
    const signatureMatch = htmlContent.match(signaturePattern);
    
    if (!signatureMatch) {
      console.warn('‚ö†Ô∏è File missing IPD Budget System signature - may be legacy or modified file');
    } else if (signatureMatch[1] !== 'DIVISIONAL_BUDGET') {
      console.error('‚ùå Wrong file type: expected DIVISIONAL_BUDGET, got', signatureMatch[1]);
      return res.status(400).json({
        success: false,
        error: 'Wrong file type. This appears to be a Sales Rep Budget file. Please use the Sales Rep Budget import instead.'
      });
    } else {
      console.log('‚úÖ Valid IPD Budget System signature detected');
    }
    
    // Extract metadata and budget data
    let metadata = null;
    let budgetData = null;
    
    try {
      const scriptTagMatch = htmlContent.match(/<script[^>]*id=["']savedBudgetData["'][^>]*>([\s\S]*?)<\/script>/i);
      if (scriptTagMatch && scriptTagMatch[1]) {
        const scriptContent = scriptTagMatch[1];
        // Improved JSON extraction - handle multi-line JSON properly
        const metaMatch = scriptContent.match(/const\s+budgetMetadata\s*=\s*(\{[\s\S]*?\});/);
        const dataMatch = scriptContent.match(/const\s+savedBudget\s*=\s*(\[[\s\S]*?\]);/);
        
        if (metaMatch && dataMatch) {
          metadata = JSON.parse(metaMatch[1]);
          budgetData = JSON.parse(dataMatch[1]);
        }
      }
      
      if (!metadata || !budgetData) {
        // Fallback for legacy files
        const metadataMatch = htmlContent.match(/const budgetMetadata = (\{[\s\S]*?\});/);
        const budgetDataMatch = htmlContent.match(/const savedBudget = (\[[\s\S]*?\]);/);
        if (metadataMatch && budgetDataMatch) {
          metadata = JSON.parse(metadataMatch[1]);
          budgetData = JSON.parse(budgetDataMatch[1]);
        }
      }
      
      if (!metadata || !budgetData) {
        return res.status(400).json({
          success: false,
          error: 'Invalid HTML file format. Missing budget metadata or saved budget data. Please re-export using the in-app "Save Final" button.'
        });
      }
      
      console.log('‚úÖ Parsed metadata and budget data from HTML export');
      console.log('‚úÖ Metadata:', { division: metadata.division, budgetYear: metadata.budgetYear });
      console.log('‚úÖ Budget records count:', Array.isArray(budgetData) ? budgetData.length : 0);
      
    } catch (e) {
      console.error('‚ùå Error extracting data from HTML:', e);
      return res.status(400).json({
        success: false,
        error: 'Failed to parse budget data from file. Ensure the file was exported from the application using "Save Final".'
      });
    }
    
    // Generate file hash for tracking
    const crypto = require('crypto');
    const fileHash = crypto.createHash('sha256').update(htmlContent).digest('hex').substring(0, 16);
    console.log('üìã File hash:', fileHash);
    
    // ============================================================================
    // VALIDATION STEP 1: Check for Draft File
    // ============================================================================
    
    const draftCheck = htmlContent.match(/const draftMetadata = (\{[\s\S]*?\});/);
    if (draftCheck) {
      try {
        const draftMeta = JSON.parse(draftCheck[1]);
        if (draftMeta.isDraft === true) {
          console.warn('‚ö†Ô∏è Draft file rejected');
          return res.status(400).json({
            success: false,
            error: '‚ö†Ô∏è Cannot upload draft file!\n\nThis is a work-in-progress draft. Please open the file, complete your budget, and click "Save Final" before uploading.',
            isDraft: true
          });
        }
      } catch (e) {
        console.log('Draft check parse error (ignored):', e.message);
      }
    }
    
    // ============================================================================
    // VALIDATION STEP 2: Validate Data Format and Version
    // ============================================================================
    
    const validationErrors = [];
    
    if (!metadata.dataFormat || metadata.dataFormat !== 'divisional_budget_import') {
      validationErrors.push('Invalid data format. This file is not a divisional budget export.');
    }
    
    if (!metadata.version || metadata.version !== '1.0') {
      validationErrors.push('Unsupported file version. Please re-export from the system.');
    }
    
    if (!metadata.division || typeof metadata.division !== 'string') {
      validationErrors.push('Invalid or missing division');
    }
    
    if (!metadata.budgetYear || typeof metadata.budgetYear !== 'number' || metadata.budgetYear < 2020 || metadata.budgetYear > 2100) {
      validationErrors.push('Invalid or missing budget year (must be between 2020-2100)');
    }
    
    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'File validation failed:\n' + validationErrors.join('\n')
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 3: Validate Budget Data Structure
    // ============================================================================
    
    if (!Array.isArray(budgetData)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid budget data format. Expected an array of records.'
      });
    }
    
    if (budgetData.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No budget data found in file. The file appears to be empty.'
      });
    }
    
    if (budgetData.length > 10000) {
      return res.status(400).json({
        success: false,
        error: `Too many records (${budgetData.length}). Maximum allowed is 10,000.`
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 4: Validate Individual Records
    // ============================================================================
    
    const recordErrors = [];
    const validRecords = [];
    
    budgetData.forEach((record, index) => {
      const errors = [];
      
      if (!record.productGroup || typeof record.productGroup !== 'string' || record.productGroup.trim() === '') {
        errors.push('Missing or invalid product group');
      }
      
      if (!record.month || typeof record.month !== 'number' || record.month < 1 || record.month > 12) {
        errors.push('Invalid month (must be 1-12)');
      }
      
      if (record.value === undefined || record.value === null) {
        errors.push('Missing value');
      } else if (typeof record.value !== 'number' || isNaN(record.value)) {
        errors.push('Invalid value (must be a number)');
      } else if (record.value < 0) {
        errors.push('Negative values not allowed');
      } else if (record.value === 0) {
        errors.push('Zero values not allowed');
      } else if (record.value > 1000000000) {
        errors.push('Value too large (max 1 billion KGS)');
      }
      
      if (errors.length > 0) {
        recordErrors.push({
          index: index + 1,
          productGroup: record.productGroup || 'Unknown',
          month: record.month || 'Unknown',
          errors: errors
        });
      } else {
        validRecords.push(record);
      }
    });
    
    // If more than 10% of records have errors, reject the file
    const errorRate = recordErrors.length / budgetData.length;
    if (errorRate > 0.1) {
      return res.status(400).json({
        success: false,
        error: `Too many invalid records (${recordErrors.length} out of ${budgetData.length}). Please check your file and try again.`,
        recordErrors: recordErrors.slice(0, 10),
        totalErrors: recordErrors.length
      });
    }
    
    // If some records have errors, log them but continue with valid records
    if (recordErrors.length > 0) {
      console.warn(`‚ö†Ô∏è Skipping ${recordErrors.length} invalid records out of ${budgetData.length}`);
    }
    
    // Use only valid records if we filtered some out
    const recordsToImport = validRecords.length > 0 ? validRecords : budgetData;
    
    console.log(`‚úÖ Validation passed: ${recordsToImport.length} valid records`);
    
    // Start transaction using division-specific pool
    const divisionPool = getPoolForDivision(metadata.division);
    const client = await divisionPool.connect();
    try {
      const existingBudget = await getDivisionalBudgetInfo(client, metadata.division, metadata.budgetYear);

      if (!confirmReplace && existingBudget.recordCount > 0) {
        // Do not release here, let the finally block handle it
        return res.json({
          success: false,
          needsConfirmation: true,
          existingBudget,
          metadata
        });
      }

      await client.query('BEGIN');
      const result = await saveDivisionalBudget(client, {
        division: metadata.division,
        budgetYear: metadata.budgetYear,
        records: recordsToImport,
        savedAt: metadata.savedAt,
        filenamePrefix: 'BUDGET_Divisional'
      });
      await client.query('COMMIT');
      
      console.log(`‚úÖ Successfully imported divisional budget:`);
      console.log(`   - KGS records: ${result.recordsInserted?.kgs || 0}`);
      console.log(`   - Amount records: ${result.recordsInserted?.amount || 0}`);
      console.log(`   - MoRM records: ${result.recordsInserted?.morm || 0}`);
      console.log(`   - Total: ${result.recordsInserted?.total || 0}`);

      res.json({
        success: true,
        message: 'Divisional budget data imported successfully',
        ...result,
        skippedRecords: recordErrors.length > 0 ? recordErrors.length : undefined,
        errors: recordErrors.length > 0 ? recordErrors : undefined
      });
    } catch (error) {
      // Safe rollback - catch any rollback errors to prevent crashes
      try {
        await client.query('ROLLBACK');
      } catch (rollbackError) {
        console.error('‚ùå Rollback failed:', rollbackError.message);
      }
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('‚ùå Error importing divisional budget HTML:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/save-divisional-budget
 * Save divisional budget data directly from the web app (no HTML export)
 */
router.post('/save-divisional-budget', async (req, res) => {
  const { division, budgetYear, records } = req.body;
  
  if (!division || !budgetYear || !Array.isArray(records)) {
    return res.status(400).json({
      success: false,
      error: 'division, budgetYear, and records array are required'
    });
  }
  
  // Use division-specific pool
  const divisionPool = getPoolForDivision(division);
  const client = await divisionPool.connect();
  try {

    await client.query('BEGIN');
    const result = await saveDivisionalBudget(client, {
      division,
      budgetYear: parseInt(budgetYear, 10),
      records,
      savedAt: new Date().toISOString(),
      filenamePrefix: 'LIVE_Divisional'
    });
    await client.query('COMMIT');

    res.json({
      success: true,
      message: 'Divisional budget saved successfully',
      ...result
    });
  } catch (error) {
    // Safe rollback - catch any rollback errors to prevent crashes
    try {
      await client.query('ROLLBACK');
    } catch (rollbackError) {
      console.error('‚ùå Rollback failed:', rollbackError.message);
    }
    console.error('‚ùå Error saving divisional budget:', error);
    const statusCode = error.details ? 400 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
      details: error.details
    });
  } finally {
    client.release();
  }
});

/**
 * GET /api/aebf/budget-years
 * Get all unique years that have budget data for a division
 */
router.get('/budget-years', async (req, res) => {
  try {
    const { division } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'division is required'
      });
    }
    
    // Get division-specific pool
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT DISTINCT budget_year
      FROM ${tables.salesRepBudget}
      WHERE UPPER(division) = UPPER($1)
        AND UPPER(type) = 'BUDGET'
      ORDER BY budget_year DESC
    `;
    
    const result = await divisionPool.query(query, [division]);
    const years = result.rows.map(row => row.budget_year);
    
    res.json({
      success: true,
      years
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching budget years:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/aebf/budget-sales-reps
 * Get all sales reps who have budget data for a specific year and division
 */
router.get('/budget-sales-reps', async (req, res) => {
  try {
    const { division, budgetYear } = req.query;
    
    if (!division || !budgetYear) {
      return res.status(400).json({
        success: false,
        error: 'division and budgetYear are required'
      });
    }
    
    // Get division-specific pool
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT DISTINCT TRIM(salesrepname) as salesrep
      FROM ${tables.salesRepBudget}
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(type) = 'BUDGET'
        AND salesrepname IS NOT NULL
        AND TRIM(salesrepname) != ''
      ORDER BY TRIM(salesrepname)
    `;
    
    const result = await divisionPool.query(query, [division, parseInt(budgetYear)]);
    const salesReps = result.rows.map(row => row.salesrep);
    
    res.json({
      success: true,
      salesReps
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching budget sales reps:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/budget-sales-rep-recap
 * Get sales rep budget recap showing AMOUNT, KGS, and MORM totals
 * Returns data similar to the screenshot: year totals for each value type
 */
router.post('/budget-sales-rep-recap', async (req, res) => {
  try {
    const { division, budgetYear, salesRep } = req.body;
    
    if (!division || !budgetYear || !salesRep) {
      return res.status(400).json({
        success: false,
        error: 'division, budgetYear, and salesRep are required'
      });
    }
    
    // Get division-specific pool
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    const query = `
      SELECT 
        values_type,
        SUM(values) as total_values,
        COUNT(*) as record_count
      FROM ${tables.salesRepBudget}
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
        AND UPPER(type) = 'BUDGET'
        AND values_type IN ('Amount', 'KGS', 'MoRM')
      GROUP BY values_type
      ORDER BY 
        CASE values_type
          WHEN 'Amount' THEN 1
          WHEN 'KGS' THEN 2
          WHEN 'MoRM' THEN 3
        END
    `;
    
    const result = await divisionPool.query(query, [division, parseInt(budgetYear), salesRep]);
    
    // Ensure all three types are present even if zero
    const recapMap = {
      'Amount': { values_type: 'Amount', total_values: 0, record_count: 0 },
      'KGS': { values_type: 'KGS', total_values: 0, record_count: 0 },
      'MoRM': { values_type: 'MoRM', total_values: 0, record_count: 0 }
    };
    
    result.rows.forEach(row => {
      recapMap[row.values_type] = {
        values_type: row.values_type,
        total_values: parseFloat(row.total_values) || 0,
        record_count: parseInt(row.record_count) || 0
      };
    });
    
    const recap = [
      recapMap['Amount'],
      recapMap['KGS'],
      recapMap['MoRM']
    ];
    
    res.json({
      success: true,
      recap,
      salesRep,
      budgetYear: parseInt(budgetYear)
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching sales rep budget recap:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/budget-product-groups
 * Get product group breakdown for sales rep budget
 * Returns KGS, Amount (Sales), MoRM for each product group
 */
router.post('/budget-product-groups', async (req, res) => {
  try {
    const { division, budgetYear, salesRep } = req.body;
    
    if (!division || !budgetYear) {
      return res.status(400).json({
        success: false,
        error: 'division and budgetYear are required'
      });
    }
    
    // Get division-specific pool
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    let query;
    let params;
    
    // If salesRep is '__ALL__' or not provided, get all sales reps
    if (!salesRep || salesRep === '__ALL__') {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM ${tables.salesRepBudget}
        WHERE UPPER(division) = UPPER($1)
          AND budget_year = $2
          AND UPPER(type) = 'BUDGET'
          AND values_type IN ('Amount', 'KGS', 'MoRM')
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(budgetYear)];
    } else {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM ${tables.salesRepBudget}
        WHERE UPPER(division) = UPPER($1)
          AND budget_year = $2
          AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
          AND UPPER(type) = 'BUDGET'
          AND values_type IN ('Amount', 'KGS', 'MoRM')
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(budgetYear), salesRep];
    }
    
    const result = await divisionPool.query(query, params);
    
    // Transform data into product group structure
    const productGroupsMap = {};
    
    result.rows.forEach(row => {
      const pgName = row.product_group;
      if (!productGroupsMap[pgName]) {
        productGroupsMap[pgName] = {
          name: pgName,
          KGS: 0,
          Amount: 0,
          MoRM: 0
        };
      }
      productGroupsMap[pgName][row.values_type] = parseFloat(row.total_values) || 0;
    });
    
    // Get pricing data for the previous year (budget year - 1)
    const pricingYear = parseInt(budgetYear) - 1;
    const pricingQuery = `
      SELECT 
        TRIM(p.product_group) as product_group,
        p.rm_round,
        p.morm_round,
        COALESCE(m.material, '') as material,
        COALESCE(m.process, '') as process
      FROM ${tables.pricingRounding} p
      LEFT JOIN ${tables.materialPercentages} m 
        ON UPPER(TRIM(p.product_group)) = UPPER(TRIM(m.product_group))
        AND m.material IS NOT NULL 
        AND TRIM(m.material) != ''
      WHERE UPPER(p.division) = UPPER($1)
        AND p.year = $2
        AND p.product_group IS NOT NULL
        AND TRIM(p.product_group) != ''
    `;
    
    const pricingResult = await divisionPool.query(pricingQuery, [division, pricingYear]);
    
    // Map pricing data
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group] = {
        rm: parseFloat(row.rm_round) || 0,
        morm: parseFloat(row.morm_round) || 0,
        material: row.material || '',
        process: row.process || ''
      };
    });
    
    // Build final product groups array with pricing
    const productGroups = Object.values(productGroupsMap).map(pg => {
      const pricing = pricingMap[pg.name] || { rm: 0, morm: 0, material: '', process: '' };
      return {
        name: pg.name,
        KGS: pg.KGS,
        Amount: pg.Amount,
        MoRM: pg.MoRM,
        RM: pricing.rm,
        Material: pricing.material,
        Process: pricing.process
      };
    });
    
    res.json({
      success: true,
      productGroups,
      budgetYear: parseInt(budgetYear),
      salesRep: salesRep || '__ALL__'
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching budget product groups:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/actual-product-groups
 * Get actual product group data for recap (from actual sales data)
 */
router.post('/actual-product-groups', async (req, res) => {
  try {
    const { division, actualYear, salesRep } = req.body;
    
    console.log(`\n====== ACTUAL PRODUCT GROUPS REQUEST ======`);
    console.log(`Division: ${division}`);
    console.log(`Actual Year: ${actualYear}`);
    console.log(`Sales Rep: ${salesRep}`);
    console.log(`==========================================\n`);
    
    if (!division || !actualYear) {
      return res.status(400).json({
        success: false,
        error: 'division and actualYear are required'
      });
    }
    
    // Get division-specific pool and table names
    const divisionPool = getPoolForDivision(division);
    const tables = getTableNames(division);
    
    console.log(`üîç Fetching actual product groups: division=${division}, year=${actualYear}, salesRep=${salesRep || '__ALL__'}, table=${tables.dataExcel}`);
    
    let query;
    let params;
    
    // Query from division-specific data_excel table for actual sales data
    if (!salesRep || salesRep === '__ALL__') {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM ${tables.dataExcel}
        WHERE UPPER(division) = UPPER($1)
          AND year = $2
          AND UPPER(type) = 'ACTUAL'
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
          AND values_type IN ('KGS', 'AMOUNT', 'MORM')
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(actualYear)];
    } else {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM ${tables.dataExcel}
        WHERE UPPER(division) = UPPER($1)
          AND year = $2
          AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
          AND UPPER(type) = 'ACTUAL'
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
          AND values_type IN ('KGS', 'AMOUNT', 'MORM')
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(actualYear), salesRep];
    }
    
    const result = await divisionPool.query(query, params);
    
    console.log(`üìä Query returned ${result.rows.length} rows`);
    
    // Transform data into product group structure (same as budget endpoint)
    const productGroupsMap = {};
    
    result.rows.forEach(row => {
      const pgName = row.product_group;
      if (!productGroupsMap[pgName]) {
        productGroupsMap[pgName] = {
          name: pgName,
          KGS: 0,
          Amount: 0,
          MoRM: 0
        };
      }
      // Normalize values_type case: AMOUNT -> Amount, MORM -> MoRM, KGS -> KGS
      let normalizedType = row.values_type;
      if (row.values_type === 'AMOUNT') {
        normalizedType = 'Amount';
      } else if (row.values_type === 'MORM') {
        normalizedType = 'MoRM';
      }
      productGroupsMap[pgName][normalizedType] = parseFloat(row.total_values) || 0;
    });
    
    const productGroups = Object.values(productGroupsMap);
    console.log(`‚úÖ Returning ${productGroups.length} product groups`);
    
    res.json({
      success: true,
      productGroups,
      actualYear: parseInt(actualYear),
      salesRep: salesRep || '__ALL__'
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching actual product groups:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * DELETE /api/aebf/delete-divisional-budget/:division/:budgetYear
 * Delete all divisional budget data for a specific division and year
 */
router.delete('/delete-divisional-budget/:division/:budgetYear', async (req, res) => {
  console.log('üóëÔ∏è DELETE divisional budget request received:', req.params);
  
  // URL decode the division parameter to handle spaces and special characters
  const division = decodeURIComponent(req.params.division);
  const budgetYear = req.params.budgetYear;
  const year = parseInt(budgetYear);
  
  // Get division-specific pool and table names
  const divisionPool = getPoolForDivision(division);
  const tables = getTableNames(division);
  
  const client = await divisionPool.connect();
  
  try {
    console.log(`Deleting divisional budget for: Division="${division}", Year=${year}`);
    
    await client.query('BEGIN');
    
    // Debug: Check what records exist before delete
    const preCheckResult = await client.query(`
      SELECT division, year, COUNT(*) as count 
      FROM public.${tables.divisionalBudget} 
      WHERE UPPER(division) = UPPER($1) AND year = $2
      GROUP BY division, year
    `, [division, year]);
    console.log('üîç Pre-delete check:', preCheckResult.rows);
    
    // Also check all divisions/years in the table
    const allDataResult = await client.query(`
      SELECT division, year, COUNT(*) as count 
      FROM public.${tables.divisionalBudget} 
      GROUP BY division, year
      ORDER BY division, year
    `);
    console.log(`üìä All data in ${tables.divisionalBudget}:`, allDataResult.rows);
    
    // First, ensure the archive table exists
    const archiveTableName = `${tables.divisionalBudget}_archive`;
    await client.query(`
      CREATE TABLE IF NOT EXISTS ${archiveTableName} (
        id SERIAL PRIMARY KEY,
        division VARCHAR(50),
        year INTEGER,
        month INTEGER,
        product_group VARCHAR(100),
        metric VARCHAR(20),
        value NUMERIC(18,4),
        material VARCHAR(100),
        process VARCHAR(100),
        uploaded_filename VARCHAR(500),
        uploaded_at TIMESTAMP,
        archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        archived_reason VARCHAR(255)
      )
    `);
    
    // Archive existing data before deletion (if any records exist)
    if (preCheckResult.rows.length > 0) {
      const archiveQuery = `
        INSERT INTO ${archiveTableName} (
          division, year, month, product_group, metric, value, material, process,
          uploaded_filename, uploaded_at, archived_at, archived_reason
        )
        SELECT 
          division, year, month, product_group, metric, value, material, process,
          uploaded_filename, uploaded_at, CURRENT_TIMESTAMP, 'Manual deletion by user'
        FROM public.${tables.divisionalBudget}
        WHERE UPPER(division) = UPPER($1)
          AND year = $2
      `;
      
      try {
        await client.query(archiveQuery, [division, year]);
        console.log('‚úÖ Divisional budget archived before deletion');
      } catch (archiveError) {
        console.warn('‚ö†Ô∏è Archive failed (non-critical):', archiveError.message);
        // Continue with deletion even if archive fails
      }
    }
    
    // Delete from divisional_budget
    const deleteResult = await client.query(`
      DELETE FROM public.${tables.divisionalBudget}
      WHERE UPPER(division) = UPPER($1) 
        AND year = $2
    `, [division, year]);
    
    console.log(`‚úÖ Deleted ${deleteResult.rowCount} records from ${tables.divisionalBudget}`);
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Divisional budget deleted successfully',
      deletedCount: deleteResult.rowCount,
      division: division,
      budgetYear: year
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Error deleting divisional budget:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  } finally {
    client.release();
  }
});

// ============================================================================
// BULK IMPORT ENDPOINTS
// ============================================================================

/**
 * POST /api/aebf/bulk-import
 * Import multiple sales rep budget files at once
 */
router.post('/bulk-import', async (req, res) => {
  console.log('üì¶ Bulk import request received');
  const client = await pool.connect();
  
  // Helper function to convert string to Proper Case (Title Case)
  const toProperCase = (str) => {
    if (!str) return '';
    return str.toString().trim().toLowerCase().replace(/(?:^|\s|[-/])\w/g, (match) => match.toUpperCase());
  };
  
  try {
    const { files, saveToFinal, division } = req.body;
    
    if (!files || !Array.isArray(files) || files.length === 0) {
      return res.status(400).json({ success: false, error: 'No files provided' });
    }
    
    if (!division) {
      return res.status(400).json({ success: false, error: 'Division is required' });
    }
    
    // Generate batch ID
    const batchId = `BULK_${Date.now()}_${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
    const status = saveToFinal ? 'final' : 'draft';
    const importedAt = new Date().toISOString();
    
    console.log(`üì¶ Processing ${files.length} files, batch: ${batchId}, status: ${status}`);
    
    await client.query('BEGIN');
    
    let totalImported = 0;
    const importedSalesReps = [];
    const errors = [];
    
    for (const file of files) {
      try {
        const { htmlContent, salesRep: rawSalesRep, budgetYear, filename } = file;
        
        // Normalize sales rep name to Proper Case for consistent storage
        const salesRep = toProperCase(rawSalesRep);
        
        if (!htmlContent) {
          errors.push({ filename, error: 'No content' });
          continue;
        }
        
        // Extract budget data from HTML (handle newlines in the data)
        const budgetDataMatch = htmlContent.match(/const savedBudget\s*=\s*(\[[\s\S]*?\]);/);
        if (!budgetDataMatch) {
          errors.push({ filename, error: 'No budget data found' });
          continue;
        }
        
        let budgetData;
        try {
          budgetData = JSON.parse(budgetDataMatch[1]);
        } catch (e) {
          errors.push({ filename, error: 'Invalid budget data format' });
          continue;
        }
        
        if (!Array.isArray(budgetData) || budgetData.length === 0) {
          errors.push({ filename, error: 'Empty budget data' });
          continue;
        }
        
        // Get pricing map for amount/morm calculations
        const pricingResult = await client.query(
          `SELECT LOWER(TRIM(product_group)) as product_group, 
                  COALESCE(asp_round, 0) as selling_price, 
                  COALESCE(morm_round, 0) as morm 
           FROM ${getTableNames(division).pricingRounding}
           WHERE year = $1`,
          [budgetYear]
        );
        const pricingMap = {};
        pricingResult.rows.forEach(row => {
          pricingMap[row.product_group] = {
            sellingPrice: parseFloat(row.selling_price) || 0,
            morm: parseFloat(row.morm) || 0
          };
        });
        
        // Group records by customer/country/productGroup and aggregate monthly values
        // Data format: each record has { customer, country, productGroup, month, value }
        const groupedData = {};
        for (const record of budgetData) {
          const customer = record.customer || '';
          const country = record.country || '';
          const productGroup = record.productGroup || '';
          const month = parseInt(record.month) || 0;
          const value = parseFloat(record.value) || 0; // Value is in KG
          
          const key = `${customer}|||${country}|||${productGroup}`;
          if (!groupedData[key]) {
            groupedData[key] = {
              customer,
              country,
              productGroup,
              months: {}
            };
          }
          if (month >= 1 && month <= 12) {
            groupedData[key].months[month] = value;
          }
        }
        
        // Insert each grouped budget record
        for (const key of Object.keys(groupedData)) {
          const record = groupedData[key];
          const customer = record.customer;
          const country = record.country;
          const productGroup = record.productGroup;
          
          // Get monthly values (already in KG)
          const months = {};
          let totalKG = 0;
          for (let m = 1; m <= 12; m++) {
            const val = parseFloat(record.months[m] || 0);
            months[m] = val;
            totalKG += val;
          }
          
          // Calculate amount and morm
          const pricing = pricingMap[(productGroup || '').toLowerCase()] || { sellingPrice: 0, morm: 0 };
          const totalAmount = totalKG * pricing.sellingPrice;
          const totalMoRM = totalKG * pricing.morm;
          
          // Insert into bulk import table
          await client.query(
            `INSERT INTO fp_budget_bulk_import 
             (batch_id, division, sales_rep, budget_year, customer, country, product_group,
              month_1, month_2, month_3, month_4, month_5, month_6,
              month_7, month_8, month_9, month_10, month_11, month_12,
              total_kg, total_amount, total_morm, status, source_file, imported_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)`,
            [
              batchId, division, salesRep, budgetYear, customer, country, productGroup,
              months[1], months[2], months[3], months[4], months[5], months[6],
              months[7], months[8], months[9], months[10], months[11], months[12],
              totalKG, totalAmount, totalMoRM, status, filename, importedAt
            ]
          );
          
          totalImported++;
        }
        
        if (!importedSalesReps.includes(salesRep)) {
          importedSalesReps.push(salesRep);
        }
        
        console.log(`‚úÖ Imported ${Object.keys(groupedData).length} records for ${salesRep} (from ${budgetData.length} raw entries)`);
        
      } catch (fileError) {
        console.error(`‚ùå Error processing file:`, fileError);
        errors.push({ filename: file.filename, error: fileError.message });
      }
    }
    
    // If saving to final, also copy to the main budget table
    if (saveToFinal && totalImported > 0) {
      const tables = getTableNames(division);
      
      // Get all records from this batch
      const batchRecords = await client.query(
        `SELECT * FROM fp_budget_bulk_import WHERE batch_id = $1`,
        [batchId]
      );
      
      for (const record of batchRecords.rows) {
        // Delete existing budget for this sales rep/customer/country/product
        await client.query(
          `DELETE FROM ${tables.salesRepBudget} 
           WHERE sales_rep = $1 AND customer = $2 AND country = $3 
           AND product_group = $4 AND budget_year = $5`,
          [record.sales_rep, record.customer, record.country, record.product_group, record.budget_year]
        );
        
        // Insert into main budget table
        await client.query(
          `INSERT INTO ${tables.salesRepBudget}
           (division, sales_rep, budget_year, customer, country, product_group,
            month_1, month_2, month_3, month_4, month_5, month_6,
            month_7, month_8, month_9, month_10, month_11, month_12,
            total_amount, total_morm, imported_at)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)`,
          [
            record.division, record.sales_rep, record.budget_year, 
            record.customer, record.country, record.product_group,
            record.month_1, record.month_2, record.month_3, record.month_4,
            record.month_5, record.month_6, record.month_7, record.month_8,
            record.month_9, record.month_10, record.month_11, record.month_12,
            record.total_amount, record.total_morm, record.imported_at
          ]
        );
      }
      
      console.log(`‚úÖ Copied ${totalImported} records to main budget table`);
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      batchId,
      importedCount: totalImported,
      salesReps: importedSalesReps,
      status,
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Bulk import error:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

/**
 * GET /api/aebf/bulk-batches
 * Get list of bulk import batches
 */
router.get('/bulk-batches', async (req, res) => {
  try {
    const { division } = req.query;
    
    let query = `
      SELECT 
        batch_id,
        division,
        budget_year,
        status,
        MIN(imported_at) as imported_at,
        COUNT(DISTINCT sales_rep) as sales_rep_count,
        COUNT(*) as record_count
      FROM fp_budget_bulk_import
    `;
    
    const params = [];
    if (division) {
      query += ` WHERE division = $1`;
      params.push(division);
    }
    
    query += ` GROUP BY batch_id, division, budget_year, status ORDER BY imported_at DESC`;
    
    const result = await pool.query(query, params);
    
    res.json({
      success: true,
      batches: result.rows
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching batches:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * GET /api/aebf/bulk-batch/:batchId
 * Get data for a specific batch
 */
router.get('/bulk-batch/:batchId', async (req, res) => {
  try {
    const { batchId } = req.params;
    
    // Get batch info
    const batchInfo = await pool.query(
      `SELECT batch_id, division, budget_year, status, MIN(imported_at) as imported_at
       FROM fp_budget_bulk_import 
       WHERE batch_id = $1
       GROUP BY batch_id, division, budget_year, status`,
      [batchId]
    );
    
    if (batchInfo.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Batch not found' });
    }
    
    // Get all records
    const records = await pool.query(
      `SELECT * FROM fp_budget_bulk_import WHERE batch_id = $1 ORDER BY sales_rep, customer`,
      [batchId]
    );
    
    res.json({
      success: true,
      batch: batchInfo.rows[0],
      data: records.rows
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching batch data:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * DELETE /api/aebf/bulk-batch/:batchId
 * Delete a bulk import batch
 */
router.delete('/bulk-batch/:batchId', async (req, res) => {
  try {
    const { batchId } = req.params;
    
    const result = await pool.query(
      `DELETE FROM fp_budget_bulk_import WHERE batch_id = $1`,
      [batchId]
    );
    
    res.json({
      success: true,
      deletedCount: result.rowCount
    });
    
  } catch (error) {
    console.error('‚ùå Error deleting batch:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * POST /api/aebf/bulk-finalize/:batchId
 * Move batch from draft to final (copy to main budget table)
 */
router.post('/bulk-finalize/:batchId', async (req, res) => {
  const client = await pool.connect();
  
  // Helper function to convert string to Proper Case (Title Case)
  const toProperCase = (str) => {
    if (!str) return '';
    return str.toString().trim().toLowerCase().replace(/(?:^|\s|[-/])\w/g, (match) => match.toUpperCase());
  };
  
  try {
    const { batchId } = req.params;
    
    await client.query('BEGIN');
    
    // Get batch records
    const batchResult = await client.query(
      `SELECT * FROM fp_budget_bulk_import WHERE batch_id = $1 AND status = 'draft'`,
      [batchId]
    );
    
    if (batchResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'No draft records found for this batch' });
    }
    
    const division = batchResult.rows[0].division;
    const tables = getTableNames(division);
    let kgsCount = 0, amountCount = 0, mormCount = 0;
    
    // Fetch pricing data (previous year of budget_year)
    const budgetYear = batchResult.rows[0].budget_year;
    const pricingYear = budgetYear - 1;
    console.log(`üìä Loading pricing data for year ${pricingYear}...`);
    
    const pricingResult = await client.query(
      `SELECT LOWER(TRIM(product_group)) as product_group, 
              asp_round as selling_price, 
              morm_round as morm 
       FROM ${tables.pricingRounding}
       WHERE year = $1`,
      [pricingYear]
    );
    
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    console.log(`‚úÖ Loaded ${Object.keys(pricingMap).length} pricing records for year ${pricingYear}`);
    
    // Fetch material/process data
    console.log(`üìä Loading material/process data...`);
    let materialProcessMap = {};
    try {
      const materialResult = await client.query(
        `SELECT LOWER(TRIM(product_group)) as product_group, material, process 
         FROM ${tables.materialPercentages}
         WHERE material IS NOT NULL AND material != '' AND process IS NOT NULL AND process != ''`
      );
      materialResult.rows.forEach(row => {
        materialProcessMap[row.product_group] = {
          material: row.material || '',
          process: row.process || ''
        };
      });
      console.log(`‚úÖ Loaded ${Object.keys(materialProcessMap).length} material/process records`);
    } catch (matErr) {
      console.warn(`‚ö†Ô∏è Could not load material/process data: ${matErr.message}`);
    }
    
    // The fp_sales_rep_budget table uses a different format:
    // One row per month with: salesrepname, customername, countryname, productgroup, month, type, values
    
    for (const record of batchResult.rows) {
      // Normalize names to Proper Case for consistent storage
      const normalizedSalesRep = toProperCase(record.sales_rep);
      const normalizedCustomer = toProperCase(record.customer);
      const normalizedCountry = toProperCase(record.country);
      const normalizedProductGroup = toProperCase(record.product_group);
      
      // Get pricing and material info for this product group
      const pgKey = (record.product_group || '').toLowerCase().trim();
      const pricing = pricingMap[pgKey] || { sellingPrice: 0, morm: 0 };
      
      // Get material/process - for "Others" product group, use "Others" as both material and process
      let matProc = materialProcessMap[pgKey] || { material: '', process: '' };
      if (pgKey === 'others' && (!matProc.material || !matProc.process)) {
        matProc = { material: 'Others', process: 'Others' };
      }
      
      // Delete existing budget records for this combination (type='budget') - use case-insensitive match
      await client.query(
        `DELETE FROM ${tables.salesRepBudget} 
         WHERE LOWER(salesrepname) = LOWER($1) AND LOWER(customername) = LOWER($2) AND LOWER(countryname) = LOWER($3) 
         AND LOWER(productgroup) = LOWER($4) AND budget_year = $5 AND UPPER(type) = 'BUDGET'`,
        [normalizedSalesRep, normalizedCustomer, normalizedCountry, normalizedProductGroup, record.budget_year]
      );
      
      // Insert one row per month (months 1-12) with non-zero values
      const monthValues = [
        record.month_1, record.month_2, record.month_3, record.month_4,
        record.month_5, record.month_6, record.month_7, record.month_8,
        record.month_9, record.month_10, record.month_11, record.month_12
      ];
      
      for (let m = 1; m <= 12; m++) {
        const kgsValue = parseFloat(monthValues[m - 1]) || 0;
        if (kgsValue > 0) {
          // Insert KGS record
          await client.query(
            `INSERT INTO ${tables.salesRepBudget}
             (division, salesrepname, customername, countryname, productgroup, 
              budget_year, year, month, type, values_type, values, material, process, uploaded_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,
            [
              record.division, 
              normalizedSalesRep,
              normalizedCustomer,
              normalizedCountry,
              normalizedProductGroup,
              record.budget_year,
              record.budget_year,
              m,
              'BUDGET',
              'KGS',
              kgsValue,
              matProc.material,
              matProc.process,
              new Date()
            ]
          );
          kgsCount++;
          
          // Insert Amount record (KGS * sellingPrice)
          const amountValue = kgsValue * pricing.sellingPrice;
          if (amountValue > 0 || pricing.sellingPrice > 0) {
            await client.query(
              `INSERT INTO ${tables.salesRepBudget}
               (division, salesrepname, customername, countryname, productgroup, 
                budget_year, year, month, type, values_type, values, material, process, uploaded_at)
               VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,
              [
                record.division, 
                normalizedSalesRep,
                normalizedCustomer,
                normalizedCountry,
                normalizedProductGroup,
                record.budget_year,
                record.budget_year,
                m,
                'BUDGET',
                'Amount',
                amountValue,
                matProc.material,
                matProc.process,
                new Date()
              ]
            );
            amountCount++;
          }
          
          // Insert MoRM record (KGS * morm)
          const mormValue = kgsValue * pricing.morm;
          if (mormValue > 0 || pricing.morm > 0) {
            await client.query(
              `INSERT INTO ${tables.salesRepBudget}
               (division, salesrepname, customername, countryname, productgroup, 
                budget_year, year, month, type, values_type, values, material, process, uploaded_at)
               VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,
              [
                record.division, 
                normalizedSalesRep,
                normalizedCustomer,
                normalizedCountry,
                normalizedProductGroup,
                record.budget_year,
                record.budget_year,
                m,
                'BUDGET',
                'MoRM',
                mormValue,
                matProc.material,
                matProc.process,
                new Date()
              ]
            );
            mormCount++;
          }
        }
      }
    }
    
    // Update batch status to final
    await client.query(
      `UPDATE fp_budget_bulk_import SET status = 'final' WHERE batch_id = $1`,
      [batchId]
    );
    
    await client.query('COMMIT');
    
    console.log(`‚úÖ Finalized batch ${batchId}: KGS=${kgsCount}, Amount=${amountCount}, MoRM=${mormCount} records inserted`);
    
    res.json({
      success: true,
      recordCount: kgsCount,
      amountCount: amountCount,
      mormCount: mormCount,
      message: `Successfully finalized ${kgsCount} KGS, ${amountCount} Amount, ${mormCount} MoRM budget records`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Error finalizing batch:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

/**
 * GET /api/aebf/bulk-export/:batchId
 * Export batch as merged HTML file
 */
router.get('/bulk-export/:batchId', async (req, res) => {
  try {
    const { batchId } = req.params;
    
    // Get batch info
    const batchInfo = await pool.query(
      `SELECT batch_id, division, budget_year, status, MIN(imported_at) as imported_at
       FROM fp_budget_bulk_import 
       WHERE batch_id = $1
       GROUP BY batch_id, division, budget_year, status`,
      [batchId]
    );
    
    if (batchInfo.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Batch not found' });
    }
    
    const batch = batchInfo.rows[0];
    
    // Get all records grouped by sales rep
    const records = await pool.query(
      `SELECT * FROM fp_budget_bulk_import WHERE batch_id = $1 ORDER BY sales_rep, customer`,
      [batchId]
    );
    
    // Group by sales rep
    const salesRepData = {};
    const allSalesReps = [];
    
    records.rows.forEach(row => {
      if (!salesRepData[row.sales_rep]) {
        salesRepData[row.sales_rep] = [];
        allSalesReps.push(row.sales_rep);
      }
      salesRepData[row.sales_rep].push(row);
    });
    
    // Get pricing for calculations
    const pricingResult = await pool.query(
      `SELECT LOWER(TRIM(product_group)) as product_group, 
              COALESCE(asp_round, 0) as selling_price, 
              COALESCE(morm_round, 0) as morm 
       FROM ${getTableNames(batch.division).pricingRounding}
       WHERE year = $1`,
      [batch.budget_year]
    );
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    // Generate merged HTML
    const html = generateMergedBudgetHTML({
      batch,
      salesRepData,
      allSalesReps,
      records: records.rows,
      pricingMap
    });
    
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('Content-Disposition', `attachment; filename="MERGED_BUDGET_${batch.division}_${batch.budget_year}_${batchId}.html"`);
    res.send(html);
    
  } catch (error) {
    console.error('‚ùå Error exporting batch:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Generate merged budget HTML for bulk export - Same design as sales rep budget
 */
function generateMergedBudgetHTML({ batch, salesRepData, allSalesReps, records, pricingMap }) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  // Calculate totals per sales rep
  const salesRepTotals = {};
  allSalesReps.forEach(rep => {
    const data = salesRepData[rep];
    salesRepTotals[rep] = {
      totalKG: data.reduce((sum, r) => sum + (parseFloat(r.total_kg) || 0), 0),
      totalAmount: data.reduce((sum, r) => sum + (parseFloat(r.total_amount) || 0), 0),
      totalMoRM: data.reduce((sum, r) => sum + (parseFloat(r.total_morm) || 0), 0),
      recordCount: data.length
    };
  });
  
  // Overall totals
  const overallTotals = {
    totalKG: records.reduce((sum, r) => sum + (parseFloat(r.total_kg) || 0), 0),
    totalAmount: records.reduce((sum, r) => sum + (parseFloat(r.total_amount) || 0), 0),
    totalMoRM: records.reduce((sum, r) => sum + (parseFloat(r.total_morm) || 0), 0),
    recordCount: records.length
  };
  
  // Calculate product group totals for chart
  const productGroupTotals = {};
  records.forEach(row => {
    const pg = row.product_group || 'Unknown';
    if (!productGroupTotals[pg]) {
      productGroupTotals[pg] = { totalKG: 0, totalAmount: 0, totalMoRM: 0 };
    }
    productGroupTotals[pg].totalKG += parseFloat(row.total_kg) || 0;
    productGroupTotals[pg].totalAmount += parseFloat(row.total_amount) || 0;
    productGroupTotals[pg].totalMoRM += parseFloat(row.total_morm) || 0;
  });
  
  // Sort product groups by total KG descending
  const sortedProductGroups = Object.entries(productGroupTotals)
    .sort((a, b) => b[1].totalKG - a[1].totalKG);
  
  // Chart colors
  const chartColors = [
    '#1890ff', '#52c41a', '#faad14', '#f5222d', '#722ed1', 
    '#13c2c2', '#eb2f96', '#fa8c16', '#a0d911', '#2f54eb',
    '#fadb14', '#ff4d4f', '#9254de', '#36cfc9', '#ffc53d'
  ];
  
  // Format number helper
  const formatNumber = (val) => {
    if (!val || val === 0) return '0';
    return val.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
  };
  
  const formatNum = (val) => {
    if (!val || val === 0) return '0';
    if (val >= 1000000) return (val / 1000000).toFixed(1) + 'M';
    if (val >= 1000) return (val / 1000).toFixed(1) + 'K';
    return val.toFixed(0);
  };
  
  // Generate table rows
  const generateTableRows = (data) => {
    return data.map((row, idx) => {
      const monthCells = Array.from({ length: 12 }, (_, i) => {
        const val = parseFloat(row['month_' + (i + 1)]) || 0;
        return '<td class="month-cell" style="text-align: right; background: #fffbe6;">' + (val > 0 ? formatNumber(val) : '-') + '</td>';
      }).join('');
      
      const totalMT = (parseFloat(row.total_kg) || 0) / 1000;
      
      return '<tr data-sales-rep="' + row.sales_rep + '" data-idx="' + idx + '">' +
        '<td class="sticky-col" style="left: 0; background: #f5f5f5; font-weight: 500;">' + row.sales_rep + '</td>' +
        '<td class="sticky-col" style="left: 120px; background: #fff;">' + (row.customer || '-') + '</td>' +
        '<td>' + (row.country || '-') + '</td>' +
        '<td>' + (row.product_group || '-') + '</td>' +
        monthCells +
        '<td style="text-align: right; font-weight: bold; background: #e6f7ff;">' + totalMT.toFixed(2) + '</td>' +
        '<td style="text-align: right; font-weight: bold;">' + formatNumber(parseFloat(row.total_amount) || 0) + '</td>' +
        '<td style="text-align: right; font-weight: bold;">' + formatNumber(parseFloat(row.total_morm) || 0) + '</td>' +
        '</tr>';
    }).join('');
  };
  
  // Generate product group table for chart legend
  const generateProductGroupTable = () => {
    return sortedProductGroups.map(([pg, totals], idx) => {
      const color = chartColors[idx % chartColors.length];
      const mt = totals.totalKG / 1000;
      return '<tr>' +
        '<td><span style="display: inline-block; width: 12px; height: 12px; background: ' + color + '; border-radius: 2px; margin-right: 8px;"></span>' + pg + '</td>' +
        '<td style="text-align: right;">' + mt.toFixed(2) + ' MT</td>' +
        '<td style="text-align: right;">' + formatNumber(totals.totalAmount) + '</td>' +
        '<td style="text-align: right;">' + formatNumber(totals.totalMoRM) + '</td>' +
        '</tr>';
    }).join('');
  };
  
  // Generate sales rep tabs
  const salesRepTabsHTML = allSalesReps.map(rep => {
    return '<button class="tab-btn" data-rep="' + rep + '" onclick="showSalesRep(\'' + rep + '\')">' + rep + ' (' + salesRepTotals[rep].recordCount + ')</button>';
  }).join('');
  
  // Generate month headers
  const monthHeaders = months.map(m => '<th style="width: 60px;">' + m + '</th>').join('');

  return '<!DOCTYPE html>' +
'<!-- IPD_BUDGET_SYSTEM_v2.0 :: TYPE=MERGED_BULK_BUDGET :: DO_NOT_EDIT_THIS_LINE -->' +
'<html lang="en">' +
'<head>' +
'  <meta charset="UTF-8">' +
'  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
'  <title>Merged Budget - ' + batch.division + ' - ' + batch.budget_year + '</title>' +
'  <script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>' +
'  <style>' +
'    * { margin: 0; padding: 0; box-sizing: border-box; }' +
'    html, body { height: 100%; margin: 0; padding: 0; }' +
'    body { font-family: Arial, sans-serif; padding: 12px; background: #f5f5f5; display: flex; flex-direction: column; }' +
'    .header { background: #fff; padding: 12px 20px; margin-bottom: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; }' +
'    .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }' +
'    .header h1 { margin: 0; color: #333; font-size: 18px; }' +
'    .header-actions { display: flex; gap: 8px; align-items: center; }' +
'    .header-bottom { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; }' +
'    .header-info { display: flex; gap: 20px; flex-wrap: wrap; }' +
'    .header-info div { font-size: 12px; color: #666; }' +
'    .header-info strong { color: #333; }' +
'    .btn { padding: 6px 16px; border-radius: 4px; cursor: pointer; font-size: 12px; border: 1px solid #d9d9d9; background: #fff; transition: all 0.2s; }' +
'    .btn:hover { border-color: #1677ff; color: #1677ff; }' +
'    .recap-container { display: flex; gap: 16px; margin-bottom: 12px; flex-shrink: 0; }' +
'    .recap-chart { flex: 1; background: #fff; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-width: 300px; }' +
'    .recap-stats { flex: 1; background: #fff; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
'    .recap-stats h3 { font-size: 14px; margin-bottom: 12px; color: #333; }' +
'    .recap-table { width: 100%; font-size: 12px; border-collapse: collapse; }' +
'    .recap-table th, .recap-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; }' +
'    .recap-table th { text-align: left; color: #666; font-weight: normal; }' +
'    .recap-table tfoot td { font-weight: bold; background: #fafafa; }' +
'    .sales-rep-tabs { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; padding: 12px; background: #fff; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
'    .tab-btn { padding: 8px 16px; border: 1px solid #d9d9d9; background: #fff; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s; }' +
'    .tab-btn:hover { border-color: #1677ff; color: #1677ff; }' +
'    .tab-btn.active { background: #1677ff; color: #fff; border-color: #1677ff; }' +
'    .table-container { background: #fff; padding: 0; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; flex: 1; min-height: 400px; overflow-x: auto; overflow-y: auto; }' +
'    table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 11px; table-layout: fixed; }' +
'    thead tr { position: sticky; top: 0; z-index: 100; }' +
'    thead th { background: #1677ff; color: #fff; padding: 8px 6px; border: 1px solid #fff; text-align: center; white-space: nowrap; }' +
'    thead th.sticky-col { position: sticky; z-index: 101; background: #1677ff; }' +
'    tbody td { padding: 6px; border: 1px solid #f0f0f0; }' +
'    tbody td.sticky-col { position: sticky; z-index: 50; }' +
'    tbody tr:hover td { background: #e6f7ff !important; }' +
'    tbody tr.hidden { display: none; }' +
'    .summary-cards { display: flex; gap: 16px; margin-bottom: 12px; }' +
'    .summary-card { flex: 1; background: #fff; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }' +
'    .summary-card .label { font-size: 11px; color: #666; margin-bottom: 4px; }' +
'    .summary-card .value { font-size: 20px; font-weight: bold; color: #1677ff; }' +
'    @media print { .header-actions, .sales-rep-tabs, .search-box { display: none; } body { padding: 0; } }' +
'  </style>' +
'</head>' +
'<body>' +
'  <div class="header">' +
'    <div class="header-top">' +
'      <h1>üìä Merged Budget Report - ' + batch.division + '</h1>' +
'      <div class="header-actions">' +
'        <input type="text" class="search-box" id="searchBox" placeholder="üîç Search..." oninput="filterTable()" style="padding: 6px 12px; border: 1px solid #d9d9d9; border-radius: 4px; width: 250px; font-size: 12px;">' +
'        <button class="btn" onclick="window.print()">üñ®Ô∏è Print</button>' +
'      </div>' +
'    </div>' +
'    <div class="header-bottom">' +
'      <div class="header-info">' +
'        <div>Division: <strong>' + batch.division + '</strong></div>' +
'        <div>Budget Year: <strong>' + batch.budget_year + '</strong></div>' +
'        <div>Sales Reps: <strong>' + allSalesReps.length + '</strong></div>' +
'        <div>Records: <strong>' + records.length + '</strong></div>' +
'        <div>Batch: <strong>' + batch.batch_id + '</strong></div>' +
'      </div>' +
'    </div>' +
'  </div>' +
'  <div class="summary-cards">' +
'    <div class="summary-card"><div class="label">Sales Reps</div><div class="value" id="statSalesReps">' + allSalesReps.length + '</div></div>' +
'    <div class="summary-card"><div class="label">Total MT</div><div class="value" id="statTotalMT">' + (overallTotals.totalKG / 1000).toFixed(2) + '</div></div>' +
'    <div class="summary-card"><div class="label">Total Amount (AED)</div><div class="value" id="statTotalAmount">' + formatNum(overallTotals.totalAmount) + '</div></div>' +
'    <div class="summary-card"><div class="label">Total MoRM (AED)</div><div class="value" id="statTotalMoRM">' + formatNum(overallTotals.totalMoRM) + '</div></div>' +
'  </div>' +
'  <div class="recap-container">' +
'    <div class="recap-chart">' +
'      <h3 style="font-size: 14px; margin-bottom: 12px;">Budget by Product Group</h3>' +
'      <canvas id="productGroupChart" style="max-height: 250px;"></canvas>' +
'    </div>' +
'    <div class="recap-stats">' +
'      <h3>Product Group Summary</h3>' +
'      <table class="recap-table">' +
'        <thead><tr><th>Product Group</th><th style="text-align: right;">MT</th><th style="text-align: right;">Amount</th><th style="text-align: right;">MoRM</th></tr></thead>' +
'        <tbody>' + generateProductGroupTable() + '</tbody>' +
'        <tfoot><tr><td>Total</td><td style="text-align: right;">' + (overallTotals.totalKG / 1000).toFixed(2) + ' MT</td><td style="text-align: right;">' + formatNumber(overallTotals.totalAmount) + '</td><td style="text-align: right;">' + formatNumber(overallTotals.totalMoRM) + '</td></tr></tfoot>' +
'      </table>' +
'    </div>' +
'  </div>' +
'  <div class="sales-rep-tabs">' +
'    <button class="tab-btn active" data-rep="all" onclick="showSalesRep(\'all\')">üìä All (' + records.length + ')</button>' +
    salesRepTabsHTML +
'  </div>' +
'  <div class="table-container">' +
'    <table id="dataTable">' +
'      <thead><tr>' +
'        <th class="sticky-col" style="left: 0; width: 120px;">Sales Rep</th>' +
'        <th class="sticky-col" style="left: 120px; width: 180px;">Customer</th>' +
'        <th style="width: 120px;">Country</th>' +
'        <th style="width: 120px;">Product Group</th>' +
        monthHeaders +
'        <th style="width: 70px;">Total MT</th>' +
'        <th style="width: 80px;">Amount</th>' +
'        <th style="width: 80px;">MoRM</th>' +
'      </tr></thead>' +
'      <tbody id="tableBody">' + generateTableRows(records) + '</tbody>' +
'    </table>' +
'  </div>' +
'  <script>' +
'    var allData = ' + JSON.stringify(records) + ';' +
'    var salesRepTotals = ' + JSON.stringify(salesRepTotals) + ';' +
'    var overallTotals = ' + JSON.stringify(overallTotals) + ';' +
'    var productGroupData = ' + JSON.stringify(sortedProductGroups) + ';' +
'    var chartColors = ' + JSON.stringify(chartColors) + ';' +
'    var currentRep = "all";' +
'    var ctx = document.getElementById("productGroupChart").getContext("2d");' +
'    var chart = new Chart(ctx, {' +
'      type: "doughnut",' +
'      data: {' +
'        labels: productGroupData.map(function(x) { return x[0]; }),' +
'        datasets: [{' +
'          data: productGroupData.map(function(x) { return x[1].totalKG / 1000; }),' +
'          backgroundColor: chartColors.slice(0, productGroupData.length),' +
'          borderWidth: 2,' +
'          borderColor: "#fff"' +
'        }]' +
'      },' +
'      options: { responsive: true, maintainAspectRatio: true, plugins: { legend: { display: false } } }' +
'    });' +
'    function formatNum(val) { if (!val || val === 0) return "0"; if (val >= 1000000) return (val / 1000000).toFixed(1) + "M"; if (val >= 1000) return (val / 1000).toFixed(1) + "K"; return val.toFixed(0); }' +
'    function showSalesRep(rep) {' +
'      currentRep = rep;' +
'      document.querySelectorAll(".tab-btn").forEach(function(btn) { btn.classList.toggle("active", btn.dataset.rep === rep); });' +
'      var totals = rep === "all" ? overallTotals : salesRepTotals[rep];' +
'      document.getElementById("statSalesReps").textContent = rep === "all" ? Object.keys(salesRepTotals).length : "1";' +
'      document.getElementById("statTotalMT").textContent = ((totals && totals.totalKG || 0) / 1000).toFixed(2);' +
'      document.getElementById("statTotalAmount").textContent = formatNum(totals && totals.totalAmount || 0);' +
'      document.getElementById("statTotalMoRM").textContent = formatNum(totals && totals.totalMoRM || 0);' +
'      filterTable();' +
'    }' +
'    function filterTable() {' +
'      var search = document.getElementById("searchBox").value.toLowerCase();' +
'      var rows = document.querySelectorAll("#tableBody tr");' +
'      rows.forEach(function(row) {' +
'        var salesRep = row.dataset.salesRep;' +
'        var idx = parseInt(row.dataset.idx);' +
'        var data = allData[idx];' +
'        if (!data) return;' +
'        var visible = true;' +
'        if (currentRep !== "all" && salesRep !== currentRep) visible = false;' +
'        if (visible && search) {' +
'          var text = [data.sales_rep, data.customer, data.country, data.product_group].join(" ").toLowerCase();' +
'          if (text.indexOf(search) === -1) visible = false;' +
'        }' +
'        row.classList.toggle("hidden", !visible);' +
'      });' +
'    }' +
'  <\/script>' +
'</body>' +
'</html>';
}

module.exports = router;
