/**
 * AEBF (Actual/Estimate/Budget/Forecast) API Routes
 * Handles data retrieval and upload operations for AEBF feature
 * 
 * Step 3: Basic API Structure
 */

const express = require('express');
const router = express.Router();
const { pool } = require('../database/config');
const path = require('path');
const fs = require('fs');
const DivisionMergeRulesService = require('../database/DivisionMergeRulesService');
const { saveLiveSalesRepBudget } = require('../services/salesRepBudgetService');
const { saveDivisionalBudget, getDivisionalBudgetInfo } = require('../services/divisionalBudgetService');

// ============================================================================
// HEALTH CHECK ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/health
 * Health check endpoint to verify AEBF API is running
 */
router.get('/health', async (req, res) => {
  try {
    // Test database connection
    const result = await pool.query('SELECT NOW() as current_time, version() as pg_version');
    
    // Check if fp_data_excel table exists and get row count
    const tableCheck = await pool.query(`
      SELECT 
        COUNT(*) as total_records,
        COUNT(DISTINCT division) as divisions,
        MIN(year) as min_year,
        MAX(year) as max_year
      FROM public.fp_data_excel
    `);
    
    res.json({
      success: true,
      status: 'healthy',
      timestamp: result.rows[0].current_time,
      database: {
        connected: true,
        version: result.rows[0].pg_version,
        table: 'fp_data_excel',
        totalRecords: parseInt(tableCheck.rows[0].total_records),
        divisions: parseInt(tableCheck.rows[0].divisions),
        yearRange: `${tableCheck.rows[0].min_year}-${tableCheck.rows[0].max_year}`
      }
    });
  } catch (error) {
    console.error('âŒ AEBF Health check failed:', error);
    res.status(500).json({
      success: false,
      status: 'unhealthy',
      error: error.message
    });
  }
});

// ============================================================================
// GET ACTUAL DATA ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/actual
 * Retrieve Actual data from fp_data_excel table
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - page: Page number for pagination (default: 1)
 * - pageSize: Records per page (default: 100, max: 1000)
 * - year: Filter by specific year
 * - month: Filter by specific month
 * - values_type: Filter by values type (AMOUNT, KGS, MORM)
 * - salesrepname: Filter by sales rep name
 * - customername: Filter by customer name (partial match)
 * - countryname: Filter by country name
 * - productgroup: Filter by product group
 * - sortBy: Sort field (year, month, values, customername, etc.)
 * - sortOrder: Sort direction (asc, desc) - default: desc
 * - search: Search across customer, country, product group (partial match)
 * 
 * Returns:
 * {
 *   success: true,
 *   data: [...],
 *   pagination: { total, page, pageSize, totalPages },
 *   filters: { applied filters }
 * }
 */
router.get('/actual', async (req, res) => {
  try {
    const {
      division,
      page = 1,
      pageSize = 100,
      year,
      month,
      values_type,
      salesrepname,
      customername,
      countryname,
      productgroup,
      sortBy = 'year',
      sortOrder = 'desc',
      search,
      types // New parameter: comma-separated types like "Actual,Estimate"
    } = req.query;
    
    // Validate required parameters
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    // Validate division value
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Validate and limit page size
    const limit = Math.min(parseInt(pageSize) || 100, 1000);
    const offset = (parseInt(page) - 1) * limit;
    
    // Build WHERE clause
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      conditions.push(`UPPER(type) IN (${typePlaceholders})`);
      params.push(...typeArray);
      paramIndex += typeArray.length;
    } else {
      // Default to Actual only for backward compatibility
      conditions.push("UPPER(type) = 'ACTUAL'");
    }
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    if (salesrepname) {
      conditions.push(`UPPER(salesrepname) = $${paramIndex}`);
      params.push(salesrepname.toUpperCase());
      paramIndex++;
    }
    
    if (customername) {
      conditions.push(`UPPER(customername) LIKE $${paramIndex}`);
      params.push(`%${customername.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (countryname) {
      conditions.push(`UPPER(countryname) = $${paramIndex}`);
      params.push(countryname.toUpperCase());
      paramIndex++;
    }
    
    if (productgroup) {
      conditions.push(`UPPER(productgroup) LIKE $${paramIndex}`);
      params.push(`%${productgroup.toUpperCase()}%`);
      paramIndex++;
    }
    
    // Global search across multiple fields
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Build ORDER BY clause
    const validSortFields = ['year', 'month', 'values', 'customername', 'countryname', 'productgroup', 'salesrepname', 'values_type'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'year';
    const sortDirection = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';
    const orderByClause = `ORDER BY ${sortField} ${sortDirection}, id DESC`;
    
    // Get total count for pagination
    const countQuery = `
      SELECT COUNT(*) as total
      FROM public.fp_data_excel
      WHERE ${whereClause}
    `;
    const countResult = await pool.query(countQuery, params);
    const total = parseInt(countResult.rows[0].total);
    
    // Get paginated data
    const dataQuery = `
      SELECT 
        id,
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.fp_data_excel
      WHERE ${whereClause}
      ${orderByClause}
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(limit, offset);
    
    const dataResult = await pool.query(dataQuery, params);
    
    // Build filters object for response
    const appliedFilters = { division };
    if (year) appliedFilters.year = year;
    if (month) appliedFilters.month = month;
    if (values_type) appliedFilters.values_type = values_type;
    if (salesrepname) appliedFilters.salesrepname = salesrepname;
    if (customername) appliedFilters.customername = customername;
    if (countryname) appliedFilters.countryname = countryname;
    if (productgroup) appliedFilters.productgroup = productgroup;
    if (search) appliedFilters.search = search;
    if (sortBy) appliedFilters.sortBy = sortBy;
    if (sortOrder) appliedFilters.sortOrder = sortOrder;
    
    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: limit,
        totalPages: Math.ceil(total / limit)
      },
      filters: appliedFilters
    });
    
  } catch (error) {
    console.error('âŒ Error fetching actual data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET BUDGET DATA ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/budget
 * Retrieve Budget data from fp_data_excel table
 * Same parameters and structure as /actual endpoint
 */
router.get('/budget', async (req, res) => {
  try {
    const {
      division,
      page = 1,
      pageSize = 100,
      year,
      month,
      values_type,
      search // Add search parameter
    } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const limit = Math.min(parseInt(pageSize) || 100, 1000);
    const offset = (parseInt(page) - 1) * limit;
    
    const conditions = ['UPPER(division) = $1', "type = 'Budget'"];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    // Global search with month name recognition
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    const countQuery = `
      SELECT COUNT(*) as total
      FROM public.fp_data_excel
      WHERE ${whereClause}
    `;
    const countResult = await pool.query(countQuery, params);
    const total = parseInt(countResult.rows[0].total);
    
    const dataQuery = `
      SELECT 
        id,
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.fp_data_excel
      WHERE ${whereClause}
      ORDER BY year DESC, month DESC, id DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(limit, offset);
    
    const dataResult = await pool.query(dataQuery, params);
    
    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: limit,
        totalPages: Math.ceil(total / limit)
      }
    });
    
  } catch (error) {
    console.error('âŒ Error fetching budget data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET SUMMARY STATISTICS ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/summary
 * Get summary statistics for a division
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 * 
 * Returns summary by year, month, values_type
 */
router.get('/summary', async (req, res) => {
  try {
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    const summaryQuery = `
      SELECT 
        type,
        values_type,
        COUNT(*) as record_count,
        SUM(values) as total_values,
        AVG(values) as avg_values,
        MIN(values) as min_values,
        MAX(values) as max_values
      FROM public.fp_data_excel
      WHERE ${whereClause}
      GROUP BY type, values_type
      ORDER BY values_type
    `;
    
    const result = await pool.query(summaryQuery, params);
    
    res.json({
      success: true,
      summary: result.rows
    });
    
  } catch (error) {
    console.error('âŒ Error fetching summary:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET YEAR-SPECIFIC SUMMARY ENDPOINT
// ============================================================================

/**
 * GET /api/aebf/year-summary
 * Get summary statistics for a specific year or all years
 * Returns totals for AMOUNT, KGS, MORM
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - REQUIRED
 * - year: Filter by year - OPTIONAL (if omitted, returns all years)
 * - search: Optional search filter across multiple fields
 */
router.get('/year-summary', async (req, res) => {
  try {
    const { division, type, types, year, search } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Build WHERE clause with optional year and search
    let whereClause = `WHERE UPPER(division) = $1`;
    const queryParams = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      whereClause += ` AND UPPER(type) IN (${typePlaceholders})`;
      queryParams.push(...typeArray);
      paramIndex += typeArray.length;
    } else if (type) {
      // Single type for backward compatibility
      whereClause += ` AND UPPER(type) = $${paramIndex}`;
      queryParams.push(type.toUpperCase());
      paramIndex++;
    }
    
    // Add year filter if provided
    if (year) {
      whereClause += ` AND year = $${paramIndex}`;
      queryParams.push(parseInt(year));
      paramIndex++;
    }
    
    // Add search filter if provided
    if (search && search.trim()) {
      const searchPattern = `%${search.trim().toUpperCase()}%`;
      whereClause += ` AND (
        UPPER(customername) LIKE $${paramIndex} OR
        UPPER(countryname) LIKE $${paramIndex} OR
        UPPER(productgroup) LIKE $${paramIndex} OR
        UPPER(salesrepname) LIKE $${paramIndex} OR
        UPPER(material) LIKE $${paramIndex}
      )`;
      queryParams.push(searchPattern);
    }
    
    const summaryQuery = `
      SELECT 
        values_type,
        COUNT(*) as record_count,
        SUM(values) as total_values,
        AVG(values) as avg_values,
        MIN(values) as min_values,
        MAX(values) as max_values
      FROM public.fp_data_excel
      ${whereClause}
      GROUP BY values_type
      ORDER BY values_type
    `;
    
    const result = await pool.query(summaryQuery, queryParams);
    
    res.json({
      success: true,
      summary: result.rows
    });
    
  } catch (error) {
    console.error('âŒ Error fetching year summary:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET FILTER OPTIONS ENDPOINT (all unique values for column filters)
// ============================================================================

/**
 * GET /api/aebf/filter-options
 * Get all unique values for each filterable column
 * Returns an object with arrays of unique values for each column
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 */
router.get('/filter-options', async (req, res) => {
  try {
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Get distinct values for each filterable column
    const filterOptionsQuery = `
      SELECT 
        ARRAY_AGG(DISTINCT year ORDER BY year) FILTER (WHERE year IS NOT NULL) as years,
        ARRAY_AGG(DISTINCT month ORDER BY month) FILTER (WHERE month IS NOT NULL) as months,
        ARRAY_AGG(DISTINCT salesrepname ORDER BY salesrepname) FILTER (WHERE salesrepname IS NOT NULL) as salesreps,
        ARRAY_AGG(DISTINCT customername ORDER BY customername) FILTER (WHERE customername IS NOT NULL) as customers,
        ARRAY_AGG(DISTINCT countryname ORDER BY countryname) FILTER (WHERE countryname IS NOT NULL) as countries,
        ARRAY_AGG(DISTINCT productgroup ORDER BY productgroup) FILTER (WHERE productgroup IS NOT NULL) as productgroups,
        ARRAY_AGG(DISTINCT material ORDER BY material) FILTER (WHERE material IS NOT NULL) as materials,
        ARRAY_AGG(DISTINCT values_type ORDER BY values_type) FILTER (WHERE values_type IS NOT NULL) as valuetypes
      FROM public.fp_data_excel
      WHERE ${whereClause}
    `;
    
    const result = await pool.query(filterOptionsQuery, params);
    const row = result.rows[0];
    
    // Format response
    const filterOptions = {
      year: row.years || [],
      month: row.months || [],
      salesrepname: row.salesreps || [],
      customername: row.customers || [],
      countryname: row.countries || [],
      productgroup: row.productgroups || [],
      material: row.materials || [],
      values_type: row.valuetypes || []
    };
    
    res.json({
      success: true,
      filterOptions
    });
    
  } catch (error) {
    console.error('âŒ Error fetching filter options:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET DISTINCT VALUES ENDPOINT (for dropdowns/filters)
// ============================================================================

/**
 * GET /api/aebf/distinct/:field
 * Get distinct values for a specific field (for filter dropdowns)
 * 
 * URL Parameters:
 * - field: Field name (salesrepname, customername, countryname, productgroup, year, month)
 * 
 * Query Parameters:
 * - division: Filter by division (FP, SB, TF, HCM) - REQUIRED
 * - type: Filter by type (Actual, Budget, Estimate, Forecast) - optional
 * 
 * Returns array of distinct values
 */
router.get('/distinct/:field', async (req, res) => {
  try {
    const { field } = req.params;
    const { division, type } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Validate field name to prevent SQL injection
    const validFields = ['salesrepname', 'customername', 'countryname', 'productgroup', 'year', 'month', 'values_type', 'material', 'process'];
    if (!validFields.includes(field)) {
      return res.status(400).json({
        success: false,
        error: `Invalid field. Must be one of: ${validFields.join(', ')}`
      });
    }
    
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    
    if (type) {
      conditions.push("UPPER(type) = $2");
      params.push(type.toUpperCase());
    }
    
    const whereClause = conditions.join(' AND ');
    
    const distinctQuery = `
      SELECT DISTINCT ${field}
      FROM public.fp_data_excel
      WHERE ${whereClause} AND ${field} IS NOT NULL
      ORDER BY ${field}
    `;
    
    const result = await pool.query(distinctQuery, params);
    
    res.json({
      success: true,
      field,
      values: result.rows.map(row => row[field])
    });
    
  } catch (error) {
    console.error('âŒ Error fetching distinct values:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// GET EXPORT DATA ENDPOINT (for CSV/Excel export)
// ============================================================================

/**
 * GET /api/aebf/export
 * Export data in CSV format (same filters as /actual endpoint)
 * 
 * Query Parameters: Same as /actual endpoint
 * Returns: CSV formatted data
 */
router.get('/export', async (req, res) => {
  try {
    const {
      division,
      year,
      month,
      values_type,
      salesrepname,
      customername,
      countryname,
      productgroup,
      sortBy = 'year',
      sortOrder = 'desc',
      search,
      types // Add types parameter
    } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division parameter is required'
      });
    }
    
    const validDivisions = ['FP', 'SB', 'TF', 'HCM'];
    if (!validDivisions.includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: `Invalid division. Must be one of: ${validDivisions.join(', ')}`
      });
    }
    
    // Build WHERE clause (same logic as /actual)
    const conditions = ['UPPER(division) = $1'];
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    // Handle type or types parameter
    if (types) {
      // Multiple types: "Actual,Estimate"
      const typeArray = types.split(',').map(t => t.trim().toUpperCase());
      const typePlaceholders = typeArray.map((_, idx) => `$${paramIndex + idx}`).join(', ');
      conditions.push(`UPPER(type) IN (${typePlaceholders})`);
      params.push(...typeArray);
      paramIndex += typeArray.length;
    } else {
      // Default to Actual only for backward compatibility
      conditions.push("UPPER(type) = 'ACTUAL'");
    }
    
    if (year) {
      conditions.push(`year = $${paramIndex}`);
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      conditions.push(`month = $${paramIndex}`);
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (values_type) {
      conditions.push(`UPPER(values_type) = $${paramIndex}`);
      params.push(values_type.toUpperCase());
      paramIndex++;
    }
    
    if (salesrepname) {
      conditions.push(`UPPER(salesrepname) = $${paramIndex}`);
      params.push(salesrepname.toUpperCase());
      paramIndex++;
    }
    
    if (customername) {
      conditions.push(`UPPER(customername) LIKE $${paramIndex}`);
      params.push(`%${customername.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (countryname) {
      conditions.push(`UPPER(countryname) = $${paramIndex}`);
      params.push(countryname.toUpperCase());
      paramIndex++;
    }
    
    if (productgroup) {
      conditions.push(`UPPER(productgroup) LIKE $${paramIndex}`);
      params.push(`%${productgroup.toUpperCase()}%`);
      paramIndex++;
    }
    
    if (search) {
      const searchUpper = search.toUpperCase().trim();
      const searchPattern = `%${searchUpper}%`;
      
      // Month name mapping (both full and abbreviated)
      const monthMap = {
        'JANUARY': 1, 'JAN': 1,
        'FEBRUARY': 2, 'FEB': 2,
        'MARCH': 3, 'MAR': 3,
        'APRIL': 4, 'APR': 4,
        'MAY': 5,
        'JUNE': 6, 'JUN': 6,
        'JULY': 7, 'JUL': 7,
        'AUGUST': 8, 'AUG': 8,
        'SEPTEMBER': 9, 'SEP': 9, 'SEPT': 9,
        'OCTOBER': 10, 'OCT': 10,
        'NOVEMBER': 11, 'NOV': 11,
        'DECEMBER': 12, 'DEC': 12
      };
      
      // Check if search term is a month name
      const monthNumber = monthMap[searchUpper];
      
      if (monthNumber) {
        // Search by month number
        conditions.push(`month = $${paramIndex}`);
        params.push(monthNumber);
      } else {
        // Regular text search
        conditions.push(`(
          UPPER(customername) LIKE $${paramIndex} OR 
          UPPER(countryname) LIKE $${paramIndex} OR 
          UPPER(productgroup) LIKE $${paramIndex} OR
          UPPER(salesrepname) LIKE $${paramIndex} OR
          UPPER(material) LIKE $${paramIndex}
        )`);
        params.push(searchPattern);
      }
      paramIndex++;
    }
    
    const whereClause = conditions.join(' AND ');
    
    // Build ORDER BY clause
    const validSortFields = ['year', 'month', 'values', 'customername', 'countryname', 'productgroup', 'salesrepname', 'values_type'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'year';
    const sortDirection = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';
    const orderByClause = `ORDER BY ${sortField} ${sortDirection}, id DESC`;
    
    // Limit export to 10000 records to prevent memory issues
    const exportQuery = `
      SELECT 
        division,
        year,
        month,
        type,
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        values_type,
        values,
        updated_at,
        uploaded_by,
        sourcesheet
      FROM public.fp_data_excel
      WHERE ${whereClause}
      ${orderByClause}
      LIMIT 10000
    `;
    
    const result = await pool.query(exportQuery, params);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No data found for export'
      });
    }
    
    // Convert to CSV
    const headers = Object.keys(result.rows[0]);
    const csvRows = [
      headers.join(','), // Header row
      ...result.rows.map(row => 
        headers.map(header => {
          const value = row[header];
          // Escape values with commas or quotes
          if (value === null || value === undefined) return '';
          const stringValue = String(value);
          if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
            return `"${stringValue.replace(/"/g, '""')}"`;
          }
          return stringValue;
        }).join(',')
      )
    ];
    
    const csv = csvRows.join('\n');
    
    // Generate filename with year, date, and time
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, ''); // YYYYMMDD
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, ''); // HHMMSS
    const dateTime = `${dateStr}-${timeStr}`;
    
    // Determine type label for filename
    let typeLabel = 'Data';
    if (types) {
      const typeArray = types.split(',').map(t => t.trim());
      if (typeArray.length === 1) {
        typeLabel = typeArray[0];
      } else {
        typeLabel = 'Multi';
      }
    }
    
    // Build filename: AEBF-{Type}-{Division}-{Year}-{DateTime}.csv
    let filename = `AEBF-${typeLabel}-${division.toUpperCase()}`;
    if (year) {
      filename += `-${year}`;
    }
    filename += `-${dateTime}.csv`;
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(csv);
    
  } catch (error) {
    console.error('âŒ Error exporting data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// POST UPLOAD ACTUAL DATA ENDPOINT
// ============================================================================

/**
 * POST /api/aebf/upload-actual
 * Handle Excel file upload and transform to SQL
 * Calls PowerShell script to process the upload
 * 
 * Form Data:
 * - file: Excel file (.xlsx)
 * - division: Division code (FP, SB, TF, HCM)
 * - uploadMode: upsert or replace
 * - uploadedBy: Username
 */
const multer = require('multer');
const { spawn } = require('child_process');

// Configure multer for file upload
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../../uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    cb(null, `aebf-upload-${timestamp}${ext}`);
  }
});

const upload = multer({
  storage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (ext !== '.xlsx' && ext !== '.xls') {
      return cb(new Error('Only Excel files are allowed'));
    }
    cb(null, true);
  },
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB max
  }
});

router.post('/upload-actual', upload.single('file'), async (req, res) => {
  try {
    const { division, uploadMode, uploadedBy } = req.body;
    const filePath = req.file.path;
    
    console.log('ðŸ“¤ Upload request received:', {
      division,
      uploadMode,
      uploadedBy,
      fileName: req.file.originalname,
      fileSize: req.file.size
    });
    
    // Validate parameters
    if (!division || !['FP', 'SB', 'TF', 'HCM'].includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid division parameter'
      });
    }
    
    if (!uploadMode || !['upsert', 'replace'].includes(uploadMode.toLowerCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid uploadMode parameter'
      });
    }
    
    if (!uploadedBy) {
      return res.status(400).json({
        success: false,
        error: 'uploadedBy parameter is required'
      });
    }
    
    // Path to PowerShell script
    const scriptPath = path.join(__dirname, '../../scripts/transform-actual-to-sql.ps1');
    
    if (!fs.existsSync(scriptPath)) {
      return res.status(500).json({
        success: false,
        error: 'Transform script not found'
      });
    }
    
    // Execute PowerShell script
    console.log('ðŸ”„ Executing PowerShell script...');
    
    const psArgs = [
      '-ExecutionPolicy', 'Bypass',
      '-File', scriptPath,
      '-ExcelPath', filePath,
      '-Division', division.toUpperCase(),
      '-UploadMode', uploadMode.toLowerCase(),
      '-UploadedBy', uploadedBy
    ];
    
    // Add selective year/month filter if provided
    if (req.body.selectiveMode === 'true' && req.body.selectedYearMonths) {
      const selectedYearMonths = JSON.parse(req.body.selectedYearMonths);
      psArgs.push('-SelectiveYearMonths', selectedYearMonths.join(','));
      console.log('ðŸ“… Selective mode enabled:', selectedYearMonths);
    }
    
    const psProcess = spawn('powershell.exe', psArgs);
    
    let stdout = '';
    let stderr = '';
    
    psProcess.stdout.on('data', (data) => {
      const output = data.toString();
      stdout += output;
      console.log(output);
    });
    
    psProcess.stderr.on('data', (data) => {
      const error = data.toString();
      stderr += error;
      console.error(error);
    });
    
    psProcess.on('close', (code) => {
      console.log(`PowerShell script exited with code ${code}`);
      
      // Clean up uploaded file
      try {
        fs.unlinkSync(filePath);
        console.log('âœ… Cleaned up uploaded file');
      } catch (err) {
        console.error('âš ï¸  Failed to clean up file:', err);
      }
      
      if (code === 0) {
        // Parse output for results
        const recordsMatch = stdout.match(/Total records processed: (\d+)/);
        const recordsAffected = recordsMatch ? parseInt(recordsMatch[1]) : 0;
        
        res.json({
          success: true,
          message: 'Upload completed successfully',
          division: division.toUpperCase(),
          uploadMode,
          uploadedBy,
          recordsAffected,
          output: stdout,
          logFile: stdout.match(/Log file: (.+)/)?.[1]
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'PowerShell script failed',
          details: stderr || stdout,
          exitCode: code
        });
      }
    });
    
    psProcess.on('error', (error) => {
      console.error('âŒ Failed to start PowerShell script:', error);
      
      // Clean up uploaded file
      try {
        fs.unlinkSync(filePath);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      res.status(500).json({
        success: false,
        error: 'Failed to execute transform script',
        details: error.message
      });
    });
    
  } catch (error) {
    console.error('âŒ Upload endpoint error:', error);
    
    // Clean up file if exists
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// BUDGET ENDPOINTS
// ============================================================================

/**
 * GET /api/aebf/budget
 * Retrieve Budget data for a specific division and year
 * 
 * Query params:
 * - division: Division code (required)
 * - year: Year (required)
 * - month: Month filter (optional)
 * - search: Global search term (optional)
 */
router.get('/budget', async (req, res) => {
  try {
    const { division, year, month, search, page, pageSize } = req.query;
    
    console.log('ðŸ“Š Get budget data request:', { division, year, month, search, page, pageSize });
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'Division is required'
      });
    }
    
    let query = `
      SELECT 
        id, division, type, year, month, customername, salesrepname, 
        countryname, productgroup, material, process, values_type, values,
        sourcesheet, created_at, updated_at, uploaded_by
      FROM fp_data_excel
      WHERE division = $1 AND type = 'Budget'
    `;
    const params = [division.toUpperCase()];
    let paramIndex = 2;
    
    if (year) {
      query += ` AND year = $${paramIndex}`;
      params.push(parseInt(year));
      paramIndex++;
    }
    
    if (month) {
      query += ` AND month = $${paramIndex}`;
      params.push(parseInt(month));
      paramIndex++;
    }
    
    if (search) {
      query += ` AND (
        LOWER(customername) LIKE $${paramIndex} OR
        LOWER(salesrepname) LIKE $${paramIndex} OR
        LOWER(countryname) LIKE $${paramIndex} OR
        LOWER(productgroup) LIKE $${paramIndex}
      )`;
      params.push(`%${search.toLowerCase()}%`);
      paramIndex++;
    }
    
    query += ' ORDER BY year DESC, month, customername';
    
    // Add pagination
    const currentPage = parseInt(page) || 1;
    const limit = parseInt(pageSize) || 50;
    const offset = (currentPage - 1) * limit;
    
    // Get total count
    const countQuery = query.replace(/SELECT[\s\S]+FROM/, 'SELECT COUNT(*) FROM');
    const countResult = await pool.query(countQuery, params);
    const totalRecords = parseInt(countResult.rows[0].count);
    
    // Add limit and offset
    query += ` LIMIT ${limit} OFFSET ${offset}`;
    
    const result = await pool.query(query, params);
    
    const summary = {
      totalAmount: result.rows.filter(r => r.values_type === 'AMOUNT').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      totalKgs: result.rows.filter(r => r.values_type === 'KGS').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      totalMorm: result.rows.filter(r => r.values_type === 'MORM').reduce((sum, row) => sum + (parseFloat(row.values) || 0), 0),
      recordCount: result.rows.length
    };
    
    console.log(`âœ… Found ${result.rows.length} budget records (page ${currentPage} of ${Math.ceil(totalRecords / limit)})`);
    
    res.json({
      success: true,
      data: result.rows,
      summary,
      pagination: {
        page: currentPage,
        pageSize: limit,
        total: totalRecords
      }
    });
    
  } catch (error) {
    console.error('âŒ Get budget error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/upload-budget
 * Handle Budget Excel file upload and transform to SQL
 */
router.post('/upload-budget', upload.single('file'), async (req, res) => {
  try {
    const { division, uploadMode, uploadedBy, selectedYearMonths } = req.body;
    const filePath = req.file.path;
    
    console.log('ðŸ“¤ Budget upload request received:', {
      division,
      uploadMode: uploadMode || 'replace',
      uploadedBy,
      selectedYearMonths,
      fileName: req.file.originalname,
      fileSize: req.file.size
    });
    
    if (!division || !['FP', 'SB', 'TF', 'HCM'].includes(division.toUpperCase())) {
      return res.status(400).json({
        success: false,
        error: 'Invalid division parameter'
      });
    }
    
    const mode = uploadMode ? uploadMode.toLowerCase() : 'replace';
    if (!['upsert', 'replace'].includes(mode)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid uploadMode parameter'
      });
    }
    
    if (!uploadedBy) {
      return res.status(400).json({
        success: false,
        error: 'uploadedBy parameter is required'
      });
    }
    
    const scriptPath = path.join(__dirname, '../../scripts/transform-budget-to-sql.ps1');
    
    if (!fs.existsSync(scriptPath)) {
      return res.status(500).json({
        success: false,
        error: 'Budget transform script not found'
      });
    }
    
    console.log('ðŸ”„ Executing Budget PowerShell script...');
    
    const psArgs = [
      '-ExecutionPolicy', 'Bypass',
      '-File', scriptPath,
      '-ExcelPath', filePath,
      '-Division', division.toUpperCase(),
      '-UploadMode', mode,
      '-UploadedBy', uploadedBy
    ];
    
    if (selectedYearMonths) {
      psArgs.push('-SelectiveYearMonths', selectedYearMonths);
    }
    
    const psProcess = spawn('powershell.exe', psArgs);
    
    let stdout = '';
    let stderr = '';
    
    psProcess.stdout.on('data', (data) => {
      const output = data.toString();
      stdout += output;
      console.log(output);
    });
    
    psProcess.stderr.on('data', (data) => {
      const output = data.toString();
      stderr += output;
      console.error(output);
    });
    
    psProcess.on('close', (code) => {
      try {
        fs.unlinkSync(filePath);
        console.log('ðŸ—‘ï¸ Cleaned up uploaded file');
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      if (code === 0) {
        console.log('âœ… Budget upload completed successfully');
        res.json({
          success: true,
          message: 'Budget data uploaded successfully',
          output: stdout,
          mode: mode
        });
      } else {
        console.error('âŒ Budget upload failed with exit code:', code);
        res.status(500).json({
          success: false,
          error: 'Budget upload failed',
          details: stderr || stdout,
          exitCode: code
        });
      }
    });
    
    psProcess.on('error', (error) => {
      console.error('âŒ PowerShell process error:', error);
      
      try {
        fs.unlinkSync(filePath);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
      
      res.status(500).json({
        success: false,
        error: 'Failed to execute budget transform script',
        details: error.message
      });
    });
    
  } catch (error) {
    console.error('âŒ Budget upload error:', error);
    
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// ANALYZE FILE ENDPOINT (preview year/month combinations)
// ============================================================================

/**
 * POST /api/aebf/analyze-file
 * Analyze Excel file to extract year/month combinations
 * Returns list of year/month with record counts
 */
router.post('/analyze-file', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded'
      });
    }
    
    const filePath = req.file.path;
    console.log('ðŸ“Š Analyzing file:', filePath);
    
    // Read Excel file
    const XLSX = require('xlsx');
    const workbook = XLSX.readFile(filePath);
    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
    const data = XLSX.utils.sheet_to_json(firstSheet);
    
    // Extract year/month combinations with counts
    const yearMonthMap = new Map();
    
    data.forEach(row => {
      if (row.year && row.month && row.customername) {
        const key = `${row.year}-${row.month}`;
        if (yearMonthMap.has(key)) {
          yearMonthMap.set(key, yearMonthMap.get(key) + 1);
        } else {
          yearMonthMap.set(key, 1);
        }
      }
    });
    
    // Convert to array and sort by year/month
    const yearMonths = Array.from(yearMonthMap.entries())
      .map(([key, count]) => {
        const [year, month] = key.split('-').map(Number);
        return { year, month, count };
      })
      .sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.month - b.month;
      });
    
    // Clean up uploaded file
    try {
      fs.unlinkSync(filePath);
    } catch (err) {
      console.error('Failed to clean up file:', err);
    }
    
    res.json({
      success: true,
      yearMonths,
      totalRecords: data.length,
      totalPeriods: yearMonths.length
    });
    
  } catch (error) {
    console.error('âŒ Analyze file error:', error);
    
    // Clean up file if exists
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to clean up file:', err);
      }
    }
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// ESTIMATE ENDPOINTS
// ============================================================================

/**
 * Get Available Actual Months
 * GET /api/aebf/available-months
 * Gets all distinct months with Actual data for a division and year
 * 
 * Query params:
 * - division: Division code (required)
 * - year: Year (required)
 * 
 * Response:
 * - months: Array of month numbers
 */
router.get('/available-months', async (req, res) => {
  const { division, year } = req.query;
  
  console.log('ðŸ“… Get available months request:', { division, year });
  
  // Validate required parameters
  if (!division || !year) {
    return res.status(400).json({
      success: false,
      error: 'Division and year are required'
    });
  }
  
  try {
    const query = `
      SELECT DISTINCT month
      FROM public.fp_data_excel
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const result = await pool.query(query, [division.toUpperCase(), parseInt(year)]);
    const months = result.rows.map(row => row.month);
    
    console.log(`âœ… Found ${months.length} Actual months:`, months);
    
    res.json({
      success: true,
      months
    });
    
  } catch (error) {
    console.error('âŒ Get available months error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Calculate Estimate
 * POST /api/aebf/calculate-estimate
 * Calculates estimates based on average of Actual data for base period months
 * 
 * Request body:
 * - division: Division code (required)
 * - year: Year for estimation (required)
 * - selectedMonths: Array of month numbers to estimate (required)
 * - createdBy: Username (required)
 * 
 * Response:
 * - estimates: Array of monthly aggregates (month, amount, kgs, morm, recordCount)
 * - basePeriodMonths: Months used for averaging
 * - estimatedMonths: Months being estimated
 */
router.post('/calculate-estimate', async (req, res) => {
  const { division, year, selectedMonths, createdBy } = req.body;
  
  console.log('ðŸ“Š Calculate estimate request:', { division, year, selectedMonths, createdBy });
  
  // Validate required parameters
  if (!division || !year || !selectedMonths || !Array.isArray(selectedMonths) || selectedMonths.length === 0) {
    return res.status(400).json({
      success: false,
      error: 'Division, year, and selectedMonths array are required'
    });
  }
  
  try {
    // Step 1: Get all available Actual months for the year
    const allMonthsQuery = `
      SELECT DISTINCT month
      FROM public.fp_data_excel
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const allMonthsResult = await pool.query(allMonthsQuery, [division.toUpperCase(), year]);
    const allActualMonths = allMonthsResult.rows.map(row => row.month);
    
    console.log('ðŸ“… All Actual months:', allActualMonths);
    
    // Step 2: Calculate base period (Actual months NOT in selectedMonths)
    const basePeriodMonths = allActualMonths.filter(m => !selectedMonths.includes(m));
    
    if (basePeriodMonths.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No base period months available for calculation. All Actual months are selected for estimation.'
      });
    }
    
    console.log('ðŸ“Š Base period months (for averaging):', basePeriodMonths);
    console.log('ðŸŽ¯ Estimate months:', selectedMonths);
    
    // Step 3: Calculate totals per values_type for base period, then divide by number of months
    // Using simple method: SUM(all values) / number of months
    const totalsQuery = `
      SELECT 
        values_type,
        SUM(values) as total_value,
        COUNT(*) as record_count
      FROM public.fp_data_excel
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ACTUAL' 
        AND year = $2 
        AND month = ANY($3)
      GROUP BY values_type
      ORDER BY values_type
    `;
    
    const totalsResult = await pool.query(totalsQuery, [
      division.toUpperCase(),
      year,
      basePeriodMonths
    ]);
    
    console.log(`âœ… Base period totals:`, totalsResult.rows);
    
    // Step 4: Calculate average per month by dividing total by number of base months
    // This is the simple Excel method: Total Ã· Months
    const monthlyAverages = {};
    totalsResult.rows.forEach(row => {
      const avgPerMonth = parseFloat(row.total_value) / basePeriodMonths.length;
      monthlyAverages[row.values_type] = {
        average: Math.round(avgPerMonth), // Round to integer
        totalRecords: parseInt(row.record_count)
      };
    });
    
    console.log('ðŸ“Š Monthly averages (Simple method - TotalÃ·Months):', monthlyAverages);
    
    // Step 5: Create estimates for each selected month
    const monthlyAggregates = [];
    
    for (const month of selectedMonths.sort((a, b) => a - b)) {
      monthlyAggregates.push({
        month,
        amount: monthlyAverages['AMOUNT']?.average || 0,
        kgs: monthlyAverages['KGS']?.average || 0,
        morm: monthlyAverages['MORM']?.average || 0,
        recordCount: Math.round((monthlyAverages['AMOUNT']?.totalRecords || 0) / basePeriodMonths.length)
      });
    }
    
    console.log('ðŸ“ˆ Monthly aggregates calculated:', monthlyAggregates);
    
    res.json({
      success: true,
      estimates: monthlyAggregates,
      basePeriodMonths,
      estimatedMonths: selectedMonths.sort((a, b) => a - b),
      baseMonthCount: basePeriodMonths.length
    });
    
  } catch (error) {
    console.error('âŒ Calculate estimate error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Save Estimate
 * POST /api/aebf/save-estimate
 * Saves approved estimates to database
 * 
 * Request body:
 * - division: Division code (required)
 * - year: Year (required)
 * - estimates: Object with month keys and {amount, kgs, morm} values (required)
 * - approvedBy: Username (required)
 * 
 * Response:
 * - recordsInserted: Number of records inserted
 * - months: Array of months saved
 */
router.post('/save-estimate', async (req, res) => {
  const { division, year, estimates, approvedBy } = req.body;
  
  console.log('ðŸ’¾ Save estimate request:', { division, year, estimateMonths: Object.keys(estimates), approvedBy });
  
  // Validate required parameters
  if (!division || !year || !estimates || typeof estimates !== 'object' || !approvedBy) {
    return res.status(400).json({
      success: false,
      error: 'Division, year, estimates object, and approvedBy are required'
    });
  }
  
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    const months = Object.keys(estimates).map(Number).sort((a, b) => a - b);
    console.log('ðŸ“… Saving estimates for months:', months);
    
    // Step 1: Get dimension details from base period
    const basePeriodQuery = `
      SELECT DISTINCT month
      FROM public.fp_data_excel
      WHERE UPPER(division) = $1 AND UPPER(type) = 'ACTUAL' AND year = $2
      ORDER BY month
    `;
    
    const basePeriodResult = await client.query(basePeriodQuery, [division.toUpperCase(), year]);
    const allActualMonths = basePeriodResult.rows.map(row => row.month);
    const basePeriodMonths = allActualMonths.filter(m => !months.includes(m));
    
    if (basePeriodMonths.length === 0) {
      throw new Error('No base period months available');
    }
    
    console.log('ðŸ“Š Base period months:', basePeriodMonths);
    
    // Step 2: Get each dimension's PROPORTION of the total
    // We need the proportion, not the absolute values
    const dimensionQuery = `
      SELECT 
        salesrepname,
        customername,
        countryname,
        productgroup,
        material,
        process,
        sourcesheet,
        values_type,
        SUM(values) as total_value
      FROM public.fp_data_excel
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ACTUAL' 
        AND year = $2 
        AND month = ANY($3)
      GROUP BY salesrepname, customername, countryname, productgroup, material, process, sourcesheet, values_type
    `;
    
    const dimensionResult = await client.query(dimensionQuery, [
      division.toUpperCase(),
      year,
      basePeriodMonths
    ]);
    
    console.log(`âœ… Found ${dimensionResult.rows.length} dimension combinations to replicate`);
    
    // Step 3: Delete existing estimates for these months
    const deleteQuery = `
      DELETE FROM public.fp_data_excel
      WHERE UPPER(division) = $1 
        AND UPPER(type) = 'ESTIMATE' 
        AND year = $2 
        AND month = ANY($3)
    `;
    
    const deleteResult = await client.query(deleteQuery, [
      division.toUpperCase(),
      year,
      months
    ]);
    
    console.log(`ðŸ—‘ï¸ Deleted ${deleteResult.rowCount} existing estimate records`);
    
    // Step 4: Calculate each dimension's proportion of the base period total
    // Then distribute the monthly estimate according to these proportions
    const totalsByType = {
      AMOUNT: 0,
      KGS: 0,
      MORM: 0
    };
    
    dimensionResult.rows.forEach(row => {
      const valuesType = row.values_type;
      if (totalsByType[valuesType] !== undefined) {
        totalsByType[valuesType] += parseFloat(row.total_value) || 0;
      }
    });
    
    console.log(`ðŸ“Š Base period totals by values_type:`, totalsByType);
    
    // Step 5: Insert estimate records with proportional distribution
    let totalInserted = 0;
    const batchSize = 500;
    
    for (const month of months) {
      const monthEstimates = estimates[month];
      const recordsForMonth = [];
      
      // For each dimension, calculate its proportion and apply to monthly estimate
      dimensionResult.rows.forEach(row => {
        const basePeriodTotal = totalsByType[row.values_type];
        const dimensionTotal = parseFloat(row.total_value) || 0;
        const monthlyEstimateTotal = row.values_type === 'AMOUNT' ? monthEstimates.amount :
                                     row.values_type === 'KGS' ? monthEstimates.kgs :
                                     monthEstimates.morm;
        
        // Calculate this dimension's share of the monthly estimate
        // proportion = dimension_total / base_period_total
        // dimension_monthly_value = monthly_estimate * proportion
        const proportion = basePeriodTotal > 0 ? dimensionTotal / basePeriodTotal : 0;
        const dimensionMonthlyValue = monthlyEstimateTotal * proportion;
        
        recordsForMonth.push({
          division: division.toUpperCase(),
          year,
          month,
          type: 'Estimate',
          salesrepname: row.salesrepname,
          customername: row.customername,
          countryname: row.countryname,
          productgroup: row.productgroup,
          material: row.material,
          process: row.process,
          sourcesheet: 'Calculated',
          values_type: row.values_type,
          values: dimensionMonthlyValue,
          uploaded_by: approvedBy
        });
      });
      
      // Insert in batches
      for (let i = 0; i < recordsForMonth.length; i += batchSize) {
        const batch = recordsForMonth.slice(i, i + batchSize);
        
        const insertQuery = `
          INSERT INTO public.fp_data_excel (
            division, year, month, type, salesrepname, customername, countryname,
            productgroup, material, process, sourcesheet, values_type, values, uploaded_by, updated_at
          ) VALUES ${batch.map((_, idx) => {
            const base = idx * 14;
            return `($${base + 1}, $${base + 2}, $${base + 3}, $${base + 4}, $${base + 5}, $${base + 6}, $${base + 7}, $${base + 8}, $${base + 9}, $${base + 10}, $${base + 11}, $${base + 12}, $${base + 13}, $${base + 14}, NOW())`;
          }).join(', ')}
        `;
        
        const insertValues = batch.flatMap(record => [
          record.division,
          record.year,
          record.month,
          record.type,
          record.salesrepname,
          record.customername,
          record.countryname,
          record.productgroup,
          record.material,
          record.process,
          record.sourcesheet,
          record.values_type,
          record.values,
          record.uploaded_by
        ]);
        
        const insertResult = await client.query(insertQuery, insertValues);
        totalInserted += insertResult.rowCount;
      }
      
      console.log(`âœ… Inserted ${recordsForMonth.length} records for month ${month}`);
    }
    
    await client.query('COMMIT');
    
    console.log(`âœ… Total inserted: ${totalInserted} estimate records`);
    
    res.json({
      success: true,
      recordsInserted: totalInserted,
      months,
      message: `Successfully saved estimates for ${months.length} months`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Save estimate error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  } finally {
    client.release();
  }
});

// ============================================================================
// HTML BUDGET FORM ENDPOINTS
// ============================================================================

// Track if indexes have been created (one-time check)
let htmlBudgetIndexesCreated = false;

/**
 * Ensure HTML budget indexes exist (automatic, one-time)
 */
async function ensureHtmlBudgetIndexes() {
  if (htmlBudgetIndexesCreated) return;
  
  try {
    // Create indexes if they don't exist
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_fp_html_budget_customers 
      ON public.fp_data_excel(division, year, type, salesrepname, customername, countryname, productgroup, month) 
      WHERE type = 'Actual' AND values_type = 'KGS';
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_fp_budget_insert 
      ON public.fp_data_excel(division, year, month, type, salesrepname, customername, countryname, productgroup, values_type)
      WHERE type = 'Budget';
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_fp_actual_sales_rep_customer 
      ON public.fp_data_excel(division, year, type, salesrepname, customername, countryname, productgroup, month, values_type)
      WHERE type = 'Actual' AND customername IS NOT NULL AND TRIM(customername) != '';
    `);
    
    // Analyze table to update statistics
    await pool.query('ANALYZE public.fp_data_excel;');
    
    htmlBudgetIndexesCreated = true;
    console.log('âœ… HTML Budget indexes created/verified');
  } catch (error) {
    console.error('âš ï¸ Error creating HTML budget indexes (will retry):', error.message);
    // Don't throw - allow query to proceed even if index creation fails
  }
}

/**
 * POST /api/aebf/html-budget-customers-all
 * Get customer Actual sales data for ALL sales reps combined
 * Similar to html-budget-customers but aggregates all sales reps together
 */
router.post('/html-budget-customers-all', async (req, res) => {
  // Ensure indexes exist (automatic, one-time)
  await ensureHtmlBudgetIndexes();
  
  try {
    const { division, actualYear, salesReps } = req.body;
    
    if (!division || !actualYear || !Array.isArray(salesReps) || salesReps.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and salesReps array are required'
      });
    }
    
    // Fetch merge rules for the division
    const mergeRules = await DivisionMergeRulesService.listRules(division);
    const activeMergeRules = mergeRules.filter(r => r.status === 'ACTIVE' && r.is_active === true);
    
    // Build mapping from original customer names (normalized) to merged customer names
    const norm = (s) => (s || '').toString().trim().toLowerCase();
    const customerMergeMap = new Map();
    
    activeMergeRules.forEach(rule => {
      const mergedName = rule.merged_customer_name;
      const originalCustomers = Array.isArray(rule.original_customers) 
        ? rule.original_customers 
        : (typeof rule.original_customers === 'string' 
            ? JSON.parse(rule.original_customers) 
            : []);
      
      originalCustomers.forEach(original => {
        const normalized = norm(original);
        customerMergeMap.set(normalized, mergedName);
      });
    });
    
    // Query Actual sales data for all sales reps
    const query = `
      SELECT 
        TRIM(salesrepname) as salesrep,
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value
      FROM public.fp_data_excel
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND TRIM(UPPER(salesrepname)) = ANY($3::text[])
        AND customername IS NOT NULL
        AND TRIM(customername) != ''
        AND countryname IS NOT NULL
        AND TRIM(countryname) != ''
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const result = await pool.query(query, [division, actualYear, salesReps]);
    
    // Transform to table structure with merge rules applied
    const customerMap = {};
    
    result.rows.forEach(row => {
      const normalizedCustomer = norm(row.customer);
      const displayCustomerName = customerMergeMap.get(normalizedCustomer) || row.customer;
      
      const key = `${row.salesrep}|${displayCustomerName}|${row.country}|${row.productgroup}`;
      if (!customerMap[key]) {
        customerMap[key] = {
          salesRep: row.salesrep,
          customer: displayCustomerName,
          country: row.country,
          productGroup: row.productgroup,
          monthlyActual: {},
        };
      }
      const existingValue = customerMap[key].monthlyActual[row.month] || 0;
      customerMap[key].monthlyActual[row.month] = existingValue + (parseFloat(row.mt_value) || 0);
    });
    
    const data = Object.values(customerMap).map(item => {
      const monthlyActual = {};
      for (let month = 1; month <= 12; month++) {
        monthlyActual[month] = item.monthlyActual[month] || 0;
      }
      return {
        ...item,
        monthlyActual,
      };
    });
    
    // Load budget data from sales_rep_budget for ALL sales reps
    const budgetYear = parseInt(actualYear) + 1;
    console.log(`ðŸ“Š Loading budget data for ALL sales reps / ${budgetYear}`);
    
    const budgetQuery = `
      SELECT 
        TRIM(salesrepname) as salesrep,
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(values) / 1000.0 as mt_value
      FROM sales_rep_budget
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(type) = 'BUDGET'
        AND UPPER(values_type) = 'KGS'
      GROUP BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(salesrepname), TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const budgetResult = await pool.query(budgetQuery, [division, budgetYear]);
    console.log(`âœ… Found ${budgetResult.rows.length} budget records (all sales reps)`);
    
    // Build budget map
    const budgetMap = {};
    const budgetOnlyCustomers = new Set();
    
    budgetResult.rows.forEach(row => {
      const key = `${row.customer}|${row.country}|${row.productgroup}|${row.month}`;
      budgetMap[key] = parseFloat(row.mt_value) || 0;
      
      const customerKey = `${row.salesrep}|${row.customer}|${row.country}|${row.productgroup}`;
      budgetOnlyCustomers.add(customerKey);
    });
    
    // Add budget-only customers
    budgetOnlyCustomers.forEach(customerKey => {
      const exists = data.some(item => {
        const itemKey = `${item.salesRep}|${item.customer}|${item.country}|${item.productGroup}`;
        return itemKey === customerKey;
      });
      
      if (!exists) {
        const [salesRep, customer, country, productGroup] = customerKey.split('|');
        const monthlyActual = {};
        for (let month = 1; month <= 12; month++) {
          monthlyActual[month] = 0;
        }
        data.push({
          salesRep,
          customer,
          country,
          productGroup,
          monthlyActual,
        });
      }
    });
    
    // Sort data
    data.sort((a, b) => {
      const repCompare = (a.salesRep || '').localeCompare(b.salesRep || '');
      if (repCompare !== 0) return repCompare;
      const nameCompare = a.customer.localeCompare(b.customer);
      if (nameCompare !== 0) return nameCompare;
      const countryCompare = a.country.localeCompare(b.country);
      if (countryCompare !== 0) return countryCompare;
      return a.productGroup.localeCompare(b.productGroup);
    });
    
    console.log(`ðŸ“Š Total rows in response: ${data.length} (all sales reps combined)`);
    
    res.json({
      success: true,
      data,
      budgetData: budgetMap,
      isAllSalesReps: true,
    });
    
  } catch (error) {
    console.error('âŒ Error fetching all sales reps budget customers:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/html-budget-customers
 * Get customer Actual sales data grouped by Customer + Country + Product Group
 * Returns monthly KGS totals converted to MT (divide by 1000)
 */
router.post('/html-budget-customers', async (req, res) => {
  // Ensure indexes exist (automatic, one-time)
  await ensureHtmlBudgetIndexes();
  
  try {
    const { division, actualYear, salesRep } = req.body;
    
    if (!division || !actualYear || !salesRep) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and salesRep are required'
      });
    }
    
    // Check if salesRep is a group
    const SALES_REP_CONFIG_FILE = path.join(__dirname, '..', 'data', 'sales-reps-config.json');
    let config = {};
    try {
      if (fs.existsSync(SALES_REP_CONFIG_FILE)) {
        config = JSON.parse(fs.readFileSync(SALES_REP_CONFIG_FILE, 'utf8'));
      }
    } catch (err) {
      console.error('Error loading sales rep config:', err);
    }
    
    const divisionConfig = config[division] || { groups: {} };
    const isGroup = divisionConfig.groups && divisionConfig.groups[salesRep];
    const salesRepsToQuery = isGroup 
      ? divisionConfig.groups[salesRep].map(r => r.toString().trim().toUpperCase())
      : [salesRep.toString().trim().toUpperCase()];
    
    if (salesRepsToQuery.length === 0) {
      return res.json({ success: true, data: [] });
    }
    
    // Fetch merge rules for the division
    const mergeRules = await DivisionMergeRulesService.listRules(division);
    const activeMergeRules = mergeRules.filter(r => r.status === 'ACTIVE' && r.is_active === true);
    
    // Build mapping from original customer names (normalized) to merged customer names
    const norm = (s) => (s || '').toString().trim().toLowerCase();
    const customerMergeMap = new Map();
    
    activeMergeRules.forEach(rule => {
      const mergedName = rule.merged_customer_name;
      const originalCustomers = Array.isArray(rule.original_customers) 
        ? rule.original_customers 
        : (typeof rule.original_customers === 'string' 
            ? JSON.parse(rule.original_customers) 
            : []);
      
      originalCustomers.forEach(original => {
        const normalized = norm(original);
        customerMergeMap.set(normalized, mergedName);
      });
    });
    
    // Query Actual sales data grouped by customer, country, product group, month
    // Exclude "Services Charges" product group
    const query = `
      SELECT 
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value
      FROM public.fp_data_excel
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND TRIM(UPPER(salesrepname)) = ANY($3::text[])
        AND customername IS NOT NULL
        AND TRIM(customername) != ''
        AND countryname IS NOT NULL
        AND TRIM(countryname) != ''
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
      ORDER BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const result = await pool.query(query, [division, actualYear, salesRepsToQuery]);
    
    // Transform to table structure: { customer, country, productGroup, monthlyActual: {1: mt, 2: mt, ...} }
    // Apply merge rules: use merged customer name if exists, otherwise use original
    const customerMap = {};
    
    result.rows.forEach(row => {
      // Check if this customer should be merged
      const normalizedCustomer = norm(row.customer);
      const displayCustomerName = customerMergeMap.get(normalizedCustomer) || row.customer;
      
      const key = `${displayCustomerName}|${row.country}|${row.productgroup}`;
      if (!customerMap[key]) {
        customerMap[key] = {
          customer: displayCustomerName,
          country: row.country,
          productGroup: row.productgroup,
          monthlyActual: {},
        };
      }
      // Sum values if multiple original customers map to same merged customer
      const existingValue = customerMap[key].monthlyActual[row.month] || 0;
      customerMap[key].monthlyActual[row.month] = existingValue + (parseFloat(row.mt_value) || 0);
    });
    
    // Convert to array and ensure all months are present (0 if no data)
    const data = Object.values(customerMap).map(item => {
      const monthlyActual = {};
      for (let month = 1; month <= 12; month++) {
        monthlyActual[month] = item.monthlyActual[month] || 0;
      }
      return {
        ...item,
        monthlyActual,
      };
    });
    
    // NOW LOAD BUDGET DATA FROM sales_rep_budget TABLE
    const budgetYear = parseInt(actualYear) + 1;
    console.log(`ðŸ“Š Loading budget data for ${division} / ${salesRep} / ${budgetYear}`);
    
    const budgetQuery = `
      SELECT 
        TRIM(customername) as customer,
        TRIM(countryname) as country,
        TRIM(productgroup) as productgroup,
        month,
        values / 1000.0 as mt_value
      FROM sales_rep_budget
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
        AND UPPER(type) = 'BUDGET'
        AND UPPER(values_type) = 'KGS'
      ORDER BY TRIM(customername), TRIM(countryname), TRIM(productgroup), month
    `;
    
    const budgetResult = await pool.query(budgetQuery, [division, budgetYear, salesRep]);
    console.log(`âœ… Found ${budgetResult.rows.length} budget records`);
    
    // Build budget map: { "customer|country|productGroup|month": value }
    const budgetMap = {};
    const budgetOnlyCustomers = new Set(); // Track customers that only exist in budget (not in actual sales)
    
    budgetResult.rows.forEach(row => {
      const key = `${row.customer}|${row.country}|${row.productgroup}|${row.month}`;
      budgetMap[key] = parseFloat(row.mt_value) || 0;
      
      // Track unique customer combinations that exist in budget (use lowercase productgroup from DB)
      const customerKey = `${row.customer}|${row.country}|${row.productgroup}`;
      budgetOnlyCustomers.add(customerKey);
    });
    
    // Add budget-only customers to the data array (customers with budget but no actual sales)
    // This ensures custom customers added by users appear in the table after refresh
    budgetOnlyCustomers.forEach(customerKey => {
      // Check if this customer already exists in the data array (from actual sales)
      // Note: Need to normalize case when comparing because actual rows use row.productGroup (from DB with original case)
      // but customerKey uses lowercase productgroup from budget query
      const exists = data.some(item => {
        const itemKey = `${item.customer}|${item.country}|${item.productGroup}`;
        return itemKey === customerKey;
      });
      
      if (!exists) {
        // This customer only exists in budget data, add them to the table
        const [customer, country, productGroup] = customerKey.split('|');
        const monthlyActual = {};
        for (let month = 1; month <= 12; month++) {
          monthlyActual[month] = 0; // No actual sales for this customer
        }
        data.push({
          customer,
          country,
          productGroup,
          monthlyActual,
        });
        console.log(`âž• Added budget-only customer to table: ${customer} (${country}) - ${productGroup}`);
      }
    });
    
    // Sort data to keep consistent order (customers with budget-only will appear mixed in)
    data.sort((a, b) => {
      const nameCompare = a.customer.localeCompare(b.customer);
      if (nameCompare !== 0) return nameCompare;
      const countryCompare = a.country.localeCompare(b.country);
      if (countryCompare !== 0) return countryCompare;
      return a.productGroup.localeCompare(b.productGroup);
    });
    
    // Query pricing data for Amount and MoRM calculations
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM product_group_pricing_rounding
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await pool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    console.log(`ðŸ“Š Total rows in response: ${data.length} (including budget-only customers)`);
    
    res.json({
      success: true,
      data,
      budgetData: budgetMap, // Add budget data to response
      pricingData: pricingMap, // Add pricing data for Amount/MoRM calculations
      pricingYear: pricingYear,
      salesRep: salesRep,
      isGroup: !!isGroup,
    });
    
  } catch (error) {
    console.error('âŒ Error fetching HTML budget customers:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/save-html-budget
 * Save budget data from HTML form to database
 * Converts MT back to KGS (multiply by 1000)
 */
router.post('/save-html-budget', async (req, res) => {
  // Ensure indexes exist (automatic, one-time)
  await ensureHtmlBudgetIndexes();
  
  const client = await pool.connect();
  
  try {
    const { division, budgetYear, salesRep, records } = req.body;
    
    if (!division || !budgetYear || !salesRep) {
      return res.status(400).json({
        success: false,
        error: 'division, budgetYear, and salesRep are required'
      });
    }
    
    await client.query('BEGIN');
    const result = await saveLiveSalesRepBudget(client, {
      division,
      budgetYear,
      salesRep,
      records
    });
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `Sales rep budget saved (${result.recordsProcessed} rows, ${result.recordsInserted.total} records inserted)`,
      ...result
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Save HTML budget error:', error);
    const statusCode = error.details ? 400 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
      details: error.details
    });
  } finally {
    client.release();
  }
});

/**
 * POST /api/aebf/export-html-budget-form
 * Generate standalone HTML form with pre-filled Actual data
 * Returns HTML file for download
 */
router.post('/export-html-budget-form', async (req, res) => {
  try {
    const { division, actualYear, salesRep, tableData, customRowsData, budgetData, mergedCustomers, countries, productGroups } = req.body;
    
    if (!division || !actualYear || !salesRep || !Array.isArray(tableData)) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, salesRep, and tableData are required'
      });
    }
    
    const customRows = Array.isArray(customRowsData) ? customRowsData : [];
    const budgetDataMap = budgetData || {};
    
    const budgetYear = parseInt(actualYear) + 1;
    
    // Query pricing data from database for Amount calculations
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price
      FROM product_group_pricing_rounding
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await pool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map (product group -> selling price)
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = parseFloat(row.selling_price) || 0;
    });
    
    console.log(`ðŸ“Š Export: Loaded ${pricingResult.rows.length} pricing entries for ${division} year ${pricingYear}`);
    
    // Calculate monthly totals
    const monthlyActualTotals = {};
    const monthlyBudgetTotals = {};
    const monthlyActualAmountTotals = {};
    const monthlyBudgetAmountTotals = {};
    for (let month = 1; month <= 12; month++) {
      monthlyActualTotals[month] = 0;
      monthlyBudgetTotals[month] = 0;
      monthlyActualAmountTotals[month] = 0;
      monthlyBudgetAmountTotals[month] = 0;
    }
    
    // Calculate actual totals from tableData (MT and Amount)
    tableData.forEach(row => {
      const productGroup = (row.productGroup || '').toLowerCase();
      const sellingPrice = pricingMap[productGroup] || 0;
      
      for (let month = 1; month <= 12; month++) {
        const mtValue = row.monthlyActual?.[month] || 0;
        monthlyActualTotals[month] += mtValue;
        // Amount = MT * 1000 * sellingPrice (MT is in tons, convert to kg then multiply by price)
        monthlyActualAmountTotals[month] += mtValue * 1000 * sellingPrice;
      }
    });
    
    // Calculate budget totals from budgetData
    // First, create a map of budget values by product group + month for Amount calculation
    const budgetByProductGroupMonth = {};
    Object.keys(budgetDataMap).forEach(key => {
      let month, productGroup;
      if (key.startsWith('custom_')) {
        const parts = key.split('_');
        month = parseInt(parts[parts.length - 1], 10);
        // For custom rows, we need to find the product group from customRows
        const customId = parts[1];
        const customRow = customRows.find(r => r.id === parseInt(customId) || r.id === customId);
        productGroup = customRow?.productGroup || '';
      } else {
        const parts = key.split('|');
        month = parseInt(parts[parts.length - 1], 10);
        productGroup = parts[2] || ''; // customer|country|productGroup|month
      }
      if (month >= 1 && month <= 12) {
        const value = budgetDataMap[key];
        const num = parseFloat((value || '').toString().replace(/,/g, '')) || 0;
        if (!isNaN(num)) {
          monthlyBudgetTotals[month] += num;
          
          // Calculate Amount for budget
          const pgLower = (productGroup || '').toLowerCase();
          const sellingPrice = pricingMap[pgLower] || 0;
          monthlyBudgetAmountTotals[month] += num * 1000 * sellingPrice;
        }
      }
    });
    
    // Prepare data for JavaScript
    const mergedCustomersList = Array.isArray(mergedCustomers) && mergedCustomers.length > 0 
      ? mergedCustomers 
      : [...new Set(tableData.map(r => r.customer))].sort();
    const countriesList = Array.isArray(countries) ? countries : [];
    const productGroupsList = Array.isArray(productGroups) ? productGroups : [];
    
    // Generate HTML
    const html = `<!DOCTYPE html>
<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=SALES_REP_BUDGET :: DO_NOT_EDIT_THIS_LINE -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Planning - ${division} - ${salesRep} - ${actualYear}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; display: flex; flex-direction: column; }
    .header { background: #fff; padding: 20px; margin-bottom: 20px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; }
    .header h1 { margin-bottom: 10px; color: #333; }
    .header-info { display: flex; gap: 30px; flex-wrap: wrap; }
    .header-info div { font-size: 14px; color: #666; }
    .header-info strong { color: #333; }
    .table-container {
      background: #fff;
      padding: 0;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
      flex: 1;
      min-height: 0;
      height: calc(100vh - 200px);
      overflow-x: auto;
      overflow-y: auto;
    }
    table { 
      width: 100%; 
      border-collapse: separate; 
      border-spacing: 0; 
      font-size: 12px; 
      table-layout: fixed; 
    }
    thead th.legend-header {
      position: -webkit-sticky !important;
      position: sticky !important;
      top: 0 !important;
      z-index: 1002 !important;
      background: #fff !important;
      padding: 12px 24px !important;
      border-bottom: 1px solid #e8e8e8 !important;
      text-align: left !important;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .legend-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    .legend { display: flex; gap: 24px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; }
    .legend-color { display: inline-block; width: 16px; height: 16px; border: 1px solid; }
    .legend-actual { background-color: #e6f4ff; border-color: #99c8ff; }
    .legend-budget { background-color: #FFFFB8; border-color: #d4b106; }
    .add-row-btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .add-row-btn:hover { background: #4096ff; }
    thead tr.header-row {
      position: -webkit-sticky;
      position: sticky;
      top: 49px;
      z-index: 1001;
      background: #fff;
    }
    thead th.column-header {
      background-color: #1677ff;
      color: #fff;
      padding: 8px;
      border: 1px solid #fff;
      text-align: center;
      min-width: 0;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    thead th.column-header.sticky-col {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 1003;
      background-color: #1677ff;
    }
    tbody td { 
      padding: 8px; 
      border: 1px solid #ddd; 
    }
    tbody td:nth-child(1) {
      background-color: #fff;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 5;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.actual-row td:nth-child(1) {
      background-color: #fff;
    }
    tbody tr.budget-row td:nth-child(1) {
      background-color: #fff;
    }
    tbody tr.custom-row td:nth-child(1) {
      background-color: #fff;
      padding: 8px;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.custom-row td:nth-child(1) .customer-cell {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    tbody tr.custom-row td:nth-child(1) .customer-cell span {
      flex: 1;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.custom-row td:nth-child(1) .new-customer-input {
      font-weight: 600;
    }
    tbody tr.actual-row td:nth-child(2),
    tbody tr.actual-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody tr.budget-row td:nth-child(2),
    tbody tr.budget-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody tr.custom-row td:nth-child(2),
    tbody tr.custom-row td:nth-child(3) {
      background-color: #fff;
    }
    tbody td:nth-child(2), tbody td:nth-child(3) { 
      background-color: #fff; 
      white-space: normal; 
      word-break: break-word; 
      line-height: 1.3; 
    }
    tbody tr.actual-row { background-color: #e6f4ff; }
    tbody tr.actual-row td:nth-child(n+4) { 
      background-color: #e6f4ff; 
      text-align: right; 
      font-weight: 500; 
      padding: 6px 8px; 
    }
    tbody tr.budget-row { background-color: #FFFFB8; }
    tbody tr.budget-row td { 
      background-color: #FFFFB8 !important; 
      padding: 2px; 
    }
    tbody tr.custom-row { background-color: #FFFFB8; }
    tbody tr.custom-row td:nth-child(2), tbody tr.custom-row td:nth-child(3) { 
      padding: 4px; 
    }
    tbody tr.custom-row td:nth-child(n+4) { 
      background-color: #FFFFB8 !important; 
      padding: 2px; 
    }
    tbody input { 
      width: 100%; 
      border: none; 
      padding: 4px 6px; 
      text-align: right; 
      font-size: 12px; 
      font-weight: 500; 
      background-color: transparent !important; 
      box-shadow: none; 
    }
    tbody tr.budget-row input,
    tbody tr.custom-row input.custom-input {
      background-color: transparent !important;
    }
    tbody input:focus { outline: none; }
    tbody input:disabled { background-color: #f5f5f5 !important; cursor: not-allowed; }
    tbody select { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
    tbody select option { padding: 4px; }
    tbody select option:hover { background-color: #e6f4ff; }
    tbody .delete-btn { 
      background: #ff4d4f; 
      color: #fff; 
      border: none; 
      padding: 2px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 12px; 
      margin-left: 4px; 
    }
    tbody .delete-btn:hover { background: #ff7875; }
    tfoot tr.actual-total {
      background-color: #cce4ff;
    }
    tfoot tr.actual-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #cce4ff;
      text-align: right;
      font-weight: 700;
    }
    tfoot tr.actual-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #cce4ff;
    }
    tfoot tr.actual-year-total {
      background-color: #90CAF9;
    }
    tfoot tr.actual-year-total td {
      padding: 8px;
      border: 1px solid #ddd;
      background-color: #90CAF9;
      text-align: right;
      font-weight: 700;
    }
    tfoot tr.actual-year-total td:first-child {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #90CAF9;
    }
    tfoot tr.budget-total {
      background-color: #FFFFB8;
    }
    tfoot tr.budget-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #FFFFB8;
      text-align: right;
      font-weight: 700;
    }
    tfoot tr.budget-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFFFB8;
    }
    tfoot tr.budget-year-total {
      background-color: #FFEB3B;
    }
    tfoot tr.budget-year-total td {
      padding: 8px;
      border: 1px solid #ddd;
      background-color: #FFEB3B;
      font-weight: 700;
    }
    tfoot tr.budget-year-total td:first-child {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFEB3B;
    }
    tfoot tr.budget-year-total td:last-child {
      text-align: center;
      font-size: 14px;
      background-color: #FFEB3B;
    }
    .btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .btn:hover { background: #4096ff; }
    .btn:disabled { background: #ccc; cursor: not-allowed; }
    .customer-cell {
      display: flex;
      align-items: center;
      gap: 4px;
      width: 100%;
    }
    .customer-cell select {
      flex: 1;
    }
    .new-customer-input {
      flex: 1;
      padding: 4px 6px;
      border: 1px solid #d9d9d9;
      border-radius: 4px;
      font-size: 12px;
    }
    .recap-container {
      background: #e6f7ff;
      border: 2px solid #1890ff;
      border-radius: 8px;
      padding: 16px 24px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .recap-title {
      font-size: 16px;
      font-weight: 700;
      color: #1890ff;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .recap-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }
    .recap-stat {
      background: #fff;
      padding: 12px 16px;
      border-radius: 4px;
      border-left: 4px solid #1890ff;
    }
    .recap-stat-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
    }
    .recap-stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #1890ff;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Budget Planning Form - ${division}</h1>
    <div class="header-info">
      <div><strong>Division:</strong> ${division}</div>
      <div><strong>Sales Rep:</strong> ${salesRep}</div>
      <div><strong>Actual Year:</strong> ${actualYear}</div>
      <div><strong>Budget Year:</strong> ${budgetYear}</div>
    </div>
  </div>
  
  <div id="recapContainer" class="recap-container" style="display: none;">
    <div class="recap-title">
      ðŸ“Š Budget Summary
    </div>
    <div class="recap-stats">
      <div class="recap-stat">
        <div class="recap-stat-label">Total Customers</div>
        <div class="recap-stat-value" id="recapCustomers">0</div>
      </div>
      <div class="recap-stat">
        <div class="recap-stat-label">Total MT (Volume)</div>
        <div class="recap-stat-value" id="recapTotalMT">0.00</div>
      </div>
      <div class="recap-stat">
        <div class="recap-stat-label">Months with Data</div>
        <div class="recap-stat-value" id="recapMonths">0</div>
      </div>
    </div>
  </div>
  
  <div class="table-container">
    <table>
      <colgroup>
        <col style="width: 14%;" />
        <col style="width: 9%;" />
        <col style="width: 13%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 4.5%;" />
        <col style="width: 8%;" />
      </colgroup>
      <thead>
        <tr>
          <th colspan="16" class="legend-header">
            <div class="legend-container">
              <div class="legend">
                <div class="legend-item">
                  <span class="legend-color legend-actual"></span>
                  <span>Actual ${actualYear} Volume (MT)</span>
                </div>
                <div class="legend-item">
                  <span class="legend-color legend-budget"></span>
                  <span>Budget ${budgetYear} Volume (MT)</span>
                </div>
                <div class="legend-item">
                  <span class="legend-color" style="background-color: #d4edda; border-color: #28a745;"></span>
                  <span>Actual ${actualYear} Amount</span>
                </div>
                <div class="legend-item">
                  <span class="legend-color" style="background-color: #fff3cd; border-color: #ffc107;"></span>
                  <span>Budget ${budgetYear} Amount</span>
                </div>
              </div>
              <div style="display: flex; gap: 8px;">
                <button class="add-row-btn" id="addRowBtn">+ Add New Row</button>
                <button class="btn" id="saveDraftBtn" style="background: #1677ff; padding: 4px 15px; font-size: 12px;">ðŸ’¾ Save Draft</button>
                <button class="btn" id="saveFinalBtn" style="background: #52c41a; padding: 4px 15px; font-size: 12px;">âœ“ Save Final</button>
              </div>
              <div style="margin-top: 8px; font-size: 11px; color: #8c8c8c;">
                ðŸ’¡ <strong>Tip:</strong> Use "Save Draft" to save your work and continue later. Use "Save Final" when ready to submit.
              </div>
            </div>
          </th>
        </tr>
        <tr class="header-row">
          <th rowspan="2" class="column-header sticky-col">Customer Name</th>
          <th rowspan="2" class="column-header" style="width: 10%;">Country Name</th>
          <th rowspan="2" class="column-header" style="width: 15%;">Product Group</th>
          ${Array.from({ length: 12 }, (_, i) => '<th class="column-header" style="width: 5%;">' + (i + 1) + '</th>').join('')}
          <th rowspan="2" class="column-header" style="background-color: #0958d9; width: 8%; font-weight: 700;">Total</th>
        </tr>
      </thead>
      <tbody id="tableBody">
        ${tableData.map((row, idx) => {
          // Calculate actual total for this row
          let actualRowTotal = 0;
          const actualCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const value = row.monthlyActual?.[month] || 0;
            actualRowTotal += value;
            const formatted = value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('');
          
          // Calculate budget total for this row
          let budgetRowTotal = 0;
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const key = row.customer + '|' + row.country + '|' + row.productGroup + '|' + month;
            const preFilledValue = budgetDataMap[key] || '';
            if (preFilledValue) {
              budgetRowTotal += parseFloat(preFilledValue.toString().replace(/,/g, '')) || 0;
            }
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-customer="' + row.customer.replace(/"/g, '&quot;') + '" ' +
              'data-country="' + row.country.replace(/"/g, '&quot;') + '" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              '/>' +
            '</td>';
          }).join('');
          
          return '<tr class="actual-row">' +
            '<td rowspan="2">' + row.customer + '</td>' +
            '<td rowspan="2">' + row.country + '</td>' +
            '<td rowspan="2">' + row.productGroup + '</td>' +
            actualCells +
            '<td style="background-color: #cce4ff; text-align: right; font-weight: 700;">' + actualRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>' +
          '<tr class="budget-row">' +
            budgetCells +
            '<td class="budget-row-total" style="background-color: #FFEB3B; text-align: right; font-weight: 700;">' + budgetRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>';
        }).join('')}
        ${customRows.map((row, idx) => {
          let customRowTotal = 0;
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            let preFilledValue = '';
            if (row.id) {
              const key = 'custom_' + row.id + '_' + month;
              preFilledValue = budgetDataMap[key] || '';
            }
            if (!preFilledValue) {
              const fallbackKey = row.customer + '|' + row.country + '|' + row.productGroup + '|' + month;
              preFilledValue = budgetDataMap[fallbackKey] || '';
            }
            if (preFilledValue) {
              customRowTotal += parseFloat(preFilledValue.toString().replace(/,/g, '')) || 0;
            }
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-customer="' + row.customer.replace(/"/g, '&quot;') + '" ' +
              'data-country="' + row.country.replace(/"/g, '&quot;') + '" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              'class="custom-input" ' +
              '/>' +
            '</td>';
          }).join('');
          
          const showInput = row.isNewCustomer && !row.customer;
          const hasCustomer = row.customer && row.customer.trim();
          
          const customerCellContent = hasCustomer ? (
            '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + row.customer.replace(/"/g, '&quot;') + '</span>' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">Ã—</button>'
          ) : (
            '<select class="customer-select" style="flex: 1; ' + (showInput ? 'display:none;' : '') + '">' +
              '<option value="">Select customer</option>' +
              '<option value="__NEW__" style="font-style: italic; color: #1890ff;">+ Add New Customer</option>' +
              mergedCustomersList.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '"' + (c === row.customer ? ' selected' : '') + '>' + c + '</option>').join('') +
            '</select>' +
            '<input type="text" class="new-customer-input" placeholder="Enter new customer name" value="' + (showInput && row.customer ? row.customer.replace(/"/g, '&quot;') : '') + '" style="flex: 1; font-weight: 600; ' + (showInput ? 'display:block;' : 'display:none;') + '" />' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">Ã—</button>'
          );
          
          const countryOptions = countriesList.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '"' + (c === row.country ? ' selected' : '') + '>' + c + '</option>').join('');
          const productGroupOptions = productGroupsList.map(pg => '<option value="' + pg.replace(/"/g, '&quot;') + '"' + (pg === row.productGroup ? ' selected' : '') + '>' + pg + '</option>').join('');
          
          return '<tr class="custom-row" data-row-id="' + (row.id || idx) + '">' +
            '<td style="padding: 8px; border: 1px solid #ddd; background-color: #fff; position: sticky; left: 0; z-index: 5; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' +
              '<div class="customer-cell" style="display: flex; align-items: center; gap: 4px;">' +
                customerCellContent +
              '</div>' +
            '</td>' +
            '<td>' +
              '<select class="country-select" style="width: 100%;"' + (!row.isNewCustomer ? ' disabled' : '') + '>' +
                '<option value="">Select country</option>' +
                countryOptions +
              '</select>' +
            '</td>' +
            '<td>' +
              '<select class="product-group-select" style="width: 100%;">' +
                '<option value="">Select product group</option>' +
                productGroupOptions +
              '</select>' +
            '</td>' +
            budgetCells +
            '<td class="custom-row-total" style="background-color: #FFEB3B; text-align: right; font-weight: 700;">' + customRowTotal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</td>' +
          '</tr>';
        }).join('')}
      </tbody>
      <tfoot>
        <tr class="actual-total">
          <td colSpan="3">Total Actual (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #90CAF9; text-align: right; font-weight: 700;">${Object.values(monthlyActualTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="budget-total">
          <td colSpan="3">Total Budget (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return '<td>' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #FFEB3B; text-align: right; font-weight: 700;" id="budgetYearTotal">${Object.values(monthlyBudgetTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
        <tr class="actual-amount-total">
          <td colSpan="3" style="background-color: #d4edda; font-weight: 700;">Total Actual (Amount)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td style="background-color: #d4edda; text-align: right; font-weight: 700;">' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #c3e6cb; text-align: right; font-weight: 700;">
            ${(() => {
              const total = Object.values(monthlyActualAmountTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>
        <tr class="budget-amount-total">
          <td colSpan="3" style="background-color: #fff3cd; font-weight: 700;">Total Budget (Amount)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetAmountTotals[month] || 0;
            const formatted = total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                              total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                              total.toFixed(0);
            return '<td style="background-color: #fff3cd; text-align: right; font-weight: 700;">' + formatted + '</td>';
          }).join('')}
          <td style="background-color: #ffeeba; text-align: right; font-weight: 700;" id="budgetAmountYearTotal">
            ${(() => {
              const total = Object.values(monthlyBudgetAmountTotals).reduce((sum, val) => sum + val, 0);
              return total >= 1000000 ? (total / 1000000).toFixed(1) + 'M' : 
                     total >= 1000 ? (total / 1000).toFixed(1) + 'K' : 
                     total.toFixed(0);
            })()}
          </td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script>
    const formData = {
      division: '${division}',
      salesRep: '\${salesRep.replace(/'/g, "\\\\'")}',
      actualYear: ${actualYear},
      budgetYear: ${budgetYear},
    };
    
    const mergedCustomers = ${JSON.stringify(mergedCustomersList)};
    const countries = ${JSON.stringify(countriesList)};
    const productGroups = ${JSON.stringify(productGroupsList)};
    const pricingMap = ${JSON.stringify(pricingMap)};
    let customRowCounter = ${customRows.length > 0 && customRows.some(r => r.id) ? Math.max(...customRows.filter(r => r.id).map(r => r.id)) + 1 : Date.now()};
    
    // Helper to format Amount values with K/M suffix
    function formatAmount(value) {
      if (!value || value === 0) return '0';
      if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
      if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
      return value.toFixed(0);
    }
    
    // Make dropdowns searchable - filter options as user types
    function makeSelectSearchable(selectElement) {
      if (!selectElement || selectElement.dataset.searchable === 'true') return;
      selectElement.dataset.searchable = 'true';
      
      selectElement.addEventListener('keydown', function(e) {
        // Only handle alphanumeric keys
        if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
          const searchTerm = e.key.toLowerCase();
          const options = Array.from(this.options);
          
          // Find first option that starts with the typed character
          for (let i = 0; i < options.length; i++) {
            if (options[i].text.toLowerCase().startsWith(searchTerm)) {
              this.selectedIndex = i;
              this.dispatchEvent(new Event('change'));
              e.preventDefault();
              break;
            }
          }
        }
      });
      
      // Add input event for continuous search (requires contenteditable hack)
      let searchBuffer = '';
      let searchTimeout;
      
      selectElement.addEventListener('keypress', function(e) {
        if (e.key.length === 1) {
          searchBuffer += e.key.toLowerCase();
          clearTimeout(searchTimeout);
          
          const options = Array.from(this.options);
          for (let i = 0; i < options.length; i++) {
            if (options[i].text.toLowerCase().includes(searchBuffer)) {
              this.selectedIndex = i;
              break;
            }
          }
          
          searchTimeout = setTimeout(() => {
            searchBuffer = '';
          }, 1000);
        }
      });
    }
    
    function formatMT(value) {
      if (!value && value !== 0) return '';
      const num = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value;
      if (isNaN(num)) return '';
      return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    function recalculateTotals() {
      const actualTotals = Array.from({ length: 12 }, () => 0);
      const budgetTotals = Array.from({ length: 12 }, () => 0);
      const budgetAmountTotals = Array.from({ length: 12 }, () => 0);
      
      // Calculate actual totals - cells start from 4th child (columns 1-3 are customer/country/group)
      // Skip the last cell in each row (the Total column)
      document.querySelectorAll('tr.actual-row').forEach(row => {
        const cells = row.querySelectorAll('td:nth-child(n+4):not(:last-child)');
        cells.forEach((cell, idx) => {
          const val = parseFloat(cell.textContent.replace(/,/g, '')) || 0;
          if (idx < 12) actualTotals[idx] += val;
        });
      });
      
      // Calculate budget totals - use month from dataset directly as array index (1-12 maps to 0-11)
      // Also calculate budget Amount using pricing data
      document.querySelectorAll('input:not([disabled])').forEach(input => {
        const month = parseInt(input.dataset.month);
        const val = parseFloat(input.value.replace(/,/g, '')) || 0;
        const productGroup = (input.dataset.group || '').toLowerCase();
        const sellingPrice = pricingMap[productGroup] || 0;
        
        if (month >= 1 && month <= 12 && !isNaN(val)) {
          budgetTotals[month - 1] += val;
          // Amount = MT * 1000 * sellingPrice
          budgetAmountTotals[month - 1] += val * 1000 * sellingPrice;
        }
      });
      
      // Also update individual budget row totals
      document.querySelectorAll('tr.budget-row').forEach(row => {
        const inputs = row.querySelectorAll('input');
        let rowTotal = 0;
        inputs.forEach(input => {
          const val = parseFloat(input.value.replace(/,/g, '')) || 0;
          rowTotal += val;
        });
        const totalCell = row.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(rowTotal);
        }
      });
      
      // Update total cells in footer
      // Footer rows have: <td colspan="3">Label</td> + 12 month cells + 1 Total cell
      // Select the 12 month cells (not first and not last)
      const actualTotalRow = document.querySelector('tfoot tr.actual-total');
      const budgetTotalRow = document.querySelector('tfoot tr.budget-total');
      const budgetAmountRow = document.querySelector('tfoot tr.budget-amount-total');
      
      if (actualTotalRow) {
        const cells = actualTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatMT(actualTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = actualTotalRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(actualTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      if (budgetTotalRow) {
        const cells = budgetTotalRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatMT(budgetTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = budgetTotalRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatMT(budgetTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      if (budgetAmountRow) {
        const cells = budgetAmountRow.querySelectorAll('td:not(:first-child):not(:last-child)');
        cells.forEach((cell, idx) => {
          if (idx < 12) cell.textContent = formatAmount(budgetAmountTotals[idx]);
        });
        // Update the Total cell (last cell)
        const totalCell = budgetAmountRow.querySelector('td:last-child');
        if (totalCell) {
          totalCell.textContent = formatAmount(budgetAmountTotals.reduce((sum, val) => sum + val, 0));
        }
      }
      
      // Also update id-based elements for compatibility
      const yearTotalCell = document.getElementById('budgetYearTotal');
      if (yearTotalCell) {
        yearTotalCell.textContent = formatMT(budgetTotals.reduce((sum, val) => sum + val, 0));
      }
      
      const amountYearTotalCell = document.getElementById('budgetAmountYearTotal');
      if (amountYearTotalCell) {
        amountYearTotalCell.textContent = formatAmount(budgetAmountTotals.reduce((sum, val) => sum + val, 0));
      }
    }
    
    function addCustomRow() {
      const rowId = customRowCounter++;
      const tbody = document.getElementById('tableBody');
      
      const budgetCells = Array.from({ length: 12 }, (_, i) => {
        const month = i + 1;
        return '<td><input type="text" data-customer="" data-country="" data-group="" data-month="' + month + '" placeholder="0" class="custom-input" disabled /></td>';
      }).join('');
      
      const customerOptions = mergedCustomers.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '">' + c + '</option>').join('');
      const countryOptions = countries.map(c => '<option value="' + c.replace(/"/g, '&quot;') + '">' + c + '</option>').join('');
      const productGroupOptions = productGroups.map(pg => '<option value="' + pg.replace(/"/g, '&quot;') + '">' + pg + '</option>').join('');
      
      const newRow = document.createElement('tr');
      newRow.className = 'custom-row';
      newRow.setAttribute('data-row-id', rowId);
      newRow.innerHTML = '<td style="padding: 8px; border: 1px solid #ddd; background-color: #fff; position: sticky; left: 0; z-index: 5; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' +
        '<div class="customer-cell" style="display: flex; align-items: center; gap: 4px;">' +
        '<select class="customer-select" style="flex: 1;">' +
        '<option value="">Select customer</option>' +
        '<option value="__NEW__" style="font-style: italic; color: #1890ff;">+ Add New Customer</option>' +
        customerOptions +
        '</select>' +
        '<input type="text" class="new-customer-input" placeholder="Enter new customer name" style="flex: 1; font-weight: 600; display:none;" />' +
        '<button class="delete-btn" onclick="removeCustomRow(this)">Ã—</button>' +
        '</div>' +
        '</td>' +
        '<td>' +
        '<select class="country-select" style="width: 100%;">' +
        '<option value="">Select country</option>' +
        countryOptions +
        '</select>' +
        '</td>' +
        '<td>' +
        '<select class="product-group-select" style="width: 100%;">' +
        '<option value="">Select product group</option>' +
        productGroupOptions +
        '</select>' +
        '</td>' +
        budgetCells;

      tbody.appendChild(newRow);
      attachRowListeners(newRow);
    }
    
    function removeCustomRow(btn) {
      const row = btn.closest('tr.custom-row');
      if (row && confirm('Remove this row?')) {
        row.remove();
        recalculateTotals();
      }
    }
    
    function attachRowListeners(row) {
      const customerSelect = row.querySelector('.customer-select');
      const customerInput = row.querySelector('.new-customer-input');
      const countrySelect = row.querySelector('.country-select');
      const productGroupSelect = row.querySelector('.product-group-select');
      const inputs = row.querySelectorAll('input.custom-input');
      
      // Make dropdowns searchable
      if (customerSelect) makeSelectSearchable(customerSelect);
      if (countrySelect) makeSelectSearchable(countrySelect);
      if (productGroupSelect) makeSelectSearchable(productGroupSelect);
      
      const showCustomerInput = () => {
        if (customerInput) {
          customerInput.style.display = 'inline-block';
          customerInput.value = '';
          customerInput.focus();
        }
        customerSelect.style.display = 'none';
      };
      
      const showCustomerSelect = () => {
        customerSelect.style.display = 'inline-block';
        if (customerInput) {
          customerInput.style.display = 'none';
        }
      };
      
      const applyCustomerSelection = (customer) => {
        inputs.forEach(input => {
          input.dataset.customer = customer || '';
        });
        
        if (customer) {
          const actualRow = Array.from(document.querySelectorAll('tr.actual-row')).find(actual => {
            const cell = actual.querySelector('td:first-child');
            return cell && cell.textContent.trim() === customer;
          });
          
          if (actualRow) {
            const countryCell = actualRow.querySelector('td:nth-child(2)');
            if (countryCell) {
              const countryName = countryCell.textContent.trim();
              countrySelect.value = countryName;
              countrySelect.disabled = true;
              inputs.forEach(input => {
                input.dataset.country = countryName;
              });
            }
          } else {
            countrySelect.disabled = false;
          }
        } else {
          countrySelect.disabled = false;
          countrySelect.value = '';
          inputs.forEach(input => {
            input.dataset.country = '';
          });
        }
        
        updateInputStates(row);
        recalculateTotals();
      };
      
      const saveNewCustomer = () => {
        if (!customerInput) return;
        const newCustomerName = customerInput.value.trim();
        
        if (!newCustomerName) {
          showCustomerSelect();
          customerSelect.value = '';
          applyCustomerSelection('');
          return;
        }
        
        // Replace select/input with plain text span matching other customer names
        const customerCell = row.querySelector('.customer-cell');
        customerCell.innerHTML = '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + newCustomerName.replace(/"/g, '&quot;') + '</span>' +
          '<button class="delete-btn" onclick="removeCustomRow(this)">Ã—</button>';
        
        countrySelect.disabled = false;
        countrySelect.value = '';
        inputs.forEach(input => {
          input.dataset.customer = newCustomerName;
          input.dataset.country = '';
        });
        updateInputStates(row);
        recalculateTotals();
      };
      
      const showCustomerAsText = (customerName) => {
        const customerCell = row.querySelector('.customer-cell');
        if (customerCell && customerName) {
          customerCell.innerHTML = '<span style="flex: 1; font-weight: 600; white-space: normal; word-break: break-word; line-height: 1.3;">' + customerName.replace(/"/g, '&quot;') + '</span>' +
            '<button class="delete-btn" onclick="removeCustomRow(this)">Ã—</button>';
        }
      };
      
      customerSelect.addEventListener('change', function() {
        const customer = this.value;
        if (customer === '__NEW__') {
          this.value = '';
          showCustomerInput();
          inputs.forEach(input => {
            input.dataset.customer = '';
            input.dataset.country = '';
          });
          countrySelect.disabled = false;
          countrySelect.value = '';
          updateInputStates(row);
          return;
        }
        
        if (customer) {
          // Replace select with plain text span matching other customer names
          showCustomerAsText(customer);
        } else {
          showCustomerSelect();
        }
        applyCustomerSelection(customer);
        recalculateTotals();
      });
      
      if (customerInput) {
        customerInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveNewCustomer();
          }
        });
        
        customerInput.addEventListener('blur', function() {
          saveNewCustomer();
        });
        
        // Update input states as user types new customer name
        customerInput.addEventListener('input', function() {
          updateInputStates(row);
        });
        
        if (customerInput.style.display !== 'none') {
          customerInput.focus();
        }
      }
      
      countrySelect.addEventListener('change', function() {
        const country = this.value;
        inputs.forEach(input => {
          input.dataset.country = country || '';
        });
        updateInputStates(row);
      });
      
      productGroupSelect.addEventListener('change', function() {
        const productGroup = this.value;
        inputs.forEach(input => {
          input.dataset.group = productGroup || '';
        });
        updateInputStates(row);
      });
      
      inputs.forEach(input => {
        input.addEventListener('focus', function() {
          // Show notification if trying to enter value without complete info
          if (this.disabled) {
            const customer = this.dataset.customer || '';
            const country = this.dataset.country || '';
            const productGroup = this.dataset.group || '';
            
            const missing = [];
            if (!customer) missing.push('Customer Name');
            if (!country) missing.push('Country');
            if (!productGroup) missing.push('Product Group');
            
            if (missing.length > 0) {
              alert('âš ï¸ Please fill in the following before entering budget values:\\n\\n' + missing.join('\\n'));
              this.blur();
            }
          }
        });
        
        input.addEventListener('blur', function() {
          const val = this.value;
          if (val) {
            this.value = formatMT(val);
          }
          recalculateTotals();
        });
        
        input.addEventListener('input', function() {
          this.value = this.value.replace(/[^0-9.,]/g, '');
          recalculateTotals();
        });
      });
      
      // Set initial state
      updateInputStates(row);
    }
    
    function updateInputStates(row) {
      // Query fresh from DOM each time to handle dynamic changes
      const customerSelect = row.querySelector('.customer-select');
      const customerInput = row.querySelector('.new-customer-input');
      const customerSpan = row.querySelector('.customer-cell span:not(.delete-btn)');
      const countrySelect = row.querySelector('.country-select');
      const productGroupSelect = row.querySelector('.product-group-select');
      const inputs = row.querySelectorAll('input.custom-input');
      
      // Get customer value from select, input field, or span text
      let customer = '';
      if (customerSelect && customerSelect.value && customerSelect.value !== '__NEW__') {
        customer = customerSelect.value;
      } else if (customerInput && customerInput.style.display !== 'none' && customerInput.value.trim()) {
        // User is typing new customer name in input field
        customer = customerInput.value.trim();
      } else if (customerSpan) {
        // Customer name already confirmed and shown as span
        customer = customerSpan.textContent.trim();
      }
      
      const country = countrySelect ? countrySelect.value : '';
      const productGroup = productGroupSelect ? productGroupSelect.value : '';
      
      const isComplete = customer && country && productGroup;
      
      console.log('updateInputStates:', { customer, country, productGroup, isComplete, customerInput: customerInput?.value });
      
      // Disable country and product group until customer is selected
      if (countrySelect && countrySelect.disabled === false) {
        // Only disable if not already disabled by other logic (e.g., existing customer auto-fill)
        const hasCustomer = !!customer;
        if (!hasCustomer && !countrySelect.dataset.keepEnabled) {
          countrySelect.disabled = true;
        } else if (hasCustomer) {
          countrySelect.disabled = false;
        }
      }
      
      if (productGroupSelect) {
        const hasCustomer = !!customer;
        productGroupSelect.disabled = !hasCustomer;
      }
      
      inputs.forEach(input => {
        input.disabled = !isComplete;
        // Update dataset with customer value
        if (customer) {
          input.dataset.customer = customer;
        }
      });
    }
    
    document.querySelectorAll('tr.custom-row').forEach(row => {
      attachRowListeners(row);
    });
    
    document.querySelectorAll('input:not(.custom-input)').forEach(input => {
      input.addEventListener('blur', function() {
        const val = this.value;
        if (val) {
          this.value = formatMT(val);
        }
        recalculateTotals();
      });
      
      input.addEventListener('input', function() {
        this.value = this.value.replace(/[^0-9.,]/g, '');
        recalculateTotals();
      });
    });
    
    document.getElementById('addRowBtn').addEventListener('click', addCustomRow);
    
    // Function to calculate and display recap summary
    function showRecapSummary() {
      const allInputs = document.querySelectorAll('input[data-month]');
      const customerSet = new Set();
      const monthSet = new Set();
      let totalMT = 0;
      
      allInputs.forEach(input => {
        const value = parseFloat(input.value?.replace(/,/g, '')) || 0;
        if (value > 0) {
          const customer = input.dataset.customer;
          const month = input.dataset.month;
          
          if (customer) customerSet.add(customer);
          if (month) monthSet.add(month);
          
          totalMT += value;
        }
      });
      
      if (customerSet.size > 0 || totalMT > 0) {
        document.getElementById('recapCustomers').textContent = customerSet.size;
        document.getElementById('recapTotalMT').textContent = totalMT.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        document.getElementById('recapMonths').textContent = monthSet.size;
        document.getElementById('recapContainer').style.display = 'block';
      } else {
        document.getElementById('recapContainer').style.display = 'none';
      }
    }
    
    // Show recap on page load and after any input change
    recalculateTotals();
    showRecapSummary();
    
    // Update recap when inputs change
    document.querySelectorAll('input[data-month]').forEach(input => {
      input.addEventListener('input', function() {
        setTimeout(showRecapSummary, 100);
      });
      input.addEventListener('blur', function() {
        showRecapSummary();
      });
    });
    
    // Save Draft Button - keeps form editable
    document.getElementById('saveDraftBtn').addEventListener('click', function() {
      // Recalculate totals first
      recalculateTotals();
      
      // Clone the entire document AS-IS (keep everything editable)
      const clonedDoc = document.cloneNode(true);
      
      // Add draft metadata (for identification)
      const draftMetadata = {
        isDraft: true,
        division: formData.division,
        salesRep: formData.salesRep,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'budget_draft'
      };
      
      // Embed draft metadata
      const draftScript = clonedDoc.createElement('script');
      draftScript.id = 'draftMetadata';
      draftScript.textContent = '/* DRAFT METADATA */\\n' +
        'const draftMetadata = ' + JSON.stringify(draftMetadata, null, 2) + ';';
      clonedDoc.body.appendChild(draftScript);
      
      // Get HTML content
      const htmlContent = '<!DOCTYPE html>\\n' + clonedDoc.documentElement.outerHTML;
      
      // Generate dynamic filename with DRAFT prefix
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      // Format: DRAFT_Division_SalesRep_BudgetYear_YYYYMMDD_HHMMSS.html
      const filename = 'DRAFT_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.salesRep.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      // Trigger download
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('âœ… Draft saved!\\n\\nYou can open this file later to continue editing.\\n\\nFilename: ' + filename + '\\n\\nðŸ’¡ This is a DRAFT file - it cannot be uploaded to the system.\\nUse "Save Final" when ready to submit.');
    });
    
    // Save Final Button - creates static HTML for upload
    document.getElementById('saveFinalBtn').addEventListener('click', function() {
      // Validate: Check if any budget data is entered
      const budgetInputs = document.querySelectorAll('input:not([disabled])[data-month]');
      const hasData = Array.from(budgetInputs).some(input => {
        const val = input.value.replace(/,/g, '');
        return val && parseFloat(val) > 0;
      });
      
      if (!hasData) {
        alert('âš ï¸ No budget data entered!\\n\\nPlease enter at least one budget value before saving final version.');
        return;
      }
      
      // Confirm finalization
      if (!confirm('ðŸ“‹ Finalize Budget?\\n\\nThis will create a final version that:\\nâ€¢ Cannot be edited\\nâ€¢ Can be uploaded to the system\\nâ€¢ Will calculate Amount and MoRM values\\n\\nDo you want to proceed?')) {
        return;
      }
      
      // Recalculate totals first
      recalculateTotals();
      
      // Clone the document
      const clonedDoc = document.cloneNode(true);
      
      // Replace all budget inputs with hardcoded text
      clonedDoc.querySelectorAll('input[data-month]').forEach(input => {
        const value = input.value || '0';
        const td = input.parentElement;
        td.innerHTML = value;
        td.style.textAlign = 'right';
        td.style.fontWeight = '500';
        td.style.padding = '6px 8px';
      });
      
      // Remove all interactive elements (buttons, selects)
      clonedDoc.querySelectorAll('.delete-btn').forEach(btn => btn.remove());
      clonedDoc.querySelectorAll('select').forEach(select => {
        const value = select.options[select.selectedIndex]?.text || '';
        select.outerHTML = '<span>' + value + '</span>';
      });
      clonedDoc.querySelectorAll('.new-customer-input').forEach(input => input.remove());
      
      // Remove Add Row button
      const addBtn = clonedDoc.getElementById('addRowBtn');
      if (addBtn) addBtn.remove();
      
      // Remove Save Draft and Save Final buttons
      const saveDraftBtn = clonedDoc.getElementById('saveDraftBtn');
      if (saveDraftBtn) saveDraftBtn.remove();
      const saveFinalBtn = clonedDoc.getElementById('saveFinalBtn');
      if (saveFinalBtn) saveFinalBtn.remove();
      
      // Remove the tip message div (specific selector to avoid removing parent containers)
      const allDivs = clonedDoc.querySelectorAll('div');
      allDivs.forEach(div => {
        // Only remove if this div directly contains the tip text and has the specific styling
        const hasMarginTop = div.style.marginTop === '8px' || div.getAttribute('style')?.includes('margin-top: 8px');
        const hasTipText = div.innerHTML && div.innerHTML.includes('ðŸ’¡ <strong>Tip:</strong>');
        if (hasMarginTop && hasTipText) {
          div.remove();
        }
      });
      
      // Remove all scripts to make it static
      clonedDoc.querySelectorAll('script').forEach(script => {
        if (!script.id || script.id !== 'savedBudgetData') {
          script.remove();
        }
      });
      
      // Collect budget data for backend
      const budgetData = [];
      document.querySelectorAll('input:not([disabled])[data-month]').forEach(input => {
        const val = input.value.replace(/,/g, '');
        if (val && parseFloat(val) > 0) {
          budgetData.push({
            customer: input.dataset.customer,
            country: input.dataset.country,
            productGroup: input.dataset.group,
            month: parseInt(input.dataset.month),
            value: parseFloat(val) * 1000
          });
        }
      });
      
      // Add metadata and saved data as script for easy database import
      const metadata = {
        division: formData.division,
        salesRep: formData.salesRep,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'budget_import'
      };
      
      const savedDataScript = clonedDoc.createElement('script');
      savedDataScript.id = 'savedBudgetData';
      savedDataScript.textContent = 
        '/* BUDGET DATA FOR DATABASE IMPORT */\\n' +
        'const budgetMetadata = ' + JSON.stringify(metadata, null, 2) + ';\\n' +
        'const savedBudget = ' + JSON.stringify(budgetData, null, 2) + ';';
      clonedDoc.body.appendChild(savedDataScript);
      
      // Get HTML content
      const htmlContent = '<!DOCTYPE html>\\n' + clonedDoc.documentElement.outerHTML;
      
      // Generate dynamic filename with budget year, date, and time
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      // Format: BUDGET_Division_SalesRep_BudgetYear_YYYYMMDD_HHMMSS.html
      const filename = 'BUDGET_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.salesRep.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      // Trigger download
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('âœ… Final budget saved!\\n\\nFilename: ' + filename + '\\n\\nThis file is ready for upload to the system.\\n\\nðŸ“¤ Next step: Upload this file in the Budget Tab.');
    });
  </script>
</body>
</html>`;
    
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('Content-Disposition', `attachment; filename="Budget_${division}_${salesRep.replace(/\s+/g, '_')}_${actualYear}.html"`);
    res.send(html);
    
  } catch (error) {
    console.error('âŒ Error exporting HTML budget form:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// IMPORT FILLED BUDGET HTML
// ============================================================================

/**
 * POST /api/aebf/import-budget-html
 * Import filled budget data from saved HTML file
 * Expects HTML file upload with embedded budget data
 */
router.post('/import-budget-html', async (req, res) => {
  console.log('ðŸ“¥ Import budget HTML request received');
  try {
    const htmlContent = req.body.htmlContent;
    
    if (!htmlContent) {
      console.error('âŒ No HTML content provided');
      return res.status(400).json({
        success: false,
        error: 'No HTML content provided'
      });
    }
    
    console.log('âœ… HTML content received, length:', htmlContent.length);
    
    // ============================================================================
    // VALIDATION STEP 0: File Signature Check
    // ============================================================================
    
    // Check for IPD Budget System signature (validates this is a genuine export)
    const signaturePattern = /<!--\s*IPD_BUDGET_SYSTEM_v[\d.]+\s*::\s*TYPE=(SALES_REP_BUDGET|DIVISIONAL_BUDGET)\s*::/;
    const signatureMatch = htmlContent.match(signaturePattern);
    
    if (!signatureMatch) {
      // Allow legacy files without signature but log warning
      console.warn('âš ï¸ File missing IPD Budget System signature - may be legacy or modified file');
    } else if (signatureMatch[1] !== 'SALES_REP_BUDGET') {
      console.error('âŒ Wrong file type: expected SALES_REP_BUDGET, got', signatureMatch[1]);
      return res.status(400).json({
        success: false,
        error: 'Wrong file type. This appears to be a Divisional Budget file. Please use the Divisional Budget import instead.'
      });
    } else {
      console.log('âœ… Valid IPD Budget System signature detected');
    }
    
    // ============================================================================
    // VALIDATION STEP 1: Extract and Parse Data
    // ============================================================================
    
    // Extract metadata and budget data from HTML
    // Prefer structured <script id="savedBudgetData"> where the exporter embeds JSON
    let metadata = null;
    let budgetData = null;

    try {
      const scriptTagMatch = htmlContent.match(/<script[^>]*id=["']savedBudgetData["'][^>]*>([\s\S]*?)<\/script>/i);
      if (scriptTagMatch && scriptTagMatch[1]) {
        const scriptContent = scriptTagMatch[1];

        // Improved JSON extraction - handle multi-line JSON properly
        const metaMatch = scriptContent.match(/const\s+budgetMetadata\s*=\s*(\{[\s\S]*?\});/);
        const dataMatch = scriptContent.match(/const\s+savedBudget\s*=\s*(\[[\s\S]*?\]);/);

        if (metaMatch && dataMatch) {
          try {
            metadata = JSON.parse(metaMatch[1]);
          } catch (e) {
            console.error('âŒ Failed to JSON.parse metadata from script tag:', e.message);
            return res.status(400).json({ success: false, error: 'Failed to parse budget metadata from file.' });
          }

          try {
            budgetData = JSON.parse(dataMatch[1]);
          } catch (e) {
            console.error('âŒ Failed to JSON.parse budget data from script tag:', e.message);
            return res.status(400).json({ success: false, error: 'Failed to parse budget data from file.' });
          }
        }
      }

      // Fallback: older files might not have script id, try previous regex approach limited to the whole HTML
      if (!metadata || !budgetData) {
        const metadataMatch = htmlContent.match(/const budgetMetadata = (\{[\s\S]*?\});/);
        const budgetDataMatch = htmlContent.match(/const savedBudget = (\[[\s\S]*?\]);/);
        if (metadataMatch && budgetDataMatch) {
          metadata = JSON.parse(metadataMatch[1]);
          budgetData = JSON.parse(budgetDataMatch[1]);
        }
      }

      if (!metadata || !budgetData) {
        console.error('âŒ Invalid HTML format - missing savedBudgetData script or metadata/savedBudget variables');
        return res.status(400).json({ success: false, error: 'Invalid HTML file format. Missing budget metadata or saved budget data. Please re-export using the in-app "Save Final" button.' });
      }

      console.log('âœ… Parsed metadata and budget data from HTML export');
      console.log('âœ… Metadata:', { division: metadata.division, salesRep: metadata.salesRep, budgetYear: metadata.budgetYear });
      console.log('âœ… Budget records count:', Array.isArray(budgetData) ? budgetData.length : 0);
    } catch (e) {
      console.error('âŒ Error extracting data from HTML:', e);
      return res.status(400).json({ success: false, error: 'Failed to extract budget data from file. Ensure the file was exported from the application using "Save Final".' });
    }
    
    // ============================================================================
    // Generate file hash for duplicate detection
    // ============================================================================
    const crypto = require('crypto');
    const fileHash = crypto.createHash('sha256').update(htmlContent).digest('hex').substring(0, 16);
    
    // ============================================================================
    // VALIDATION STEP 2: Check for Draft File
    // ============================================================================
    
    const draftCheck = htmlContent.match(/const draftMetadata = ({[^;]+});/);
    if (draftCheck) {
      try {
        const draftMeta = JSON.parse(draftCheck[1]);
        if (draftMeta.isDraft === true) {
          console.warn('âš ï¸ Draft file rejected');
          return res.status(400).json({
            success: false,
            error: 'âš ï¸ Cannot upload draft file!\n\nThis is a work-in-progress draft. Please open the file, complete your budget, and click "Save Final" before uploading.',
            isDraft: true
          });
        }
      } catch (e) {
        console.log('Draft check parse error (ignored):', e.message);
      }
    }
    
    // ============================================================================
    // VALIDATION STEP 3: Validate Metadata Structure
    // ============================================================================
    
    const validationErrors = [];
    
    if (!metadata.division || typeof metadata.division !== 'string') {
      validationErrors.push('Invalid or missing division');
    }
    
    if (!metadata.salesRep || typeof metadata.salesRep !== 'string') {
      validationErrors.push('Invalid or missing sales rep name');
    }
    
    if (!metadata.budgetYear || typeof metadata.budgetYear !== 'number' || metadata.budgetYear < 2020 || metadata.budgetYear > 2100) {
      validationErrors.push('Invalid or missing budget year (must be between 2020-2100)');
    }
    
    if (!metadata.version || metadata.version !== '1.0') {
      validationErrors.push('Unsupported file version. Please re-export from the system.');
    }
    
    if (!metadata.dataFormat || metadata.dataFormat !== 'budget_import') {
      validationErrors.push('Invalid data format. This file may not be a budget export.');
    }
    
    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'File validation failed:\n' + validationErrors.join('\n')
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 4: Validate Budget Data Structure
    // ============================================================================
    
    if (!Array.isArray(budgetData)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid budget data format. Expected an array of records.'
      });
    }
    
    if (budgetData.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No budget data found in file. The file appears to be empty.'
      });
    }
    
    if (budgetData.length > 10000) {
      return res.status(400).json({
        success: false,
        error: `Too many records (${budgetData.length}). Maximum allowed is 10,000.`
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 5: Validate Individual Records
    // ============================================================================
    
    const recordErrors = [];
    const validRecords = [];
    
    budgetData.forEach((record, index) => {
      const errors = [];
      
      // Check required fields
      if (!record.customer || typeof record.customer !== 'string' || record.customer.trim() === '') {
        errors.push('Missing or invalid customer name');
      }
      
      if (!record.country || typeof record.country !== 'string' || record.country.trim() === '') {
        errors.push('Missing or invalid country');
      }
      
      if (!record.productGroup || typeof record.productGroup !== 'string' || record.productGroup.trim() === '') {
        errors.push('Missing or invalid product group');
      }
      
      if (!record.month || typeof record.month !== 'number' || record.month < 1 || record.month > 12) {
        errors.push('Invalid month (must be 1-12)');
      }
      
      if (record.value === undefined || record.value === null) {
        errors.push('Missing value');
      } else if (typeof record.value !== 'number' || isNaN(record.value)) {
        errors.push('Invalid value (must be a number)');
      } else if (record.value < 0) {
        errors.push('Negative values not allowed');
      } else if (record.value === 0) {
        errors.push('Zero values not allowed');
      } else if (record.value > 1000000000) {
        errors.push('Value too large (max 1 billion KGS)');
      }
      
      if (errors.length > 0) {
        recordErrors.push({
          index: index + 1,
          customer: record.customer || 'Unknown',
          month: record.month || 'Unknown',
          errors: errors
        });
      } else {
        validRecords.push(record);
      }
    });
    
    // If more than 10% of records have errors, reject the file
    const errorRate = recordErrors.length / budgetData.length;
    if (errorRate > 0.1) {
      return res.status(400).json({
        success: false,
        error: `Too many invalid records (${recordErrors.length} out of ${budgetData.length}). Please check your file and try again.`,
        recordErrors: recordErrors.slice(0, 10), // Show first 10 errors
        totalErrors: recordErrors.length
      });
    }
    
    // If some records have errors, log them but continue with valid records
    if (recordErrors.length > 0) {
      console.warn(`âš ï¸ Skipping ${recordErrors.length} invalid records out of ${budgetData.length}`);
    }
    
    // Use only valid records
    budgetData = validRecords;
    
    console.log(`âœ… Validation passed: ${budgetData.length} valid records`);
    
    console.log('ðŸ“¥ Importing budget data:', {
      division: metadata.division,
      salesRep: metadata.salesRep,
      budgetYear: metadata.budgetYear,
      recordCount: budgetData.length,
      savedAt: metadata.savedAt
    });
    
    // Start transaction
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      
      // Check if budget already exists for this sales rep/division/year
      const existingCheckQuery = `
        SELECT 
          COUNT(*) as record_count,
          MAX(uploaded_at) as last_upload,
          MAX(uploaded_filename) as last_filename
        FROM sales_rep_budget
        WHERE UPPER(division) = UPPER($1)
        AND UPPER(salesrepname) = UPPER($2)
        AND budget_year = $3
        AND UPPER(type) = 'BUDGET'
      `;
      
      const existingCheck = await client.query(existingCheckQuery, [
        metadata.division,
        metadata.salesRep,
        metadata.budgetYear
      ]);
      
      const existingRecords = parseInt(existingCheck.rows[0].record_count);
      const lastUpload = existingCheck.rows[0].last_upload;
      const lastFilename = existingCheck.rows[0].last_filename;
      
      console.log(`ðŸ“‹ Existing budget check:`, {
        existingRecords,
        lastUpload,
        lastFilename
      });
      
      // Get division code for lookups
      const divisionCode = metadata.division.split('-')[0].toLowerCase(); // e.g., "FP-UAE" -> "fp"
      const materialPercentagesTable = `${divisionCode}_material_percentages`;
      
      // 1. Fetch material and process for all product groups
      const materialProcessQuery = `
        SELECT product_group, material, process 
        FROM ${materialPercentagesTable}
      `;
      const materialProcessResult = await client.query(materialProcessQuery);
      
      // Create lookup map: productGroup -> { material, process }
      const materialProcessMap = {};
      materialProcessResult.rows.forEach(row => {
        materialProcessMap[row.product_group.toLowerCase()] = {
          material: row.material || '',
          process: row.process || ''
        };
      });
      
      console.log('ðŸ“‹ Material/Process lookup map:', materialProcessMap);
      
      // 2. Fetch pricing data for previous year (budgetYear - 1)
      const pricingYear = metadata.budgetYear - 1;
      console.log(`ðŸ“Š Fetching pricing data for division: ${divisionCode}, year: ${pricingYear}`);
      
      let pricingResult;
      try {
        const pricingQuery = `
          SELECT product_group, asp_round, morm_round
          FROM product_group_pricing_rounding
          WHERE UPPER(division) = UPPER($1)
          AND year = $2
        `;
        pricingResult = await client.query(pricingQuery, [divisionCode, pricingYear]);
        console.log(`âœ… Found ${pricingResult.rows.length} pricing records`);
      } catch (pricingError) {
        console.error('âŒ Error querying pricing table:', pricingError);
        throw new Error(`Pricing table query failed: ${pricingError.message}. Please ensure the product_group_pricing_rounding table exists.`);
      }
      
      // Create lookup map: productGroup -> { sellingPrice, morm }
      const pricingMap = {};
      pricingResult.rows.forEach(row => {
        const aspRound = row.asp_round ? Math.round(parseFloat(row.asp_round)) : null;
        const mormRound = row.morm_round ? Math.round(parseFloat(row.morm_round)) : null;
        pricingMap[row.product_group.toLowerCase()] = {
          sellingPrice: aspRound,
          morm: mormRound
        };
      });
      
      console.log(`ðŸ“Š Pricing lookup map (Year ${pricingYear}):`, pricingMap);
      
      // ============================================================================
      // VALIDATION STEP 6: Check Pricing Data Availability
      // ============================================================================
      
      const warnings = [];
      const missingPricingProducts = new Set();
      
      budgetData.forEach(record => {
        const productGroupKey = record.productGroup.toLowerCase();
        const pricing = pricingMap[productGroupKey];
        
        if (!pricing || (pricing.sellingPrice === null && pricing.morm === null)) {
          missingPricingProducts.add(record.productGroup);
        }
      });
      
      if (missingPricingProducts.size > 0) {
        const missingList = Array.from(missingPricingProducts).join(', ');
        warnings.push(`Missing pricing data for ${missingPricingProducts.size} product group(s): ${missingList}`);
        console.warn(`âš ï¸ Missing pricing data for products: ${missingList}`);
      }
      
      if (Object.keys(pricingMap).length === 0) {
        warnings.push(`No pricing data found for year ${pricingYear}. Only KGS records will be created.`);
        console.warn(`âš ï¸ No pricing data available for year ${pricingYear}`);
      }
      
      // ============================================================================
      // BACKUP STEP: Archive existing data before deletion (if any)
      // ============================================================================
      
      if (existingRecords > 0) {
        console.log(`ðŸ“¦ Creating backup of ${existingRecords} existing records before replacement...`);
        
        // Archive to sales_rep_budget_archive table (create if not exists)
        const archiveQuery = `
          INSERT INTO sales_rep_budget_archive (
            division, budget_year, month, type, salesrepname, customername, countryname,
            productgroup, values_type, values, material, process, uploaded_filename,
            uploaded_at, archived_at, archived_reason
          )
          SELECT 
            division, budget_year, month, type, salesrepname, customername, countryname,
            productgroup, values_type, values, material, process, uploaded_filename,
            uploaded_at, CURRENT_TIMESTAMP, 'Replaced by new upload'
          FROM sales_rep_budget
          WHERE UPPER(division) = UPPER($1)
            AND UPPER(salesrepname) = UPPER($2)
            AND budget_year = $3 
            AND UPPER(type) = 'BUDGET'
        `;
        
        try {
          await client.query(archiveQuery, [
            metadata.division,
            metadata.salesRep,
            metadata.budgetYear
          ]);
          console.log(`âœ… Backup created successfully`);
        } catch (archiveError) {
          // Archive table might not exist - create it and retry
          if (archiveError.code === '42P01') { // undefined_table
            console.log('ðŸ“‹ Creating archive table...');
            await client.query(`
              CREATE TABLE IF NOT EXISTS sales_rep_budget_archive (
                id SERIAL PRIMARY KEY,
                division VARCHAR(50),
                budget_year INTEGER,
                month INTEGER,
                type VARCHAR(50),
                salesrepname VARCHAR(255),
                customername VARCHAR(255),
                countryname VARCHAR(100),
                productgroup VARCHAR(100),
                values_type VARCHAR(20),
                values NUMERIC(18,4),
                material VARCHAR(100),
                process VARCHAR(100),
                uploaded_filename VARCHAR(500),
                uploaded_at TIMESTAMP,
                archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                archived_reason VARCHAR(255)
              )
            `);
            await client.query(archiveQuery, [
              metadata.division,
              metadata.salesRep,
              metadata.budgetYear
            ]);
            console.log(`âœ… Archive table created and backup stored`);
          } else {
            console.warn('âš ï¸ Backup failed (non-critical):', archiveError.message);
          }
        }
      }
      
      // 3. Delete existing sales rep budget data for this combination
      const deleteQuery = `
        DELETE FROM sales_rep_budget 
        WHERE UPPER(division) = UPPER($1)
        AND UPPER(salesrepname) = UPPER($2)
        AND budget_year = $3 
        AND UPPER(type) = 'BUDGET'
      `;
      
      const deleteResult = await client.query(deleteQuery, [
        metadata.division,
        metadata.salesRep,
        metadata.budgetYear
      ]);
      
      console.log(`ðŸ—‘ï¸  Deleted ${deleteResult.rowCount} existing sales rep budget records`);
      
      // 4. Insert new budget data with 3 records per entry (KGS, Amount, MoRM)
      let insertedKGS = 0;
      let insertedAmount = 0;
      let insertedMoRM = 0;
      
      // Extract filename from metadata if available
      const uploadedFilename = metadata.savedAt ? 
        `BUDGET_${metadata.division.replace(/[^a-zA-Z0-9]/g, '_')}_${metadata.salesRep.replace(/[^a-zA-Z0-9]/g, '_')}_${metadata.budgetYear}_${new Date(metadata.savedAt).toISOString().replace(/[:.]/g, '-').slice(0, -5)}.html` : 
        null;
      
      for (const record of budgetData) {
        // Lookup material and process for this product group
        const productGroupKey = record.productGroup.toLowerCase();
        const materialProcess = materialProcessMap[productGroupKey] || { material: '', process: '' };
        const pricing = pricingMap[productGroupKey] || { sellingPrice: null, morm: null };
        
        const kgsValue = record.value; // Already in KGS (MT * 1000)
        
        // Common insert query for all 3 value types
        const insertQuery = `
          INSERT INTO sales_rep_budget (
            division,
            budget_year,
            month,
            type,
            salesrepname,
            customername,
            countryname,
            productgroup,
            values_type,
            values,
            material,
            process,
            uploaded_filename
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
          ON CONFLICT (division, budget_year, month, type, salesrepname, customername, countryname, productgroup, values_type)
          DO UPDATE SET 
            values = EXCLUDED.values,
            material = EXCLUDED.material,
            process = EXCLUDED.process,
            uploaded_at = CURRENT_TIMESTAMP,
            uploaded_filename = EXCLUDED.uploaded_filename
        `;
        
        // Insert Record 1: KGS (always insert)
        await client.query(insertQuery, [
          metadata.division,
          metadata.budgetYear,
          record.month,
          'Budget',
          metadata.salesRep,
          record.customer,
          record.country,
          record.productGroup,
          'KGS',
          kgsValue,
          materialProcess.material,
          materialProcess.process,
          uploadedFilename
        ]);
        insertedKGS++;
        
        // Insert Record 2: Amount (only if selling price available)
        if (pricing.sellingPrice !== null) {
          const amountValue = kgsValue * pricing.sellingPrice;
          await client.query(insertQuery, [
            metadata.division,
            metadata.budgetYear,
            record.month,
            'Budget',
            metadata.salesRep,
            record.customer,
            record.country,
            record.productGroup,
            'Amount',
            amountValue,
            materialProcess.material,
            materialProcess.process,
            uploadedFilename
          ]);
          insertedAmount++;
        }
        
        // Insert Record 3: MoRM (only if morm price available)
        if (pricing.morm !== null) {
          const mormValue = kgsValue * pricing.morm;
          await client.query(insertQuery, [
            metadata.division,
            metadata.budgetYear,
            record.month,
            'Budget',
            metadata.salesRep,
            record.customer,
            record.country,
            record.productGroup,
            'MoRM',
            mormValue,
            materialProcess.material,
            materialProcess.process,
            uploadedFilename
          ]);
          insertedMoRM++;
        }
      }
      
      await client.query('COMMIT');
      
      console.log(`âœ… Successfully imported sales rep budget:`);
      console.log(`   - KGS records: ${insertedKGS}`);
      console.log(`   - Amount records: ${insertedAmount}`);
      console.log(`   - MoRM records: ${insertedMoRM}`);
      console.log(`   - Total: ${insertedKGS + insertedAmount + insertedMoRM}`);
      
      res.json({
        success: true,
        message: 'Sales rep budget data imported successfully',
        metadata: metadata,
        existingBudget: existingRecords > 0 ? {
          recordCount: existingRecords,
          lastUpload: lastUpload,
          lastFilename: lastFilename,
          wasReplaced: true
        } : null,
        recordsDeleted: deleteResult.rowCount,
        recordsInserted: {
          kgs: insertedKGS,
          amount: insertedAmount,
          morm: insertedMoRM,
          total: insertedKGS + insertedAmount + insertedMoRM
        },
        pricingYear: pricingYear,
        pricingDataAvailable: Object.keys(pricingMap).length,
        warnings: warnings.length > 0 ? warnings : undefined,
        skippedRecords: recordErrors.length > 0 ? recordErrors.length : undefined
      });
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('âŒ Error importing budget HTML:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// DIVISIONAL HTML BUDGET ENDPOINTS
// ============================================================================

/**
 * GET /api/aebf/html-budget-actual-years
 * Get all unique years that have actual sales data for a division (for HTML budget)
 */
router.get('/html-budget-actual-years', async (req, res) => {
  try {
    const { division } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'division is required'
      });
    }
    
    const query = `
      SELECT DISTINCT year
      FROM public.fp_data_excel
      WHERE UPPER(division) = UPPER($1)
        AND UPPER(type) = 'ACTUAL'
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      ORDER BY year DESC
    `;
    
    const result = await pool.query(query, [division]);
    const years = result.rows.map(row => row.year);
    
    res.json({
      success: true,
      years
    });
    
  } catch (error) {
    console.error('âŒ Error fetching HTML budget actual years:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/divisional-html-budget-data
 * Fetch aggregated actual sales data by product group for divisional budget
 */
router.post('/divisional-html-budget-data', async (req, res) => {
  try {
    const { division, actualYear } = req.body;
    
    if (!division || !actualYear) {
      return res.status(400).json({
        success: false,
        error: 'division and actualYear are required'
      });
    }
    
    const budgetYear = parseInt(actualYear) + 1;
    
    // Query actual sales data aggregated by product group (all sales reps, all customers, all countries)
    const actualQuery = `
      SELECT 
        TRIM(productgroup) as productgroup,
        month,
        SUM(CASE WHEN UPPER(values_type) = 'KGS' THEN values ELSE 0 END) / 1000.0 as mt_value
      FROM public.fp_data_excel
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND UPPER(type) = 'ACTUAL'
        AND productgroup IS NOT NULL
        AND TRIM(productgroup) != ''
        AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
      GROUP BY TRIM(productgroup), month
      ORDER BY TRIM(productgroup), month
    `;
    
    const actualResult = await pool.query(actualQuery, [division, actualYear]);
    
    // Query existing budget data from fp_divisional_budget table
    const budgetQuery = `
      SELECT 
        TRIM(product_group) as productgroup,
        month,
        SUM(CASE WHEN UPPER(metric) = 'KGS' THEN value ELSE 0 END) / 1000.0 as mt_value
      FROM public.fp_divisional_budget
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
        AND product_group IS NOT NULL
        AND TRIM(product_group) != ''
      GROUP BY TRIM(product_group), month
      ORDER BY TRIM(product_group), month
    `;
    
    const budgetResult = await pool.query(budgetQuery, [division, budgetYear]);
    
    // Query pricing data for Amount and MoRM calculations (from prior year)
    const pricingYear = parseInt(actualYear);
    const pricingQuery = `
      SELECT 
        TRIM(product_group) as product_group,
        COALESCE(asp_round, 0) as selling_price,
        COALESCE(morm_round, 0) as morm
      FROM product_group_pricing_rounding
      WHERE UPPER(division) = UPPER($1)
        AND year = $2
    `;
    const pricingResult = await pool.query(pricingQuery, [division, pricingYear]);
    
    // Build pricing map
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group.toLowerCase()] = {
        sellingPrice: parseFloat(row.selling_price) || 0,
        morm: parseFloat(row.morm) || 0
      };
    });
    
    // Transform actual data to table structure
    const productGroupMap = {};
    
    actualResult.rows.forEach(row => {
      const productGroup = row.productgroup;
      if (!productGroupMap[productGroup]) {
        productGroupMap[productGroup] = {
          productGroup: productGroup,
          monthlyActual: {},
        };
      }
      productGroupMap[productGroup].monthlyActual[row.month] = parseFloat(row.mt_value) || 0;
    });
    
    // Transform budget data to key-value map
    const budgetDataMap = {};
    budgetResult.rows.forEach(row => {
      const key = `${row.productgroup}|${row.month}`;
      budgetDataMap[key] = (parseFloat(row.mt_value) || 0).toFixed(2);
    });
    
    const data = Object.values(productGroupMap).sort((a, b) => 
      a.productGroup.localeCompare(b.productGroup)
    );
    
    res.json({
      success: true,
      data: data,
      budgetData: budgetDataMap,
      pricingData: pricingMap,
      pricingYear: pricingYear
    });
    
  } catch (error) {
    console.error('Error fetching divisional HTML budget data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/export-divisional-html-budget-form
 * Export divisional budget HTML form (similar to sales rep, but product group only)
 */
router.post('/export-divisional-html-budget-form', async (req, res) => {
  try {
    const { division, actualYear, tableData, budgetData, isFinal } = req.body;
    
    if (!division || !actualYear || !Array.isArray(tableData)) {
      return res.status(400).json({
        success: false,
        error: 'division, actualYear, and tableData are required'
      });
    }
    
    const budgetDataMap = budgetData || {};
    const budgetYear = parseInt(actualYear) + 1;
    
    // Calculate monthly totals
    const monthlyActualTotals = {};
    const monthlyBudgetTotals = {};
    for (let month = 1; month <= 12; month++) {
      monthlyActualTotals[month] = 0;
      monthlyBudgetTotals[month] = 0;
    }
    
    // Calculate actual totals
    tableData.forEach(row => {
      for (let month = 1; month <= 12; month++) {
        monthlyActualTotals[month] += row.monthlyActual?.[month] || 0;
      }
    });
    
    // Calculate budget totals
    Object.keys(budgetDataMap).forEach(key => {
      let month;
      if (key.startsWith('custom_')) {
        const parts = key.split('_');
        month = parseInt(parts[parts.length - 1], 10);
      } else {
        const parts = key.split('|');
        month = parseInt(parts[parts.length - 1], 10);
      }
      if (month >= 1 && month <= 12) {
        const value = budgetDataMap[key];
        const num = parseFloat((value || '').toString().replace(/,/g, '')) || 0;
        if (!isNaN(num)) {
          monthlyBudgetTotals[month] += num;
        }
      }
    });
    
    
    // Generate HTML (similar structure to sales rep, but simplified for product groups only)
    const html = `<!DOCTYPE html>
<!-- IPD_BUDGET_SYSTEM_v1.0 :: TYPE=DIVISIONAL_BUDGET :: DO_NOT_EDIT_THIS_LINE -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Divisional Budget Planning - ${division} - ${actualYear}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; display: flex; flex-direction: column; }
    .header { background: #fff; padding: 20px; margin-bottom: 20px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; }
    .header h1 { margin-bottom: 10px; color: #333; }
    .header-info { display: flex; gap: 30px; flex-wrap: wrap; }
    .header-info div { font-size: 14px; color: #666; }
    .header-info strong { color: #333; }
    .table-container {
      background: #fff;
      padding: 0;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
      flex: 1;
      min-height: 0;
      height: calc(100vh - 200px);
      overflow-x: auto;
      overflow-y: auto;
    }
    table { 
      width: 100%; 
      border-collapse: separate; 
      border-spacing: 0; 
      font-size: 12px; 
      table-layout: fixed; 
    }
    thead th.legend-header {
      position: -webkit-sticky !important;
      position: sticky !important;
      top: 0 !important;
      z-index: 1002 !important;
      background: #fff !important;
      padding: 12px 24px !important;
      border-bottom: 1px solid #e8e8e8 !important;
      text-align: left !important;
    }
    thead tr.header-row {
      position: -webkit-sticky;
      position: sticky;
      top: 49px;
      z-index: 1001;
      background: #fff;
    }
    thead th.column-header {
      background-color: #1677ff;
      color: #fff;
      padding: 8px;
      border: 1px solid #fff;
      text-align: center;
      min-width: 0;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    thead th.column-header.sticky-col {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 1003;
      background-color: #1677ff;
    }
    tbody td { 
      padding: 8px; 
      border: 1px solid #ddd; 
    }
    tbody td:nth-child(1) {
      background-color: #fff;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 5;
      font-weight: 600;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }
    tbody tr.actual-row { background-color: #e6f4ff; }
    tbody tr.actual-row td:nth-child(n+2) { 
      background-color: #e6f4ff; 
      text-align: right; 
      font-weight: 500; 
      padding: 6px 8px; 
    }
    tbody tr.budget-row { background-color: #FFFFB8; }
    tbody tr.budget-row td { 
      background-color: #FFFFB8 !important; 
      padding: 2px; 
    }
    tbody input { 
      width: 100%; 
      border: none; 
      padding: 4px 6px; 
      text-align: right; 
      font-size: 12px; 
      font-weight: 500; 
      background-color: transparent !important; 
      box-shadow: none; 
    }
    tbody input:focus { outline: none; }
    tbody input:disabled { background-color: #f5f5f5 !important; cursor: not-allowed; }
    tbody select { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
    tbody .delete-btn { 
      background: #ff4d4f; 
      color: #fff; 
      border: none; 
      padding: 2px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 12px; 
      margin-left: 4px; 
    }
    tfoot tr.actual-total {
      background-color: #cce4ff;
    }
    tfoot tr.actual-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #cce4ff;
      text-align: right;
      font-weight: 700;
    }
    tfoot tr.actual-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #cce4ff;
    }
    tfoot tr.budget-total {
      background-color: #FFFFB8;
    }
    tfoot tr.budget-total td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      background-color: #FFFFB8;
      text-align: right;
      font-weight: 700;
    }
    tfoot tr.budget-total td:first-child {
      padding: 8px;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFFFB8;
    }
    tfoot tr.budget-year-total {
      background-color: #FFEB3B;
    }
    tfoot tr.budget-year-total td {
      padding: 8px;
      border: 1px solid #ddd;
      background-color: #FFEB3B;
      font-weight: 700;
    }
    tfoot tr.budget-year-total td:first-child {
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      z-index: 6;
      text-align: left;
      background-color: #FFEB3B;
    }
    .btn {
      background: #1677ff;
      color: #fff;
      border: none;
      padding: 4px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .btn:hover { background: #4096ff; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Divisional Budget Planning Form - ${division}</h1>
    <div class="header-info">
      <div><strong>Division:</strong> ${division}</div>
      <div><strong>Actual Year:</strong> ${actualYear}</div>
      <div><strong>Budget Year:</strong> ${budgetYear}</div>
    </div>
  </div>
  
  <div class="table-container">
    <table>
      <colgroup>
        <col style="width: 25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
        <col style="width: 6.25%;" />
      </colgroup>
      <thead>
        <tr>
          <th colspan="14" class="legend-header">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; gap: 24px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="display: inline-block; width: 16px; height: 16px; background-color: #e6f4ff; border: 1px solid #99c8ff;"></span>
                  <span>Actual ${actualYear} Volume (MT)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="display: inline-block; width: 16px; height: 16px; background-color: #FFFFB8; border: 1px solid #d4b106;"></span>
                  <span>Budget ${budgetYear} Volume (MT)</span>
                </div>
              </div>
              ${!isFinal ? `
              <div style="display: flex; gap: 8px;">
                <button class="btn" id="saveDraftBtn" style="background: #1677ff;">ðŸ’¾ Save Draft</button>
                <button class="btn" id="saveFinalBtn" style="background: #52c41a;">âœ“ Save Final</button>
              </div>
              ` : ''}
            </div>
          </th>
        </tr>
        <tr class="header-row">
          <th rowspan="2" class="column-header sticky-col">Product Group</th>
          ${Array.from({ length: 12 }, (_, i) => `<th class="column-header">${i + 1}</th>`).join('')}
        </tr>
      </thead>
      <tbody id="tableBody">
        ${tableData.map((row, idx) => {
          const actualCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const value = row.monthlyActual?.[month] || 0;
            const formatted = value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('');
          
          const budgetCells = Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const key = row.productGroup + '|' + month;
            const preFilledValue = budgetDataMap[key] || '';
            return '<td>' +
              '<input ' +
              'type="text" ' +
              'data-group="' + row.productGroup.replace(/"/g, '&quot;') + '" ' +
              'data-month="' + month + '" ' +
              'placeholder="0" ' +
              'value="' + preFilledValue + '" ' +
              (isFinal ? 'disabled ' : '') +
              '/>' +
            '</td>';
          }).join('');
          
          return `<tr class="actual-row">
            <td rowspan="2">${row.productGroup}</td>
            ${actualCells}
          </tr>
          <tr class="budget-row">
            ${budgetCells}
          </tr>`;
        }).join('')}
      </tbody>
      <tfoot>
        <tr class="actual-total">
          <td>Total Actual (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyActualTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('')}
        </tr>
        <tr class="actual-year-total">
          <td
            style="padding: 8px; border: 1px solid #ddd; position: sticky; left: 0; z-index: 6; font-weight: 700; text-align: left; background-color: #90CAF9;"
          >
            Total Actual (MT)
          </td>
          <td
            colspan="12"
            style="padding: 8px; border: 1px solid #ddd; background-color: #90CAF9; text-align: center; font-weight: 700; font-size: 14px;"
          >
            ${Object.values(monthlyActualTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
          </td>
        </tr>
        <tr class="budget-total">
          <td>Total Budget (MT)</td>
          ${Array.from({ length: 12 }, (_, i) => {
            const month = i + 1;
            const total = monthlyBudgetTotals[month] || 0;
            const formatted = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return `<td>${formatted}</td>`;
          }).join('')}
        </tr>
        <tr class="budget-year-total">
          <td>Total Budget (MT)</td>
          <td colspan="12" style="text-align: center; font-size: 14px;" id="budgetYearTotal">${Object.values(monthlyBudgetTotals).reduce((sum, val) => sum + val, 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script>
    const formData = {
      division: '${division}',
      actualYear: ${actualYear},
      budgetYear: ${budgetYear},
    };
    
    function cloneWorkingDocument() {
      const htmlClone = document.documentElement.cloneNode(true);
      const liveInputs = document.querySelectorAll('input');
      const clonedInputs = htmlClone.querySelectorAll('input');
      clonedInputs.forEach((input, idx) => {
        if (liveInputs[idx]) {
          input.setAttribute('value', liveInputs[idx].value || '');
        }
      });
      
      const tempDoc = document.implementation.createHTMLDocument(document.title || 'Divisional Budget');
      const importedHtml = tempDoc.importNode(htmlClone, true);
      tempDoc.replaceChild(importedHtml, tempDoc.documentElement);
      return tempDoc;
    }
    
    function formatMT(value) {
      if (!value && value !== 0) return '';
      const num = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value;
      if (isNaN(num)) return '';
      return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    function recalculateTotals() {
      const budgetTotals = Array.from({ length: 12 }, () => 0);
      
      document.querySelectorAll('input:not([disabled])').forEach(input => {
        const month = parseInt(input.dataset.month);
        const val = parseFloat(input.value.replace(/,/g, '')) || 0;
        if (month >= 1 && month <= 12 && !isNaN(val)) {
          budgetTotals[month - 1] += val;
        }
      });
      
      const budgetTotalCells = document.querySelectorAll('tfoot tr.budget-total td:not(:first-child)');
      budgetTotalCells.forEach((cell, idx) => {
        cell.textContent = formatMT(budgetTotals[idx]);
      });
      
      const yearTotal = budgetTotals.reduce((sum, val) => sum + val, 0);
      const yearTotalCell = document.getElementById('budgetYearTotal');
      if (yearTotalCell) {
        yearTotalCell.textContent = formatMT(yearTotal);
      }
    }
    
    ${!isFinal ? `
    document.querySelectorAll('input').forEach(input => {
      input.addEventListener('blur', function() {
        const val = this.value;
        if (val) {
          this.value = formatMT(val);
        }
        recalculateTotals();
      });
      
      input.addEventListener('input', function() {
        this.value = this.value.replace(/[^0-9.,]/g, '');
        recalculateTotals();
      });
    });
    
    // Save Draft Button - keeps form editable
    document.getElementById('saveDraftBtn').addEventListener('click', function() {
      recalculateTotals();
      
      const clonedDoc = cloneWorkingDocument();
      
      const draftMetadata = {
        isDraft: true,
        division: formData.division,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'divisional_budget_draft'
      };
      
      const draftScript = clonedDoc.createElement('script');
      draftScript.id = 'draftMetadata';
      draftScript.textContent = '/* DRAFT METADATA */\\n' +
        'const draftMetadata = ' + JSON.stringify(draftMetadata, null, 2) + ';';
      clonedDoc.body.appendChild(draftScript);
      
      const htmlContent = '<!DOCTYPE html>\\n' + clonedDoc.documentElement.outerHTML;
      
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      const filename = 'DRAFT_Divisional_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('âœ… Draft saved!\\n\\nYou can open this file later to continue editing.\\n\\nFilename: ' + filename + '\\n\\nðŸ’¡ This is a DRAFT file - it cannot be uploaded to the system.\\nUse "Save Final" when ready to submit.');
    });
    
    // Save Final Button
    document.getElementById('saveFinalBtn').addEventListener('click', function() {
      const budgetInputs = document.querySelectorAll('input:not([disabled])[data-month]');
      const hasData = Array.from(budgetInputs).some(input => {
        const val = input.value.replace(/,/g, '');
        return val && parseFloat(val) > 0;
      });
      
      if (!hasData) {
        alert('âš ï¸ No budget data entered!\\n\\nPlease enter at least one budget value before saving final version.');
        return;
      }
      
      if (!confirm('ðŸ“‹ Finalize Divisional Budget?\\n\\nThis will create a final version that:\\nâ€¢ Cannot be edited\\nâ€¢ Can be uploaded to the system\\nâ€¢ Will calculate Amount and MoRM values\\n\\nDo you want to proceed?')) {
        return;
      }
      
      recalculateTotals();
      
      const clonedDoc = cloneWorkingDocument();
      
      clonedDoc.querySelectorAll('input[data-month]').forEach(input => {
        const value = input.value || '0';
        const td = input.parentElement;
        td.innerHTML = value;
        td.style.textAlign = 'right';
        td.style.fontWeight = '500';
        td.style.padding = '6px 8px';
      });
      
      clonedDoc.querySelectorAll('.delete-btn').forEach(btn => btn.remove());
      clonedDoc.querySelectorAll('select').forEach(select => {
        const value = select.options[select.selectedIndex]?.text || '';
        select.outerHTML = '<span>' + value + '</span>';
      });
      
      const addBtn = clonedDoc.getElementById('addRowBtn');
      if (addBtn) addBtn.remove();
      const saveDraftBtn = clonedDoc.getElementById('saveDraftBtn');
      if (saveDraftBtn) saveDraftBtn.remove();
      const saveFinalBtn = clonedDoc.getElementById('saveFinalBtn');
      if (saveFinalBtn) saveFinalBtn.remove();
      
      clonedDoc.querySelectorAll('script').forEach(script => {
        if (!script.id || script.id !== 'savedBudgetData') {
          script.remove();
        }
      });
      
      const budgetData = [];
      document.querySelectorAll('input:not([disabled])[data-month]').forEach(input => {
        const val = input.value.replace(/,/g, '');
        if (val && parseFloat(val) > 0) {
          budgetData.push({
            productGroup: input.dataset.group,
            month: parseInt(input.dataset.month),
            value: parseFloat(val) * 1000
          });
        }
      });
      
      const metadata = {
        division: formData.division,
        actualYear: formData.actualYear,
        budgetYear: formData.budgetYear,
        savedAt: new Date().toISOString(),
        version: '1.0',
        dataFormat: 'divisional_budget_import'
      };
      
      const savedDataScript = clonedDoc.createElement('script');
      savedDataScript.id = 'savedBudgetData';
      savedDataScript.textContent = 
        '/* DIVISIONAL BUDGET DATA FOR DATABASE IMPORT */\\n' +
        'const budgetMetadata = ' + JSON.stringify(metadata, null, 2) + ';\\n' +
        'const savedBudget = ' + JSON.stringify(budgetData, null, 2) + ';';
      clonedDoc.body.appendChild(savedDataScript);
      
      const htmlContent = '<!DOCTYPE html>\\n' + clonedDoc.documentElement.outerHTML;
      
      const now = new Date();
      const dateStr = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0');
      const timeStr = String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      const timestamp = dateStr + '_' + timeStr;
      
      const filename = 'BUDGET_Divisional_' + 
        formData.division.replace(/[^a-zA-Z0-9]/g, '_') + '_' + 
        formData.budgetYear + '_' + 
        timestamp + '.html';
      
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      alert('âœ… Final divisional budget saved!\\n\\nFilename: ' + filename + '\\n\\nThis file is ready for upload to the system.');
    });
    ` : ''}
    
    recalculateTotals();
  </script>
</body>
</html>`;
    
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('Content-Disposition', `attachment; filename="Budget_Divisional_${division}_${actualYear}.html"`);
    res.send(html);
    
  } catch (error) {
    console.error('âŒ Error exporting divisional HTML budget form:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/import-divisional-budget-html
 * Import filled divisional budget HTML file to fp_divisional_budget table
 */
router.post('/import-divisional-budget-html', async (req, res) => {
  console.log('ðŸ“¥ Import divisional budget HTML request received');
  try {
    const htmlContent = req.body.htmlContent;
    const confirmReplace = req.body.confirmReplace === true;
    
    if (!htmlContent) {
      return res.status(400).json({
        success: false,
        error: 'No HTML content provided'
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 0: File Signature Check
    // ============================================================================
    
    const signaturePattern = /<!--\s*IPD_BUDGET_SYSTEM_v[\d.]+\s*::\s*TYPE=(SALES_REP_BUDGET|DIVISIONAL_BUDGET)\s*::/;
    const signatureMatch = htmlContent.match(signaturePattern);
    
    if (!signatureMatch) {
      console.warn('âš ï¸ File missing IPD Budget System signature - may be legacy or modified file');
    } else if (signatureMatch[1] !== 'DIVISIONAL_BUDGET') {
      console.error('âŒ Wrong file type: expected DIVISIONAL_BUDGET, got', signatureMatch[1]);
      return res.status(400).json({
        success: false,
        error: 'Wrong file type. This appears to be a Sales Rep Budget file. Please use the Sales Rep Budget import instead.'
      });
    } else {
      console.log('âœ… Valid IPD Budget System signature detected');
    }
    
    // Extract metadata and budget data
    let metadata = null;
    let budgetData = null;
    
    try {
      const scriptTagMatch = htmlContent.match(/<script[^>]*id=["']savedBudgetData["'][^>]*>([\s\S]*?)<\/script>/i);
      if (scriptTagMatch && scriptTagMatch[1]) {
        const scriptContent = scriptTagMatch[1];
        // Improved JSON extraction - handle multi-line JSON properly
        const metaMatch = scriptContent.match(/const\s+budgetMetadata\s*=\s*(\{[\s\S]*?\});/);
        const dataMatch = scriptContent.match(/const\s+savedBudget\s*=\s*(\[[\s\S]*?\]);/);
        
        if (metaMatch && dataMatch) {
          metadata = JSON.parse(metaMatch[1]);
          budgetData = JSON.parse(dataMatch[1]);
        }
      }
      
      if (!metadata || !budgetData) {
        // Fallback for legacy files
        const metadataMatch = htmlContent.match(/const budgetMetadata = (\{[\s\S]*?\});/);
        const budgetDataMatch = htmlContent.match(/const savedBudget = (\[[\s\S]*?\]);/);
        if (metadataMatch && budgetDataMatch) {
          metadata = JSON.parse(metadataMatch[1]);
          budgetData = JSON.parse(budgetDataMatch[1]);
        }
      }
      
      if (!metadata || !budgetData) {
        return res.status(400).json({
          success: false,
          error: 'Invalid HTML file format. Missing budget metadata or saved budget data. Please re-export using the in-app "Save Final" button.'
        });
      }
      
      console.log('âœ… Parsed metadata and budget data from HTML export');
      console.log('âœ… Metadata:', { division: metadata.division, budgetYear: metadata.budgetYear });
      console.log('âœ… Budget records count:', Array.isArray(budgetData) ? budgetData.length : 0);
      
    } catch (e) {
      console.error('âŒ Error extracting data from HTML:', e);
      return res.status(400).json({
        success: false,
        error: 'Failed to parse budget data from file. Ensure the file was exported from the application using "Save Final".'
      });
    }
    
    // Generate file hash for tracking
    const crypto = require('crypto');
    const fileHash = crypto.createHash('sha256').update(htmlContent).digest('hex').substring(0, 16);
    console.log('ðŸ“‹ File hash:', fileHash);
    
    // ============================================================================
    // VALIDATION STEP 1: Check for Draft File
    // ============================================================================
    
    const draftCheck = htmlContent.match(/const draftMetadata = (\{[\s\S]*?\});/);
    if (draftCheck) {
      try {
        const draftMeta = JSON.parse(draftCheck[1]);
        if (draftMeta.isDraft === true) {
          console.warn('âš ï¸ Draft file rejected');
          return res.status(400).json({
            success: false,
            error: 'âš ï¸ Cannot upload draft file!\n\nThis is a work-in-progress draft. Please open the file, complete your budget, and click "Save Final" before uploading.',
            isDraft: true
          });
        }
      } catch (e) {
        console.log('Draft check parse error (ignored):', e.message);
      }
    }
    
    // ============================================================================
    // VALIDATION STEP 2: Validate Data Format and Version
    // ============================================================================
    
    const validationErrors = [];
    
    if (!metadata.dataFormat || metadata.dataFormat !== 'divisional_budget_import') {
      validationErrors.push('Invalid data format. This file is not a divisional budget export.');
    }
    
    if (!metadata.version || metadata.version !== '1.0') {
      validationErrors.push('Unsupported file version. Please re-export from the system.');
    }
    
    if (!metadata.division || typeof metadata.division !== 'string') {
      validationErrors.push('Invalid or missing division');
    }
    
    if (!metadata.budgetYear || typeof metadata.budgetYear !== 'number' || metadata.budgetYear < 2020 || metadata.budgetYear > 2100) {
      validationErrors.push('Invalid or missing budget year (must be between 2020-2100)');
    }
    
    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'File validation failed:\n' + validationErrors.join('\n')
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 3: Validate Budget Data Structure
    // ============================================================================
    
    if (!Array.isArray(budgetData)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid budget data format. Expected an array of records.'
      });
    }
    
    if (budgetData.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No budget data found in file. The file appears to be empty.'
      });
    }
    
    if (budgetData.length > 10000) {
      return res.status(400).json({
        success: false,
        error: `Too many records (${budgetData.length}). Maximum allowed is 10,000.`
      });
    }
    
    // ============================================================================
    // VALIDATION STEP 4: Validate Individual Records
    // ============================================================================
    
    const recordErrors = [];
    const validRecords = [];
    
    budgetData.forEach((record, index) => {
      const errors = [];
      
      if (!record.productGroup || typeof record.productGroup !== 'string' || record.productGroup.trim() === '') {
        errors.push('Missing or invalid product group');
      }
      
      if (!record.month || typeof record.month !== 'number' || record.month < 1 || record.month > 12) {
        errors.push('Invalid month (must be 1-12)');
      }
      
      if (record.value === undefined || record.value === null) {
        errors.push('Missing value');
      } else if (typeof record.value !== 'number' || isNaN(record.value)) {
        errors.push('Invalid value (must be a number)');
      } else if (record.value < 0) {
        errors.push('Negative values not allowed');
      } else if (record.value === 0) {
        errors.push('Zero values not allowed');
      } else if (record.value > 1000000000) {
        errors.push('Value too large (max 1 billion KGS)');
      }
      
      if (errors.length > 0) {
        recordErrors.push({
          index: index + 1,
          productGroup: record.productGroup || 'Unknown',
          month: record.month || 'Unknown',
          errors: errors
        });
      } else {
        validRecords.push(record);
      }
    });
    
    // If more than 10% of records have errors, reject the file
    const errorRate = recordErrors.length / budgetData.length;
    if (errorRate > 0.1) {
      return res.status(400).json({
        success: false,
        error: `Too many invalid records (${recordErrors.length} out of ${budgetData.length}). Please check your file and try again.`,
        recordErrors: recordErrors.slice(0, 10),
        totalErrors: recordErrors.length
      });
    }
    
    // If some records have errors, log them but continue with valid records
    if (recordErrors.length > 0) {
      console.warn(`âš ï¸ Skipping ${recordErrors.length} invalid records out of ${budgetData.length}`);
    }
    
    // Use only valid records if we filtered some out
    const recordsToImport = validRecords.length > 0 ? validRecords : budgetData;
    
    console.log(`âœ… Validation passed: ${recordsToImport.length} valid records`);
    
    const client = await pool.connect();
    try {
      const existingBudget = await getDivisionalBudgetInfo(client, metadata.division, metadata.budgetYear);

      if (!confirmReplace && existingBudget.recordCount > 0) {
        client.release();
        return res.json({
          success: false,
          needsConfirmation: true,
          existingBudget,
          metadata
        });
      }

      await client.query('BEGIN');
      const result = await saveDivisionalBudget(client, {
        division: metadata.division,
        budgetYear: metadata.budgetYear,
        records: recordsToImport,
        savedAt: metadata.savedAt,
        filenamePrefix: 'BUDGET_Divisional'
      });
      await client.query('COMMIT');
      
      console.log(`âœ… Successfully imported divisional budget:`);
      console.log(`   - KGS records: ${result.recordsInserted?.kgs || 0}`);
      console.log(`   - Amount records: ${result.recordsInserted?.amount || 0}`);
      console.log(`   - MoRM records: ${result.recordsInserted?.morm || 0}`);
      console.log(`   - Total: ${result.recordsInserted?.total || 0}`);

      res.json({
        success: true,
        message: 'Divisional budget data imported successfully',
        ...result,
        skippedRecords: recordErrors.length > 0 ? recordErrors.length : undefined
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('âŒ Error importing divisional budget HTML:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/save-divisional-budget
 * Save divisional budget data directly from the web app (no HTML export)
 */
router.post('/save-divisional-budget', async (req, res) => {
  const client = await pool.connect();
  try {
    const { division, budgetYear, records } = req.body;

    if (!division || !budgetYear || !Array.isArray(records)) {
      return res.status(400).json({
        success: false,
        error: 'division, budgetYear, and records array are required'
      });
    }

    await client.query('BEGIN');
    const result = await saveDivisionalBudget(client, {
      division,
      budgetYear: parseInt(budgetYear, 10),
      records,
      savedAt: new Date().toISOString(),
      filenamePrefix: 'LIVE_Divisional'
    });
    await client.query('COMMIT');

    res.json({
      success: true,
      message: 'Divisional budget saved successfully',
      ...result
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Error saving divisional budget:', error);
    const statusCode = error.details ? 400 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
      details: error.details
    });
  } finally {
    client.release();
  }
});

/**
 * GET /api/aebf/budget-years
 * Get all unique years that have budget data for a division
 */
router.get('/budget-years', async (req, res) => {
  try {
    const { division } = req.query;
    
    if (!division) {
      return res.status(400).json({
        success: false,
        error: 'division is required'
      });
    }
    
    const query = `
      SELECT DISTINCT budget_year
      FROM sales_rep_budget
      WHERE UPPER(division) = UPPER($1)
        AND UPPER(type) = 'BUDGET'
      ORDER BY budget_year DESC
    `;
    
    const result = await pool.query(query, [division]);
    const years = result.rows.map(row => row.budget_year);
    
    res.json({
      success: true,
      years
    });
    
  } catch (error) {
    console.error('âŒ Error fetching budget years:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/aebf/budget-sales-reps
 * Get all sales reps who have budget data for a specific year and division
 */
router.get('/budget-sales-reps', async (req, res) => {
  try {
    const { division, budgetYear } = req.query;
    
    if (!division || !budgetYear) {
      return res.status(400).json({
        success: false,
        error: 'division and budgetYear are required'
      });
    }
    
    const query = `
      SELECT DISTINCT TRIM(salesrepname) as salesrep
      FROM sales_rep_budget
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(type) = 'BUDGET'
        AND salesrepname IS NOT NULL
        AND TRIM(salesrepname) != ''
      ORDER BY TRIM(salesrepname)
    `;
    
    const result = await pool.query(query, [division, parseInt(budgetYear)]);
    const salesReps = result.rows.map(row => row.salesrep);
    
    res.json({
      success: true,
      salesReps
    });
    
  } catch (error) {
    console.error('âŒ Error fetching budget sales reps:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/budget-sales-rep-recap
 * Get sales rep budget recap showing AMOUNT, KGS, and MORM totals
 * Returns data similar to the screenshot: year totals for each value type
 */
router.post('/budget-sales-rep-recap', async (req, res) => {
  try {
    const { division, budgetYear, salesRep } = req.body;
    
    if (!division || !budgetYear || !salesRep) {
      return res.status(400).json({
        success: false,
        error: 'division, budgetYear, and salesRep are required'
      });
    }
    
    const query = `
      SELECT 
        values_type,
        SUM(values) as total_values,
        COUNT(*) as record_count
      FROM sales_rep_budget
      WHERE UPPER(division) = UPPER($1)
        AND budget_year = $2
        AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
        AND UPPER(type) = 'BUDGET'
        AND values_type IN ('Amount', 'KGS', 'MoRM')
      GROUP BY values_type
      ORDER BY 
        CASE values_type
          WHEN 'Amount' THEN 1
          WHEN 'KGS' THEN 2
          WHEN 'MoRM' THEN 3
        END
    `;
    
    const result = await pool.query(query, [division, parseInt(budgetYear), salesRep]);
    
    // Ensure all three types are present even if zero
    const recapMap = {
      'Amount': { values_type: 'Amount', total_values: 0, record_count: 0 },
      'KGS': { values_type: 'KGS', total_values: 0, record_count: 0 },
      'MoRM': { values_type: 'MoRM', total_values: 0, record_count: 0 }
    };
    
    result.rows.forEach(row => {
      recapMap[row.values_type] = {
        values_type: row.values_type,
        total_values: parseFloat(row.total_values) || 0,
        record_count: parseInt(row.record_count) || 0
      };
    });
    
    const recap = [
      recapMap['Amount'],
      recapMap['KGS'],
      recapMap['MoRM']
    ];
    
    res.json({
      success: true,
      recap,
      salesRep,
      budgetYear: parseInt(budgetYear)
    });
    
  } catch (error) {
    console.error('âŒ Error fetching sales rep budget recap:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/aebf/budget-product-groups
 * Get product group breakdown for sales rep budget
 * Returns KGS, Amount (Sales), MoRM for each product group
 */
router.post('/budget-product-groups', async (req, res) => {
  try {
    const { division, budgetYear, salesRep } = req.body;
    
    if (!division || !budgetYear) {
      return res.status(400).json({
        success: false,
        error: 'division and budgetYear are required'
      });
    }
    
    let query;
    let params;
    
    // If salesRep is '__ALL__' or not provided, get all sales reps
    if (!salesRep || salesRep === '__ALL__') {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM sales_rep_budget
        WHERE UPPER(division) = UPPER($1)
          AND budget_year = $2
          AND UPPER(type) = 'BUDGET'
          AND values_type IN ('Amount', 'KGS', 'MoRM')
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(budgetYear)];
    } else {
      query = `
        SELECT 
          TRIM(productgroup) as product_group,
          values_type,
          SUM(values) as total_values
        FROM sales_rep_budget
        WHERE UPPER(division) = UPPER($1)
          AND budget_year = $2
          AND UPPER(TRIM(salesrepname)) = UPPER(TRIM($3))
          AND UPPER(type) = 'BUDGET'
          AND values_type IN ('Amount', 'KGS', 'MoRM')
          AND productgroup IS NOT NULL
          AND TRIM(productgroup) != ''
          AND UPPER(TRIM(productgroup)) != 'SERVICES CHARGES'
        GROUP BY TRIM(productgroup), values_type
        ORDER BY TRIM(productgroup), values_type
      `;
      params = [division, parseInt(budgetYear), salesRep];
    }
    
    const result = await pool.query(query, params);
    
    // Transform data into product group structure
    const productGroupsMap = {};
    
    result.rows.forEach(row => {
      const pgName = row.product_group;
      if (!productGroupsMap[pgName]) {
        productGroupsMap[pgName] = {
          name: pgName,
          KGS: 0,
          Amount: 0,
          MoRM: 0
        };
      }
      productGroupsMap[pgName][row.values_type] = parseFloat(row.total_values) || 0;
    });
    
    // Get pricing data for the previous year (budget year - 1)
    const pricingYear = parseInt(budgetYear) - 1;
    const pricingQuery = `
      SELECT 
        TRIM(p.product_group) as product_group,
        p.rm_round,
        p.morm_round,
        COALESCE(m.material, '') as material,
        COALESCE(m.process, '') as process
      FROM product_group_pricing_rounding p
      LEFT JOIN fp_material_percentages m 
        ON UPPER(TRIM(p.product_group)) = UPPER(TRIM(m.product_group))
        AND m.material IS NOT NULL 
        AND TRIM(m.material) != ''
      WHERE UPPER(p.division) = UPPER($1)
        AND p.year = $2
        AND p.product_group IS NOT NULL
        AND TRIM(p.product_group) != ''
    `;
    
    const pricingResult = await pool.query(pricingQuery, [division, pricingYear]);
    
    // Map pricing data
    const pricingMap = {};
    pricingResult.rows.forEach(row => {
      pricingMap[row.product_group] = {
        rm: parseFloat(row.rm_round) || 0,
        morm: parseFloat(row.morm_round) || 0,
        material: row.material || '',
        process: row.process || ''
      };
    });
    
    // Build final product groups array with pricing
    const productGroups = Object.values(productGroupsMap).map(pg => {
      const pricing = pricingMap[pg.name] || { rm: 0, morm: 0, material: '', process: '' };
      return {
        name: pg.name,
        KGS: pg.KGS,
        Amount: pg.Amount,
        MoRM: pg.MoRM,
        RM: pricing.rm,
        Material: pricing.material,
        Process: pricing.process
      };
    });
    
    res.json({
      success: true,
      productGroups,
      budgetYear: parseInt(budgetYear),
      salesRep: salesRep || '__ALL__'
    });
    
  } catch (error) {
    console.error('âŒ Error fetching budget product groups:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * DELETE /api/aebf/delete-divisional-budget/:division/:budgetYear
 * Delete all divisional budget data for a specific division and year
 */
router.delete('/delete-divisional-budget/:division/:budgetYear', async (req, res) => {
  console.log('ðŸ—‘ï¸ DELETE divisional budget request received:', req.params);
  const client = await pool.connect();
  
  try {
    // URL decode the division parameter to handle spaces and special characters
    const division = decodeURIComponent(req.params.division);
    const budgetYear = req.params.budgetYear;
    const year = parseInt(budgetYear);
    
    console.log(`Deleting divisional budget for: Division="${division}", Year=${year}`);
    
    await client.query('BEGIN');
    
    // Debug: Check what records exist before delete
    const preCheckResult = await client.query(`
      SELECT division, year, COUNT(*) as count 
      FROM public.fp_divisional_budget 
      WHERE UPPER(division) = UPPER($1) AND year = $2
      GROUP BY division, year
    `, [division, year]);
    console.log('ðŸ” Pre-delete check:', preCheckResult.rows);
    
    // Also check all divisions/years in the table
    const allDataResult = await client.query(`
      SELECT division, year, COUNT(*) as count 
      FROM public.fp_divisional_budget 
      GROUP BY division, year
      ORDER BY division, year
    `);
    console.log('ðŸ“Š All data in fp_divisional_budget:', allDataResult.rows);
    
    // First, ensure the archive table exists
    await client.query(`
      CREATE TABLE IF NOT EXISTS fp_divisional_budget_archive (
        id SERIAL PRIMARY KEY,
        division VARCHAR(50),
        year INTEGER,
        month INTEGER,
        product_group VARCHAR(100),
        metric VARCHAR(20),
        value NUMERIC(18,4),
        material VARCHAR(100),
        process VARCHAR(100),
        uploaded_filename VARCHAR(500),
        uploaded_at TIMESTAMP,
        archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        archived_reason VARCHAR(255)
      )
    `);
    
    // Archive existing data before deletion (if any records exist)
    if (preCheckResult.rows.length > 0) {
      const archiveQuery = `
        INSERT INTO fp_divisional_budget_archive (
          division, year, month, product_group, metric, value, material, process,
          uploaded_filename, uploaded_at, archived_at, archived_reason
        )
        SELECT 
          division, year, month, product_group, metric, value, material, process,
          uploaded_filename, uploaded_at, CURRENT_TIMESTAMP, 'Manual deletion by user'
        FROM public.fp_divisional_budget
        WHERE UPPER(division) = UPPER($1)
          AND year = $2
      `;
      
      try {
        await client.query(archiveQuery, [division, year]);
        console.log('âœ… Divisional budget archived before deletion');
      } catch (archiveError) {
        console.warn('âš ï¸ Archive failed (non-critical):', archiveError.message);
        // Continue with deletion even if archive fails
      }
    }
    
    // Delete from fp_divisional_budget
    const deleteResult = await client.query(`
      DELETE FROM public.fp_divisional_budget
      WHERE UPPER(division) = UPPER($1) 
        AND year = $2
    `, [division, year]);
    
    console.log(`âœ… Deleted ${deleteResult.rowCount} records from fp_divisional_budget`);
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Divisional budget deleted successfully',
      deletedCount: deleteResult.rowCount,
      division: division,
      budgetYear: year
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Error deleting divisional budget:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  } finally {
    client.release();
  }
});

module.exports = router;
